%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 152690130_258063421
  Name: "GS.Зарплата.Пролог"
  Caption: "Пролог-скрипты"
  Version: "1.0.0.11"
  Optional: False
  Internal: True
  MD5: 5CD4352F882F56B9F805B94FA2309413
Objects: 
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189469_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "lib"
      COMMENT: ~
      SCRIPT: | 
        % lib
        
        %:- ['../gd_pl_state/date'].
        
        % desc for predsort
        desc(Order, Term1, Term2) :-
            compare(Order0, Term1, Term2),
            ( Order0 = '>', Order = '<'
            ; Order0 = '<', Order = '>'
            ; Order = Order0
            ),
            !.
        
        % atomic_list_to_string(+List, -String)
        atomic_list_to_string(List, String) :-
            current_predicate( atomics_to_string/2 ),
            atomics_to_string(List, String),
            !.
        atomic_list_to_string(List, String) :-
            atomic_list_concat(List, Atom),
            atom_string(Atom, String),
            !.
        % atomic_list_to_string(+List, +Separator, -String)
        atomic_list_to_string(List, Separator, String) :-
            current_predicate( atomics_to_string/3 ),
            atomics_to_string(List, Separator, String),
            !.
        atomic_list_to_string(List, Separator, String) :-
            atomic_list_concat(List, Separator, Atom),
            atom_string(Atom, String),
            !.
        
        % date_format(+DateIn, -DateOut)
        date_format(DateIn, DateOut) :-
            date_format(DateIn, DateOut, ru),
            !.
        % date_format(+DateIn, -DateOut, ?Locale)
        date_format(DateIn, DateOut, ru) :-
            atom_date(DateIn, _),
            atom_chars(DateIn, [Y1, Y2, Y3, Y4, '-', M1, M2, '-', D1, D2]),
            atom_chars(DateOut, [D1, D2, '.', M1, M2, '.', Y1, Y2, Y3, Y4]).
        date_format(date(Y, M, D), DateOut, Locale) :-
            atom_date(DateIn, date(Y, M, D)),
            date_format(DateIn, DateOut, Locale).
        date_format(_, '', _).
        
        % month_name(?Month, ?Name)
        month_name(Month, Name) :-
            month_name(Month, Name, ru).
        %
        month_name(1, "январь", ru).
        month_name(2, "февраль", ru).
        month_name(3, "март", ru).
        month_name(4, "апрель", ru).
        month_name(5, "май", ru).
        month_name(6, "июнь", ru).
        month_name(7, "июль", ru).
        month_name(8, "август", ru).
        month_name(9, "сентябрь", ru).
        month_name(10, "октябрь", ru).
        month_name(11, "ноябрь", ru).
        month_name(12, "декабрь", ru).
        
        % term_to_file(+Term, +FilePath, +Mode)
        term_to_file(Term, FilePath, Mode) :-
            memberchk(Mode, [write, append]),
            open(FilePath, Mode, Stream, [encoding(utf8)]),
            forall( catch(Term, _, fail),
                    ( writeq(Stream, Term), write(Stream,'.'), nl(Stream) )
                  ),
            close(Stream, [force(true)]),
            !.
        term_to_file(Term, FilePath) :-
            term_to_file(Term, FilePath, write),
            !.
        
        % get_local_stamp(-Stamp)
        get_local_stamp(Stamp) :-
            get_local_date_time(DateTime),
            get_time(TimeStamp),
            Fract is round(float_fractional_part(TimeStamp) * 1000) // 1,
            atomic_list_concat([DateTime, '.', Fract], Stamp),
            !.
        
        % день недели
        weekday(date(Year, Month, Day), WeekDay) :-
            A is (14 - Month) // 12,
            Y is Year - A,
            M is Month + 12 * A - 2,
            WeekDay0 is (7000 + (Day + Y + Y // 4 - Y // 100 + Y // 400 + (31 * M) // 12)) mod 7,
            WeekDay is WeekDay0 + 1,
            !.
        weekday(Date, WeekDay) :-
            atom_date(Date, date(Year, Month, Day)),
            weekday(date(Year, Month, Day), WeekDay),
            !.
        
        % подготовка SQL-строки
        prepare_sql(InSQL, [], InSQL) :-
            !.
        prepare_sql(InSQL,[Key-Value|Pairs], OutSQL) :-
            replace_all(InSQL, Key, Value, InSQL1),
            !,
            prepare_sql(InSQL1, Pairs, OutSQL).
        
        % to_currency(+NumIn, -NumOut)
        to_currency(NumIn, NumOut) :-
            to_currency(NumIn, NumOut, 4),
            !.
        % to_currency(+NumIn, -NumOut, +Round)
        to_currency(NumIn, NumOut, Round) :-
            number(NumIn), integer(Round),
            NumOut is float( round( NumIn * (10 ** Round) ) / (10 ** Round) ),
            !.
        
        % round_sum(+SumIn, +SumOut, +RoundType, +RoundValue)
        round_sum(SumIn, SumOut, RoundType, RoundValue) :-
            number(SumIn), integer(RoundType), number(RoundValue),
            Delta = 0.00001,
            round_sum(SumIn, SumOut, RoundType, RoundValue, Delta),
            !.
        % round_sum(+SumIn, +SumOut, +RoundType, +RoundValue, +Delta)
        round_sum(SumIn, SumOut, 1, _, Delta) :-
            SumOut is round((SumIn + Delta) / 10) * 10,
            !.
        round_sum(SumIn, SumOut, 2, RoundValue, Delta) :-
            SumOut is round((SumIn + Delta) / RoundValue) * RoundValue,
            !.
        round_sum(SumIn, SumOut, 3, RoundValue, Delta) :-
            SumOut is float_integer_part((SumIn + Delta) / RoundValue) * RoundValue,
            !.
        round_sum(Sum, Sum, _, _, _) :-
            !.
        
        % exist_in(+Search, +In)
        exist_in(Search, In) :-
            text_list([Search, In], [SearchCodes, InCodes]),
            append(_, MiddleCodes, InCodes),
            append(SearchCodes, _, MiddleCodes),
            !.
        
        % replace_all(+In, +Search, +Replace, -Out)
        replace_all(In, Search, Replace, Out) :-
            replace(In, Search, Replace, In1),
            \+ In = In1,
            !,
            replace_all(In1, Search, Replace, Out).
        replace_all(In, _, _, In).
        
        % replace(+In, +Search, +Replace, -Out)
        replace(In, Search, Replace, Out) :-
            text_list([In, Search, Replace], [InCodes, SearchCodes, ReplaceCodes]),
            replace_list(InCodes, SearchCodes, ReplaceCodes, OutCodes),
            text_in_out(In, OutCodes, Out),
            !.
        replace(In, _, _, In).
        
        % replace_list(+In, +Search, +Replace, -Out)
        replace_list(In, Search, Replace, Out) :-
            append(Part1, Middle, In),
            append(Search, Part2, Middle),
            append([Part1, Replace, Part2], Out),
            !.
        
        %
        text_list([], []) :-
            !.
        text_list([Head|Teil], [Head1|Rest]) :-
            text_in_out(Head, Head1, Head),
            !,
            text_list(Teil, Rest).
        
        %
        text_in_out(In, OutCodes, Out) :-
            ( atom(In), atom_codes(Out, OutCodes)
            ; string(In), string_codes(Out, OutCodes)
            ; number(In), number_codes(Out, OutCodes)
            ; integer_list(In), Out = In ),
            !.
        
        %
        integer_list([]) :-
            !.
        integer_list([Head|Tail]) :-
            integer(Head),
            !,
            integer_list(Tail).
        
        %
        member_list([], _) :-
            !.
        member_list([Head|Tail], List) :-
            memberchk(Head, List),
            !,
            member_list(Tail, List).
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-10-29T14:58:20+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189468_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "params"
      COMMENT: ~
      SCRIPT: | 
        % params
        
        %:- [lib].
        /* member_list */
        
        :-
            dynamic(param_list/3),
            multifile(param_list/3),
            discontiguous(param_list/3).
        
        % param_list(?Scope, ?Type, ?Pairs)
        %   Scope - name of context
        %   Type  - protocol support
        %       Client: in; data; got; restart; test; ...
        %       Server: run; query; temp; log; out; clean; error; ...
        %   Pairs - list of pairs Key-Value or mixed with other
        
        % new_param_list(+Scope, +Type, +Pairs)
        new_param_list(Scope, Type, Pairs) :-
            \+ param_list(Scope, Type, Pairs),
            assertz( param_list(Scope, Type, Pairs) ),
            !.
        new_param_list(_, _, _) :-
            !.
        
        % dispose_param_list(?Scope, ?Type, ?Pairs)
        dispose_param_list(Scope, Type, Pairs) :-
            retractall( param_list(Scope, Type, Pairs) ),
            !.
        
        % get_param(?Scope, ?Type, ?Param)
        get_param(Scope, Type, Param) :-
            param_list(Scope, Type, Pairs),
            memberchk(Param, Pairs).
        % get_param(?Scope, ?Type, ?Param, ?Pairs)
        get_param(Scope, Type, Param, Pairs) :-
            param_list(Scope, Type, Pairs),
            memberchk(Param, Pairs).
        
        % get_param_list(?Scope, ?Type, ?Params)
        get_param_list(Scope, Type, Params) :-
            param_list(Scope, Type, Pairs),
            member_list(Params, Pairs).
        % get_param_list(?Scope, ?Type, ?Params, ?Pairs)
        get_param_list(Scope, Type, Params, Pairs) :-
            param_list(Scope, Type, Pairs),
            member_list(Params, Pairs).
        
        %
        get_scope(Scope) :-
            setof(Scope, Type^Pairs^param_list(Scope, Type, Pairs), ScopeList),
            member(Scope, ScopeList).
        
        %
        get_scope_list(ScopeList) :-
            setof(Scope, Type^Pairs^param_list(Scope, Type, Pairs), ScopeList),
            !.
        
        %
        get_type(Type) :-
            setof(Type, Scope^Pairs^param_list(Scope, Type, Pairs), TypeList),
            member(Type, TypeList).
        
        %
        get_type_list(TypeList) :-
            setof(Type, Scope^Pairs^param_list(Scope, Type, Pairs), TypeList),
            !.
        
        %
        get_scope_type(Scope-Type) :-
            setof(Scope-Type, Pairs^param_list(Scope, Type, Pairs), ScopeTypeList),
            member(Scope-Type, ScopeTypeList).
        
        %
        get_scope_type_list(ScopeTypeList) :-
            setof(Scope-Type, Pairs^param_list(Scope, Type, Pairs), ScopeTypeList),
            !.
        
        %
        param_list_debug(Scope, Param) :-
            Type = debug,
            % взять локальное время
            get_local_stamp(DT),
            % удалить отладочную информацию
            dispose_param_list(Scope, Type, [Param|_]),
            % записать отладочную информацию
            new_param_list(Scope, Type, [Param, DT]),
            !.
        
        %
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-08-01T17:33:00+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151042959_187967073
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "wg_data_mix"
      COMMENT: ~
      SCRIPT: | 
        %% wg_data_mix
        %  смешанные данные для twg_avg_wage, twg_fee, twg_pu
        %
        
        %:- ['../gd_pl_state/date', '../gd_pl_state/dataset'].
        %:- ['../common/lib', '../common/params'].
        
        /* реализация - общий код */
        
        % взять среднюю зп по РБ
        get_avg_salary_rb(Scope, Y-M, MonthAvgSalary) :-
            % первая дата месяца
            atom_date(FirstMonthDate, date(Y, M, 1)),
            % взять среднюю зп
            findall( AvgSalary0,
                          % взять данные по средней зп
                        ( get_data(Scope, kb, gd_const_AvgSalaryRB, [
                                    fConstDate-ConstDate, fAvgSalaryRB-AvgSalary0]),
                          % где дата константы меньше первой даты месяца
                          ConstDate @< FirstMonthDate
                        ),
            % в список средних зп
            AvgSalaryList),
            % проверить список средних зп
            \+ AvgSalaryList = [],
            % последние данные средней зп за месяц
            last(AvgSalaryList, MonthAvgSalary),
            !.
        get_avg_salary_rb(Scope, _, 0) :-
            new_param_list(Scope, error, [pError-"Введите константу 'Средняя зарплата по РБ'"]),
            !.
        
        % взять БВ
        get_min_wage(Scope, DateCalcTo, MinWage) :-
            findall( MinWage0,
                          % взять данные по БВ
                        ( get_data(Scope, kb, usr_wg_FCRate, [
                                    fDate-Date, fMinWage-MinWage0]),
                          % где дата константы меньше первой даты месяца
                          Date @< DateCalcTo
                        ),
            % в список БВ
            MinWageList),
            % последние данные по БВ
            last(MinWageList, MinWage),
            !.
        get_min_wage(_, _, 0) :-
            !.
        
        % взять БПМ
        get_budget(Scope, DateCalcTo, Budget) :-
            findall( Budget0,
                          % взять данные по БПМ
                        ( get_data(Scope, kb, gd_const_budget, [
                                    fConstDate-ConstDate, fBudget-Budget0]),
                          % где дата константы меньше первой даты месяца
                          ConstDate @< DateCalcTo
                        ),
            % в список БПМ
            BudgetList),
            % последние данные по БПМ
            last(BudgetList, Budget),
            !.
        get_budget(_, _, 0) :-
            !.
        
        % взять дату последнего приема на работу
        get_last_hire(Scope, PK, DateIn) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять даты
            findall( EmplKey-FirstMoveKey-DateIn0,
                     % для первого движения по типу 1 (прием на работу)
                     get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey,
                                 fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                                 fDateBegin-DateIn0, fMovementType-1 ]),
            % в список дат приема на работу
            DateInList ),
            % определить дату последнего приема на работу
            last(DateInList, EmplKey-FirstMoveKey-DateIn),
            !.
        
        % формирование временных данных по графику работы
        make_schedule(Scope, PK) :-
            % временные данные по графику работы уже есть
            get_param_list(Scope, temp, [pScheduleKey-_|PK]),
            !.
        make_schedule(Scope, PK) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные по движению
            findall( Date-ScheduleKey,
                     get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                 fDateBegin-Date, fScheduleKey-ScheduleKey]),
            MoveList ),
            % взять дату ограничения расчета
            get_param_list(Scope, run, [pDateCalcTo-DateCalcTo|PK]),
            % добавить временные данные по графику работы
            add_schedule(Scope, PK, MoveList, DateCalcTo),
            !.
        
        % добавить временные данные по графику работы
        add_schedule(_, _, [], _) :-
            !.
        add_schedule(Scope, PK, [DateFrom-ScheduleKey], DateCalcTo) :-
            append(PK,
                    [pDateFrom-DateFrom, pDateTo-DateCalcTo, pScheduleKey-ScheduleKey],
                        Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        add_schedule(Scope, PK, [DateFrom-ScheduleKey, DateTo-ScheduleKey1 | MoveList], DateCalcTo) :-
            append(PK,
                    [pDateFrom-DateFrom, pDateTo-DateTo, pScheduleKey-ScheduleKey],
                        Pairs),
            new_param_list(Scope, temp, Pairs),
            !,
            add_schedule(Scope, PK, [DateTo-ScheduleKey1 | MoveList], DateCalcTo).
        
        % взять последний график рабочего времени
        get_last_schedule(Scope, PK, ScheduleKey) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять график
            findall( ScheduleKey0,
                     % для движения по сотруднику
                     get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                 fScheduleKey-ScheduleKey0]),
            % в список графиков
            ScheduleKeyList ),
            % определить последний график рабочего времени
            last(ScheduleKeyList, ScheduleKey),
            !.
        
        % проверить вхождение даты в график
        check_schedule(Scope, PK, TheDay, ScheduleKey) :-
            append(PK,
                    [pDateFrom-DateFrom, pDateTo-DateTo, pScheduleKey-ScheduleKey],
                        Pairs),
            get_param_list(Scope, temp, Pairs),
            TheDay @>= DateFrom, TheDay @< DateTo,
            !.
        check_schedule(Scope, PK, _, ScheduleKey) :-
            get_last_schedule(Scope, PK, ScheduleKey),
            !.
        
        % расчитать табель за месяц по одному из параметров
        calc_month_tab(Scope, PK, Y-M, TabDays) :-
            % параметры выбора табеля
            member(TabelOption, [tbl_cal_flex, tbl_cal, tbl_charge, dbf_sums]),
            % взять данные из табеля
            findall( Date-DOW-HOW,
                    % для проверяемого месяца
                    ( usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, DOW, HOW, _, TabelOption),
                    % с контролем наличия дней или часов
                    once( ( DOW > 0 ; HOW > 0 ) )
                    ),
            % в список дата-день-часы
            TabDays),
            % проверить список табеля
            \+ TabDays = [],
            !.
        calc_month_tab(_, _, _, []) :-
            !.
        
        % сумма дней и часов
        sum_days_houres(ListDays, Days, Houres) :-
            sum_days_houres(ListDays, Days, Houres, '', ''),
            !.
        sum_days_houres(ListDays, Days, Houres, DateBegin, DateEnd) :-
            sum_days_houres(ListDays, Days, Houres, 0, 0, DateBegin, DateEnd),
            !.
        %
        sum_days_houres([], Days, Houres, Days, Houres, _, _).
        sum_days_houres([Date-DOW-HOW|ListDays], Days, Houres, Days0, Houres0, DateBegin, DateEnd) :-
              % если в заданном периоде
            ( ( Date @>= DateBegin, Date @=< DateEnd
              % или полный расчет
              ; [DateBegin, DateEnd] = ['', '']
              ),
              % то добавить дни и часы
              Days1 is Days0 + DOW,
              Houres1 is Houres0 + HOW
            ; % иначе исключать
              Days1 is Days0,
              Houres1 is Houres0
            ),
            !,
            sum_days_houres(ListDays, Days, Houres, Days1, Houres1, DateBegin, DateEnd).
        
        /* реализация - смешанные данные */
        
        %% взять данные по начислению
        % начисление из TblCharge
        usr_wg_TblCharge_mix(Scope, ArgPairs, ChargeOption) :-
            ChargeOption = tbl_charge,
            get_data(Scope, kb, usr_wg_TblCharge, [fPayPeriod-PayPeriod|ArgPairs]),
            once( ( PayPeriod < 2
                  ; \+ memberchk(Scope, [wg_avg_wage_avg]) )
                ).
        % или начисление из dbf
        % с согласованием спецификации по TblCharge
        usr_wg_TblCharge_mix(Scope, ArgPairs, ChargeOption) :-
            ChargeOption = dbf_sums,
            % спецификация usr_wg_TblCharge
            ValuePairs = [
                        fEmplKey-EmplKey, fFirstMoveKey-_,
                        fCalYear-CalYear, fCalMonth-CalMonth, fDateBegin-DateBegin,
                        fDebit-Debit, fFeeTypeKey-FeeTypeKey
                        ],
            member_list(ArgPairs, ValuePairs),
            % спецификация usr_wg_DbfSums
            DataPairs =  [
                        fEmplKey-EmplKey,
                        fInYear-CalYear, fInMonth-CalMonth, fDateBegin-DateBegin,
                        fInSum-Debit, fSickProp-FeeTypeKey
                        ],
            get_data(Scope, kb, usr_wg_DbfSums, DataPairs).
        
        %% взять данные по графику
        % день месяца по календарному графику
        usr_wg_TblDayNorm_mix(Scope, PK, Y-M, Date, Duration, WorkDay, NormOption) :-
            NormOption = tbl_cal_flex,
            get_Flex_by_type(Scope, PK, Y-M, Date, WorkDay, Duration, _, "plan").
        % или день месяца по справочнику графика рабочего времени
        usr_wg_TblDayNorm_mix(Scope, PK, Y-M, TheDay, WDuration, WorkDay, NormOption) :-
            NormOption = tbl_day_norm,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_data(Scope, kb, usr_wg_TblCalDay, [
                        fScheduleKey-ScheduleKey,
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fWYear-Y, fWMonth-M, fTheDay-TheDay,
                        fWDuration-WDuration, fWorkDay-WorkDay ]),
            check_schedule(Scope, PK, TheDay, ScheduleKey).
        
        %% взять данные по табелю
        % день месяца по табелю мастера
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, Days, Duration, HoureType, TabelOption) :-
            TabelOption = tbl_cal_flex,
            get_Flex_by_type(Scope, PK, Y-M, Date, Days, Duration, HoureType, "fact").
        % или день месяца по табелю
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, Days, Duration, HoureType, TabelOption) :-
            TabelOption = tbl_cal,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_data(Scope, kb, usr_wg_TblCalLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDate-Date,
                        fDuration-Duration, fHoureType-HoureType]),
            once( (Duration > 0, Days = 1 ; Days = 0) ).
        % или табель дни-часы из начислений
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, DOW, HOW, 0, TabelOption) :-
            TabelOption = tbl_charge,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            ArgPairs = [fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-Date,
                        fFeeTypeKey-FeeTypeKey, fDOW-DOW, fHOW-HOW],
            get_data(Scope, kb, usr_wg_TblCharge, [fPayPeriod-_|ArgPairs]),
            once( get_data(Scope, kb, usr_wg_FeeType, [
                            fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                            fFeeTypeKey-FeeTypeKey, fAvgDayHOW-1]) ).
        % или день месяца из dbf
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, InDays, InHoures, 0, TabelOption) :-
            TabelOption = dbf_sums,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_data(Scope, kb, usr_wg_DbfSums, [
                        fEmplKey-EmplKey, fInDays-InDays, fInHoures-InHoures,
                        fInYear-Y, fInMonth-M, fDateBegin-Date]).
        
        % день месяца по календарному графику или табелю мастера
        % FlexType: "plan" ; "fact"
        get_Flex_by_type(Scope, PK, Y-M, Date, Days, Duration, HoureType, FlexType) :-
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, _),
            length(TeilArgs, 62),
            Term =..[ usr_wg_TblCal_FlexLine, FlexType, EmplKey, FirstMoveKey, Y, M, _ | TeilArgs ],
            catch( call( Term ), _, fail ),
            between(1, 31, D),
            atom_date(Date, date(Y, M, D)),
            S is (D - 1) * 2 + 6 + 1,
            H is S + 1,
            arg(S, Term, Duration0),
            once( ( number(Duration0), Duration = Duration0
                    ; atom_number(Duration0, Duration)
                    ; Duration = 0 ) ),
            arg(H, Term, HoureType0),
            once( ( number(HoureType0), HoureType = HoureType0
                    ; atom_number(HoureType0, HoureType)
                    ; HoureType = 0 ) ),
            once( (Duration > 0, Days = 1 ; Days = 0) ).
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-03-11T10:27:17+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189470_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151189370_18175251
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_avg_wage_sql"
      COMMENT: ~
      SCRIPT: | 
        %% twg_avg_wage_sql
        %  спецификации и sql-шаблоны для базы знаний twg_avg_wage
        %
        
        :-  style_check(-atom),
            GetSQL = [gd_pl_ds/5, get_sql/5],
            %dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql([
                    % section twg_avg_wage
                    %  05. Начисление отпусков
                    -usr_wg_DbfSums/8, % 05, 06, 12
                    usr_wg_MovementLine/15, % 05, 06, 12
                    usr_wg_FCRate/4,
                    usr_wg_TblCalDay/9, % 05, 06, 12
                    -usr_wg_TblDayNorm/8, % 05, 06
                    -usr_wg_TblYearNorm/5,
                    usr_wg_TblCalLine/7, % 05, 06, 12
                    usr_wg_TblCal_FlexLine/68, % 05, 06, 12
                    usr_wg_HourType/13, % 05, 06
                    usr_wg_TblCharge/10, % 05, 06, 12
                    usr_wg_FeeType/5, % 05, 06, 12
                    usr_wg_FeeTypeNoCoef/4,
                    usr_wg_BadHourType/3,
                    usr_wg_BadFeeType/3,
                    usr_wg_SpecDep/3,
                    %  06. Начисление больничных
                    usr_wg_AvgWage/6,
                    usr_wg_FeeTypeProp/4, % 06, 12
                    wg_holiday/1,
                    usr_wg_ExclDays/8, % 05, 06
                    % 12. Начисление по-среднему
                    usr_wg_TblChargeBonus/8,
                    % section twg_struct
                    %wg_holiday/1,
                    wg_vacation_slice/2,
                    wg_vacation_compensation/3,
                    gd_const_budget/2,
                    gd_const_AvgSalaryRB/2, % 06, 12
                    %usr_wg_TblDayNorm/8,
                    wg_job_ill_type/1,
                    wg_child_ill_type/1,
                    % section twg_rule
                    usr_wg_pl_Rule/2,
                    -
                    ]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            memberchk(Functor/Arity, ValidSQL),
            !.
        
        %  05. Начисление отпусков
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_DbfSums, 8, [
            fEmplKey-integer, fInSum-float, fInDays-float, fInHoures-float,
            fInYear-integer, fInMonth-integer, fDateBegin-date,
            fSickProp-boolean
            ]).
        % usr_wg_DbfSums(EmplKey, InSum, InDays, InHoures, InYear, InMonth, DateBegin, SickProp)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_DbfSums/8,
        "
        SELECT
          Z.USR$EMPLKEY,
          COALESCE(Z.USR$SUM, 0) AS INSUM,
          COALESCE(Z.USR$DOW, 0) AS InDays,
          COALESCE(Z.USR$MID_HOW, 0) AS INHOURES,
          EXTRACT(YEAR FROM IDK.USR$DATEBEGIN) AS InYear,
          EXTRACT(MONTH FROM IDK.USR$DATEBEGIN) AS InMonth,
          IDK.USR$DATEBEGIN,
          USR$SICK_PROP AS SickProp
        FROM
          USR$GMK_SUMS Z
        JOIN
          USR$WG_TOTAL IDK
            ON IDK.DOCUMENTKEY  =  Z.USR$INDOCKEY
        WHERE
          Z.USR$EMPLKEY = pEmplKey
          AND
          IDK.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          IDK.USR$DATEBEGIN < 'pDateCalcTo'
        ORDER BY
          Z.USR$EMPLKEY,
          IDK.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]).
        
        gd_pl_ds(Scope, kb, usr_wg_MovementLine, 15, [
            fEmplKey-integer, fDocumentKey-integer, fFirstMoveKey-integer,
            fMoveYear-integer, fMoveMonth-integer, fDateBegin-date,
            fScheduleKey-integer, fMovementType-integer,
            fRate-float, fListNumber-string, fMSalary-float,
            fPayFormKey-integer, fSalaryKey-integer,
            fTSalary-float, fTHoureRate-float
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        % usr_wg_MovementLine(EmplKey, DocumentKey, FirstMoveKey,
        %   MoveYear, MoveMonth, DateBegin,
        %   ScheduleKey, MovementType, Rate, ListNumber, MSalary,
        %   PayFormKey, SalaryKey, TSalary, THoureRate)
        get_sql(Scope, kb, usr_wg_MovementLine/15,
        "
        SELECT
          ml.USR$EMPLKEY,
          ml.DOCUMENTKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          EXTRACT(YEAR FROM ml.USR$DATEBEGIN) AS MoveYear,
          EXTRACT(MONTH FROM ml.USR$DATEBEGIN) AS MoveMonth,
          ml.USR$DATEBEGIN,
          ml.USR$SCHEDULEKEY,
          ml.USR$MOVEMENTTYPE,
          COALESCE(ml.USR$RATE, 0) AS Rate,
          ml.USR$LISTNUMBER,
          COALESCE(ml.USR$MSALARY, 0) AS MSalary,
          COALESCE(ml.USR$PAYFORMKEY, 0) AS PayFormKey,
          (SELECT id FROM GD_P_GETID(pPayFormSalary_ruid)) AS SalaryKey,
          COALESCE(ml.USR$TSALARY, 0) AS TSalary,
          COALESCE(USR$THOURRATE, 0) AS THoureRate
        FROM
          USR$WG_MOVEMENTLINE ml
        WHERE
          ml.USR$EMPLKEY = pEmplKey
          AND
          ml.USR$FIRSTMOVE = pFirstMoveKey
          AND
          NOT ml.USR$MOVEMENTTYPE IN(7)
        ORDER BY
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE,
          ml.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pPayFormSalary_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_FCRate, 4, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fDate-date, fFCRateSum-float
            ]).
        % usr_wg_FCRate(EmplKey, FirstMoveKey, Date, FCRateSum)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_FCRate/4,
        "
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          fc.USR$WG_DATE,
          fc.USR$WG_FCRATESUM
        FROM
          USR$WG_FCRATE fc
        ORDER BY
          fc.USR$WG_DATE
        ",
            [
            pEmplKey-_, pFirstMoveKey-_
            ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCalDay, 9, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fTheDay-date, fWYear-integer, fWMonth-integer, fWDay-integer,
            fWDuration-float, fWorkDay-integer, fScheduleKey-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        % usr_wg_TblCalDay(EmplKey, FirstMoveKey, TheDay, WYear, WMonth, WDay,
        %    WDuration, WorkDay, ScheduleKey)
        get_sql(Scope, kb, usr_wg_TblCalDay/9,
        "
        SELECT
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          tcd.THEDAY,
          EXTRACT(YEAR FROM tcd.THEDAY) AS WYEAR,
          EXTRACT(MONTH FROM tcd.THEDAY) AS WMONTH,
          EXTRACT(DAY FROM tcd.THEDAY) AS WDAY,
          tcd.WDURATION,
          tcd.WORKDAY,
          ml.USR$SCHEDULEKEY
        FROM
        (
        SELECT DISTINCT
          USR$EMPLKEY,
          USR$FIRSTMOVE,
          USR$SCHEDULEKEY
        FROM
          USR$WG_MOVEMENTLINE
        WHERE
          USR$EMPLKEY = pEmplKey
          AND
          USR$FIRSTMOVE = pFirstMoveKey
        ) ml
        JOIN
          WG_TBLCAL tc
            ON tc.ID = ml.USR$SCHEDULEKEY
        JOIN
          WG_TBLCALDAY tcd
            ON tcd.TBLCALKEY = tc.ID
        WHERE
          COALESCE(tcd.WDURATION, 0) > 0
          AND
          (tcd.THEDAY >= 'pDateCalcFrom' OR tcd.THEDAY >= 'pDateNormFrom')
          AND
          (tcd.THEDAY < 'pDateCalcTo' OR tcd.THEDAY < 'pDateNormTo')
        ORDER BY
          tcd.THEDAY
        ",
            [
            pEmplKey-_, pFirstMoveKey-_,
            pDateCalcFrom-_, pDateCalcTo-_,
            pDateNormFrom-_, pDateNormTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblDayNorm, 8, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fWYear-integer, fWMonth-integer, fTheDay-date, fWDay-integer,
            fWDuration-float, fWorkDay-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        % usr_wg_TblDayNorm(EmplKey, FirstMoveKey, WYear, WMonth, TheDay, WDay, WDuration, WorkDay)
        get_sql(Scope, kb, usr_wg_TblDayNorm/8,
        "
        SELECT EmplKey, FirstMoveKey, WYear, WMonth, TheDay, WDay, WDuration, WorkDay
        FROM USR$WG_TBLCALDAY_P(pEmplKey, pFirstMoveKey, 'pDateCalcFrom', 'pDateCalcTo')
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_TblYearNorm, 5,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fWYear-integer,
            fWHoures-float, fWDays-integer
            ]).
        % usr_wg_TblYearNorm(EmplKey, FirstMoveKey, WYear, WHoures, WDays)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_TblYearNorm/5,
        "
        SELECT EmplKey, FirstMoveKey, WYear, SUM(WDuration) AS WHoures, SUM(WorkDay) AS WDays
        FROM USR$WG_TBLCALDAY_P(pEmplKey, pFirstMoveKey, 'pDateNormFrom', 'pDateNormTo')
        GROUP BY EmplKey, FirstMoveKey, WYear
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateNormFrom-_, pDateNormTo-_
            ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCalLine, 7, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDate-date,
            fDuration-float, fHoureType-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        % usr_wg_TblCalLine(EmplKey, FirstMoveKey, CalYear, CalMonth, Date, Duration, HoureType)
        get_sql(Scope, kb, usr_wg_TblCalLine/7,
        "
        SELECT
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tcl.USR$DATE) AS CalYear,
          EXTRACT(MONTH FROM tcl.USR$DATE) AS CalMonth,
          tcl.USR$DATE,
          tcl.USR$DURATION,
          tcl.USR$HOURTYPE
        FROM
          USR$WG_TBLCAL tc
        JOIN
          USR$WG_TBLCALLINE tcl
            ON tcl.MASTERKEY = tc.DOCUMENTKEY
        WHERE
          tc.USR$EMPLKEY = pEmplKey
          AND
          tc.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND
          tcl.USR$DATE >= 'pDateCalcFrom'
          AND
          tcl.USR$DATE < 'pDateCalcTo'
        ORDER BY
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          tcl.USR$DATE
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, [
            fFlexType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fS1-variant, fH1-variant, fS2-variant, fH2-variant,
            fS3-variant, fH3-variant, fS4-variant, fH4-variant,
            fS5-variant, fH5-variant, fS6-variant, fH6-variant,
            fS7-variant, fH7-variant, fS8-variant, fH8-variant,
            fS9-variant, fH9-variant, fS10-variant, fH10-variant,
            fS11-variant, fH11-variant, fS12-variant, fH12-variant,
            fS13-variant, fH13-variant, fS14-variant, fH14-variant,
            fS15-variant, fH15-variant, fS16-variant, fH16-variant,
            fS17-variant, fH17-variant, fS18-variant, fH18-variant,
            fS19-variant, fH19-variant, fS20-variant, fH20-variant,
            fS21-variant, fH21-variant, fS22-variant, fH22-variant,
            fS23-variant, fH23-variant, fS24-variant, fH24-variant,
            fS25-variant, fH25-variant, fS26-variant, fH26-variant,
            fS27-variant, fH27-variant, fS28-variant, fH28-variant,
            fS29-variant, fH29-variant, fS30-variant, fH30-variant,
            fS31-variant, fH31-variant
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        % usr_wg_TblCal_FlexLine(FlexType, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, S1, H1, ..., S31, H31)
        get_sql(Scope, kb, usr_wg_TblCal_FlexLine/68,
        "
        SELECT
          CASE gd.DOCUMENTTYPEKEY
            WHEN
              (SELECT id FROM gd_ruid WHERE xid = pTblCal_DocType_Plan_xid1 AND dbid = pTblCal_DocType_Plan_dbid1)
                THEN 'plan'
            WHEN
              (SELECT id FROM gd_ruid WHERE xid = pTblCal_DocType_Plan_xid2 AND dbid = pTblCal_DocType_Plan_dbid2)
                THEN 'plan'
            WHEN
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Fact_ruid))
                THEN 'fact'
            ELSE
                'unknown'
          END
            AS FlexType,
          tcfl.USR$EMPLKEY,
          tcfl.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth,
          t.USR$DATEBEGIN,
          tcfl.USR$S1, tcfl.USR$H1, tcfl.USR$S2, tcfl.USR$H2,
          tcfl.USR$S3, tcfl.USR$H3, tcfl.USR$S4, tcfl.USR$H4,
          tcfl.USR$S5, tcfl.USR$H5, tcfl.USR$S6, tcfl.USR$H6,
          tcfl.USR$S7, tcfl.USR$H7, tcfl.USR$S8, tcfl.USR$H8,
          tcfl.USR$S9, tcfl.USR$H9, tcfl.USR$S10, tcfl.USR$H10,
          tcfl.USR$S11, tcfl.USR$H11, tcfl.USR$S12, tcfl.USR$H12,
          tcfl.USR$S13, tcfl.USR$H13, tcfl.USR$S14, tcfl.USR$H14,
          tcfl.USR$S15, tcfl.USR$H15, tcfl.USR$S16, tcfl.USR$H16,
          tcfl.USR$S17, tcfl.USR$H17, tcfl.USR$S18, tcfl.USR$H18,
          tcfl.USR$S19, tcfl.USR$H19, tcfl.USR$S20, tcfl.USR$H20,
          tcfl.USR$S21, tcfl.USR$H21, tcfl.USR$S22, tcfl.USR$H22,
          tcfl.USR$S23, tcfl.USR$H23, tcfl.USR$S24, tcfl.USR$H24,
          tcfl.USR$S25, tcfl.USR$H25, tcfl.USR$S26, tcfl.USR$H26,
          tcfl.USR$S27, tcfl.USR$H27, tcfl.USR$S28, tcfl.USR$H28,
          tcfl.USR$S29, tcfl.USR$H29, tcfl.USR$S30, tcfl.USR$H30,
          tcfl.USR$S31, tcfl.USR$H31
        FROM
          GD_DOCUMENT gd
        JOIN
          USR$WG_TBLCAL_FLEXLINE tcfl
            ON gd.ID = tcfl.DOCUMENTKEY
        JOIN
          USR$WG_TBLCAL_FLEX tcf
            ON tcf.DOCUMENTKEY = tcfl.MASTERKEY
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tcf.USR$TOTALDOCKEY
        WHERE
          tcfl.USR$EMPLKEY = pEmplKey
          AND
          tcfl.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND
          t.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDateCalcTo'
         ORDER BY
           tcfl.USR$EMPLKEY,
           tcfl.USR$FIRSTMOVEKEY,
           t.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pTblCal_DocType_Plan_xid1-_, pTblCal_DocType_Plan_dbid1-_,
            pTblCal_DocType_Plan_xid2-_, pTblCal_DocType_Plan_dbid2-_,
            pTblCal_DocType_Fact_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg,
                wg_struct_sick
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_HourType, 13, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fID-integer, fCode-string, fDigitCode-string,
            fDiscription-string, fIsWorked-integer, fShortName-string,
            fForCalFlex-integer, fForOverTime-integer, fForFlex-integer,
            fExcludeForSickList-integer, fExclType-string
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick
                ]).
        % usr_wg_HourType(EmplKey, FirstMoveKey,
        %   ID, Code, DigitCode, Description, IsWorked, ShortName,
        %   ForCalFlex, ForOverTime, ForFlex, ExcludeForSickList, ExclType)
        get_sql(Scope, kb, usr_wg_HourType/13,
        "
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          ht.ID,
          ht.USR$CODE,
          ht.USR$DIGITCODE,
          ht.USR$DISCRIPTION,
          ht.USR$ISWORKED,
          ht.USR$SHORTNAME,
          ht.USR$FORCALFLEX,
          ht.USR$FOROVERTIME,
          ht.USR$FORFLEX,
          ht.USR$WG_EXCLUDEFORSICKLIST,
          CASE ht.ID
            WHEN
              (SELECT id FROM GD_P_GETID(pKindDayHourType_ruid))
                THEN 'kind_day'
            ELSE
                'unknown'
          END
            AS ExclType
        FROM
          USR$WG_HOURTYPE ht
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pKindDayHourType_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge, 10, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fFeeTypeKey-integer, fDOW-float, fHOW-float,
            fPayPeriod-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        % usr_wg_TblCharge(EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, FeeTypeKey, DOW, HOW, PayPeriod)
        get_sql(Scope, kb, usr_wg_TblCharge/10,
        "
        SELECT
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$FEETYPEKEY,
          tch.USR$DOW,
          tch.USR$HOW,
          COALESCE(ft.USR$PAYPERIOD, 0) AS PayPeriod
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_FEETYPE ft
            ON ft.ID = tch.USR$FEETYPEKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          NOT tch.USR$DEBIT = 0
          AND
          tch.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          tch.USR$DATEBEGIN < 'pDateCalcTo'
          AND
          COALESCE(ft.USR$PAYPERIOD, 0) >= 0
        ORDER BY
          tch.USR$EMPLKEY,
          tch.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblChargeBonus, 8, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fFeeTypeKey-integer,
            fPayPeriod-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_avg
                ]).
        % usr_wg_TblChargeBonus(EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin,
        %   Debit, FeeTypeKey, PayPeriod)
        get_sql(Scope, kb, usr_wg_TblChargeBonus/8,
        "
        SELECT
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$FEETYPEKEY,
          COALESCE(ft.USR$PAYPERIOD, 0) AS PayPeriod
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_FEETYPE ft
            ON ft.ID = tch.USR$FEETYPEKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          NOT tch.USR$DEBIT = 0
          AND
          tch.USR$DATEBEGIN >= 'pDateBonusFrom'
          AND
          tch.USR$DATEBEGIN < 'pDateBonusTo'
          AND
          COALESCE(ft.USR$PAYPERIOD, 0) > 1
        ORDER BY
          tch.USR$EMPLKEY,
          tch.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateBonusFrom-_, pDateBonusTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_avg
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType, 5, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer,
            fAvgDayHOW-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        % usr_wg_FeeType(EmplKey, FirstMoveKey, FeeGroupKey, FeeTypeKey, AvgDayHOW)
        get_sql(Scope, kb, usr_wg_FeeType/5,
        "
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY,
          ft_avg.USR$AVGDAYHOW
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY IN
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_ruid))
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pFeeGroupKey_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_FeeTypeNoCoef, 4, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fFeeGroupKeyNoCoef-integer, fFeeTypeKeyNoCoef-integer
            ]).
        % usr_wg_FeeTypeNoCoef(EmplKey, FirstMoveKey, FeeGroupKeyNoCoef, FeeTypeKeyNoCoef)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_FeeTypeNoCoef/4,
        "
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY =
            (SELECT id FROM GD_P_GETID(pFeeGroupKeyNoCoef_ruid))
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pFeeGroupKeyNoCoef_ruid-_
            ]).
        
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_BadHourType, 3, [
            fEmplKey-integer, fFirstMoveKey-integer, fID-integer
            ]).
        % usr_wg_BadHourType(EmplKey, FirstMoveKey, ID)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_BadHourType/3,
        "
        SELECT
          pEmplKey AS EmplKey, pFirstMoveKey AS FirstMoveKey, id
        FROM USR$WG_HOURTYPE
        WHERE id IN
        (SELECT id FROM gd_ruid
        WHERE xid IN (pBadHourType_xid_IN)
        AND dbid = pBadHourType_dbid
        )
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pBadHourType_xid_IN-_, pBadHourType_dbid-_
            ]).
        
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_BadFeeType, 3, [
            fEmplKey-integer, fFirstMoveKey-integer, fID-integer
            ]).
        % usr_wg_BadFeeType(EmplKey, FirstMoveKey, ID)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_BadFeeType/3,
        "
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          ft.USR$WG_FEETYPEKEY AS id
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY =
            (SELECT id FROM GD_P_GETID(pBadFeeGroupKey_ruid))
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pBadFeeGroupKey_ruid-_
            ]).
        
        gd_pl_ds(-wg_avg_wage_vacation, kb, usr_wg_BadFeeType, 3, [
            fEmplKey-integer, fFirstMoveKey-integer, fID-integer
            ]).
        % usr_wg_BadFeeType(EmplKey, FirstMoveKey, ID)
        get_sql(-wg_avg_wage_vacation, kb, usr_wg_BadFeeType/3,
        "
        SELECT
          pEmplKey AS EmplKey, pFirstMoveKey AS FirstMoveKey, id
        FROM USR$WG_FEETYPE
        WHERE id IN
        (SELECT id FROM gd_ruid
        WHERE xid IN (pBadFeeType_xid_IN)
        AND dbid = pBadFeeType_dbid
        )
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pBadFeeType_xid_IN-_, pBadFeeType_dbid-_
            ]).
        
        gd_pl_ds(wg_avg_wage_vacation, kb, usr_wg_SpecDep, 3, [
            fEmplKey-integer, fFirstMoveKey-integer, fID-integer
            ]).
        % usr_wg_SpecDep(EmplKey, FirstMoveKey, ID)
        get_sql(wg_avg_wage_vacation, kb, usr_wg_SpecDep/3,
        "
        SELECT
          pEmplKey AS EmplKey, pFirstMoveKey AS FirstMoveKey, id
        FROM
          GD_P_GETID(pSpecDep_ruid)
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pSpecDep_ruid-_
            ]).
        
        %  06. Начисление больничных
        gd_pl_ds(Scope, kb, usr_wg_DbfSums, 8, [
            fEmplKey-integer, fInSum-float, fInDays-float, fInHoures-float,
            fInYear-integer, fInMonth-integer, fDateBegin-date,
            fSickProp-boolean
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        % usr_wg_DbfSums(EmplKey, InSum, InDays, InHoures, InYear, InMonth, DateBegin, SickProp)
        get_sql(Scope, kb, usr_wg_DbfSums/8,
        "
        SELECT
          Z.USR$EMPLKEY,
          COALESCE(Z.USR$SUMSICK, 0) AS INSUM,
          COALESCE(Z.USR$DOW, 0) AS InDays,
          COALESCE(Z.USR$MID_HOW, 0) AS INHOURES,
          EXTRACT(YEAR FROM IDK.USR$DATEBEGIN) AS InYear,
          EXTRACT(MONTH FROM IDK.USR$DATEBEGIN) AS InMonth,
          IDK.USR$DATEBEGIN,
          USR$SICK_PROP AS SickProp
        FROM
          USR$GMK_SUMS Z
        JOIN
          USR$WG_TOTAL IDK
            ON IDK.DOCUMENTKEY  =  Z.USR$INDOCKEY
        WHERE
          Z.USR$EMPLKEY = pEmplKey
          AND
          IDK.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          IDK.USR$DATEBEGIN < 'pDateCalcTo'
        ORDER BY
          Z.USR$EMPLKEY,
          IDK.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        
        gd_pl_ds(wg_avg_wage_sick, kb, usr_wg_AvgWage, 6, [
            fAvgType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer,
            fAvgSumma-float
            ]).
        % usr_wg_AvgWage(AvgType, EmplKey, FirstMoveKey, CalYear, CalMonth, AvgSumma)
        get_sql(wg_avg_wage_sick, kb, usr_wg_AvgWage/6,
        "
        SELECT
          'vacation' AS AvgType,
          v.USR$EMPLKEY,
          v.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM vl.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM vl.USR$DATEBEGIN) AS CalMonth,
          v.USR$AVGSUMMA
        FROM
          USR$WG_VACATION v
        JOIN
          USR$WG_VACATIONLINE vl
            ON vl.MASTERKEY = v.DOCUMENTKEY
        WHERE
          v.USR$EMPLKEY = pEmplKey
          AND
          v.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND
          vl.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          vl.USR$DATEBEGIN < 'pDateCalcTo'
        UNION ALL
        SELECT
          'sick' AS AvgType,
          s.USR$EMPLKEY,
          s.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM sl.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM sl.USR$DATEBEGIN) AS CalMonth,
          s.USR$AVGSUMMA
        FROM
          USR$WG_SICKLIST s
        JOIN
          USR$WG_SICKLISTLINE sl
            ON sl.MASTERKEY = s.DOCUMENTKEY
        WHERE
          s.USR$EMPLKEY = pEmplKey
          AND
          s.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND
          sl.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          sl.USR$DATEBEGIN < 'pDateCalcTo'
        UNION ALL
        SELECT
          'avg' AS AvgType,
          al.USR$EMPLKEY,
          al.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth,
          CASE COALESCE(a.USR$CALCBYHOUR, 0)
            WHEN 1 THEN
              8 * COALESCE(al.USR$AVGSUM, 0)
            ELSE
              COALESCE(al.USR$AVGSUM, 0)
          END
            AS AvgSumma
        FROM
          USR$WG_AVGADDPAYLINE al
        JOIN
          USR$WG_AVGADDPAY a
            ON a.DOCUMENTKEY = al.MASTERKEY
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = a.USR$TOTALDOCKEY
        WHERE
          al.USR$EMPLKEY = pEmplKey
          AND
          al.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND
          t.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDateCalcTo'
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeTypeProp, 4, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fFeeGroupKeyProp-integer, fFeeTypeKeyProp-integer
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        % usr_wg_FeeTypeProp(EmplKey, FirstMoveKey, FeeGroupKeyProp, FeeTypeKeyProp)
        get_sql(Scope, kb, usr_wg_FeeTypeProp/4,
        "
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY = (SELECT id FROM GD_P_GETID(pFeeGroupKeyProp_ruid))
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pFeeGroupKeyProp_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        
        gd_pl_ds(wg_avg_wage_sick, kb, wg_holiday, 1, [
            fHolidayDate-date
            ]).
        % wg_holiday(HolidayDate)
        get_sql(wg_avg_wage_sick, kb, wg_holiday/1,
        "
        SELECT
          h.holidaydate
        FROM
          wg_holiday h
        WHERE
          h.holidaydate BETWEEN 'pDateCalcFrom' AND 'pDateCalcTo'
          AND COALESCE(h.disabled, 0) = 0
        ",
            [
            pDateCalcFrom-_, pDateCalcTo-_
            ]).
        
        gd_pl_ds(Scope, kb, usr_wg_ExclDays, 8, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fExclType-string, fOrderType-integer, fHourType-integer,
            fExclWeekDay-integer,
            fFromDate-date, fToDate-date
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick
                ]).
        % usr_wg_ExclDays(EmplKey, FirstMoveKey, ExclType, OrderType, HourType, ExclWeekDay, FromDate, ToDate)
        get_sql(Scope, kb, usr_wg_ExclDays/8,
        "
        SELECT
          EmplKey, FirstMoveKey, ExclType, OrderType, HourType, ExclWeekDay, FromDate, ToDate
        FROM (
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          'LIGHTWORKLINE' AS ExclType,
          0 AS OrderType,
          0 AS HourType,
          0 AS ExclWeekDay,
          CAST( IIF(lw.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', lw.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(lw.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(lw.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', lw.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_LIGHTWORKLINE lw
        WHERE lw.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND lw.USR$EMPLKEY = pEmplKey
          AND lw.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(lw.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        UNION ALL
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          'LEAVEDOCLINE' AS ExclType,
          t.USR$TYPE AS OrderType,
          t.USR$HOURTYPE AS HourType,
          0 AS ExclWeekDay,
          CAST( IIF(ld.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', ld.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(ld.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(ld.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', ld.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_LEAVEDOCLINE ld
        JOIN USR$WG_VACATIONTYPE t ON t.ID = ld.USR$VACATIONTYPEKEY
        WHERE ld.USR$FIRSTMOVEKEY = pFirstMoveKey
          AND ld.USR$EMPLKEY = pEmplKey
          AND ld.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(ld.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
          AND COALESCE(t.USR$EXCLUDEFORSICKLIST, 0) = 1
        UNION ALL
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          'SICKLISTJOURNAL' AS ExclType,
          t.USR$CALCTYPE AS OrderType,
          0 AS HourType,
          0 AS ExclWeekDay,
          CAST( IIF(s.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', s.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(s.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(s.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', s.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_SICKLISTJOURNAL s
        JOIN USR$WG_ILLTYPE t ON t.ID = s.USR$ILLTYPEKEY
        WHERE s.USR$EMPLKEY = pEmplKey
          AND s.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(s.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        UNION ALL
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          'LEAVEEXTDOC' AS ExclType,
          0 AS OrderType,
          0 AS HourType,
          0 AS ExclWeekDay,
          CAST( IIF(ext.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', ext.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(ext.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(ext.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', ext.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_LEAVEEXTDOC ext
        WHERE ext.USR$EMPLKEY = pEmplKey
          AND ext.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(ext.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        UNION ALL
        SELECT
          pEmplKey AS EmplKey,
          pFirstMoveKey AS FirstMoveKey,
          'KINDDAYLINE' AS ExclType,
          0 AS OrderType,
          0 AS HourType,
          kdl.USR$DAY AS ExclWeekDay,
          CAST( IIF(kdl.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', kdl.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(kdl.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(kdl.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', kdl.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_KINDDAYLINE kdl
        WHERE kdl.USR$EMPLKEY = pEmplKey
          AND kdl.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(kdl.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        )
        ORDER BY
          ExclWeekDay,
          FromDate
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick
                ]).
        
        % twg_struct
        
        gd_pl_ds(wg_struct_vacation, kb, wg_holiday, 1, [
            fHolidayDate-date
            ]).
        % wg_holiday(HolidayDate)
        get_sql(wg_struct_vacation, kb, wg_holiday/1,
        "
        SELECT
          h.holidaydate
        FROM
          wg_holiday h
        WHERE
          h.holidaydate BETWEEN 'pDateBegin' AND 'pDateEnd'
          AND COALESCE(h.disabled, 0) = 0
        ",
            [
            pDateBegin-_, pDateEnd-_
            ]).
        
        gd_pl_ds(wg_struct_vacation, kb, wg_vacation_slice, 2, [
            fVcType-integer, fSlice-float
            ]).
        % wg_vacation_slice(VcType, Slice)
        get_sql(wg_struct_vacation, kb, wg_vacation_slice/2,
        "
        SELECT
          0 AS VcType, COALESCE(USR$DURATION,0) AS Slice
        FROM
          USR$WG_VACATION
        WHERE
          DOCUMENTKEY = pDocKey
        UNION ALL
        SELECT
          1 AS VcType, COALESCE(USR$EXTRADURATION,0) AS Slice
        FROM
          USR$WG_VACATION
        WHERE
          DOCUMENTKEY = pDocKey
        /*
        UNION ALL
        SELECT
          2 AS VcType, COALESCE(USR$UNHEALTHY,0) AS Slice
        FROM
          USR$WG_VACATION
        WHERE
          DOCUMENTKEY = pDocKey
        UNION ALL
        SELECT
          3 AS VcType, COALESCE(USR$UNFIXED,0) AS Slice
        FROM
          USR$WG_VACATION
        WHERE
          DOCUMENTKEY = pDocKey
        UNION ALL
        SELECT
          4 AS VcType, COALESCE(USR$COMPENSATIONDAY,0) AS Slice
        FROM
          USR$WG_VACATION
        WHERE
          DOCUMENTKEY = pDocKey
        */
        ",
            [
            pDocKey-_
            ]).
        
        gd_pl_ds(wg_struct_vacation, kb, wg_vacation_compensation, 3, [
            fDateFrom-integer, fDuration-float, fCompensation-integer
            ]).
        % wg_vacation_compensation(DateFrom, Duration, Compensation)
        get_sql(wg_struct_vacation, kb, wg_vacation_compensation/3,
        "
        SELECT
          USR$FROM AS DateFrom,
          COALESCE(USR$DURATION,0) AS Duration,
          COALESCE(USR$COMPENSATION,0) AS Compensation
        FROM
          USR$WG_VACATION
        WHERE
          DOCUMENTKEY = pDocKey
        ",
            [
            pDocKey-_
            ]).
        
        gd_pl_ds(wg_struct_sick, kb, gd_const_budget, 2, [
            fConstDate-date, fBudget-float
            ]).
        % gd_const_budget(ConstDate, Budget)
        get_sql(wg_struct_sick, kb, gd_const_budget/2,
        "
        SELECT
          cv.CONSTDATE,
          CAST(cv.CONSTVALUE AS DECIMAL(15,4)) AS Budget
        FROM
          GD_CONSTVALUE cv
        JOIN
          GD_CONST c
            ON c.ID  =  cv.CONSTKEY
        WHERE
          cv.CONSTKEY = (SELECT id FROM GD_P_GETID(pBudget_ruid))
        ORDER BY
          cv.CONSTDATE
        ",
            [
            pBudget_ruid-_
            ]).
        
        gd_pl_ds(Scope, kb, gd_const_AvgSalaryRB, 2, [
            fConstDate-date, fAvgSalaryRB-float
            ]) :-
            memberchk(Scope, [
                wg_struct_sick, wg_avg_wage_sick
                ]).
        % gd_const_AvgSalaryRB(ConstDate, AvgSalaryRB)
        get_sql(Scope, kb, gd_const_AvgSalaryRB/2,
        "
        SELECT
          cv.CONSTDATE,
          CAST(cv.CONSTVALUE AS DECIMAL(15,4)) AS AvgSalaryRB
        FROM
          GD_CONSTVALUE cv
        JOIN
          GD_CONST c
            ON c.ID  =  cv.CONSTKEY
        WHERE
          cv.CONSTKEY = (SELECT id FROM GD_P_GETID(pAvgSalaryRB_ruid))
        ORDER BY
          cv.CONSTDATE
        ",
            [
            pAvgSalaryRB_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_struct_sick, wg_avg_wage_sick
                ]).
        
        gd_pl_ds(wg_struct_sick, kb, usr_wg_TblDayNorm, 8, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fWYear-integer, fWMonth-integer, fTheDay-date, fWDay-integer,
            fWDuration-float, fWorkDay-integer
            ]).
        % usr_wg_TblDayNorm(EmplKey, FirstMoveKey, WYear, WMonth, TheDay, WDay, WDuration, WorkDay)
        get_sql(wg_struct_sick, kb, usr_wg_TblDayNorm/8,
        "
        SELECT EmplKey, FirstMoveKey, WYear, WMonth, TheDay, WDay, WDuration, WorkDay
        FROM USR$WG_TBLCALDAY_P(pEmplKey, pFirstMoveKey, 'pDateCalcFrom', 'pDateCalcTo')
        ",
            [
            pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]).
        
        gd_pl_ds(Scope, kb, wg_job_ill_type, 1, [
            fJobIllType-integer
            ]) :-
            memberchk(Scope, [
                wg_struct_sick, wg_avg_wage_sick
                ]).
        % wg_job_ill_type(ID)
        get_sql(Scope, kb, wg_job_ill_type/1,
        "
        SELECT id FROM GD_P_GETID(pJobIllType_ruid)
        ",
            [
            pJobIllType_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_struct_sick, wg_avg_wage_sick
                ]).
        
        gd_pl_ds(Scope, kb, wg_child_ill_type, 1, [
            fChildIllType-integer
            ]) :-
            memberchk(Scope, [
                wg_struct_sick
                ]).
        % wg_child_ill_type(ID)
        get_sql(Scope, kb, wg_child_ill_type/1,
        "
        SELECT id FROM GD_P_GETID(pChildIllType_ruid)
        ",
            [
            pChildIllType_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_struct_sick
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_pl_Rule, 2, [
            fAtom-string, fEnabled-boolean
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        % usr_wg_pl_Rule(Atom, Enabled)
        get_sql(Scope, kb, usr_wg_pl_Rule/2,
        "
        SELECT
          r.USR$ATOM,
          r.USR$ENABLED
        FROM
          USR$WG_PL_RULE r
        WHERE
          NOT r.USR$ATOM IS NULL
        ORDER BY
          r.PARENT,
          r.USR$ORDER
        ",
            [
            ]) :-
            memberchk(Scope, [
                wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg
                ]).
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-02-04T12:58:50+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189471_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151189370_18175251
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_avg_wage_in_params"
      COMMENT: ~
      SCRIPT: | 
        %% twg_avg_wage_in_params
        %  входные параметры для twg_avg_wage
        %
        
        %:- ['../common/lib', '../common/params'].
        
        twg_avg_wage_in_params:-
            member(Scope, [
                wg_avg_wage_vacation,
                wg_avg_wage_sick,
                wg_avg_wage_avg,
                wg_struct_sick
                ]),
            new_param_list(Scope, in, [
                pCommon-1,
                % форма оплаты Оклад
                pPayFormSalary_ruid-'147009181,119619099',
                % Календарный график
                %pTblCal_DocType_Plan_ruid-'147567935,1514418708',
                pTblCal_DocType_Plan_xid1-147567935,
                pTblCal_DocType_Plan_dbid1-1514418708,
                pTblCal_DocType_Plan_xid2-147117601,
                pTblCal_DocType_Plan_dbid2-1481574092,
                % Травма производственная
                pJobIllType_ruid-'147036273,151520244',
                % Табель мастера
                pTblCal_DocType_Fact_ruid-'187613422,1596169984'
                ]),
            fail.
        twg_avg_wage_in_params:-
            new_param_list(wg_avg_wage_vacation, in, [
                pMonthQty-12, pAvgDays-29.7,
                pFeeGroupKey_ruid-'147071456,274788016',
                pFeeGroupKeyNoCoef_ruid-'147757383,84733194',
                % Постановление №31 (исключение пособий для среднего)
                pBadFeeGroupKey_ruid-'147077036,222160651',
                % Больничный (80%)
                %pBadFeeType_xid_IN-'151000730',
                %pBadFeeType_dbid-2109681374,
                % А, УБЗ, Т
                pBadHourType_xid_IN-'147650804, 147650786, 147650802',
                pBadHourType_dbid-119619099,
                % Ненормированный график
                pSpecDep_ruid-'156913837,131572570'
                ]),
            fail.
        twg_avg_wage_in_params:-
            new_param_list(wg_avg_wage_sick, in, [
                pMonthQty-6, pLimitDays-30,
                pFeeGroupKey_ruid-'147071457,274788016',
                % Группа Пропорциональных начислений
                pFeeGroupKeyProp_ruid-'147119175,1354510846',
                pKindDayHourType_ruid-'147650798,119619099',
                pAvgSalaryRB_ruid-'147105585,1224850260'
                ]),
            fail.
        twg_avg_wage_in_params:-
            new_param_list(wg_avg_wage_avg, in, [
                pMonthQty-2, pMonthBonusQty-12, pMonthLimitQty-2,
                pFeeGroupKey_ruid-'147113780,1354510846',
                % Группа Пропорциональных начислений
                pFeeGroupKeyProp_ruid-'151471645,212040444'
                ]),
            fail.
        twg_avg_wage_in_params:-
            new_param_list(wg_struct_vacation, in, [
                ]),
            fail.
        twg_avg_wage_in_params:-
            new_param_list(wg_struct_sick, in, [
                pFirstCalcType-0, pFirstDuration-12, pFirstPart-0.8,
                pBugetCalcType-1, pBudgetPart-0.5, pViolatPart-0.5,
                pBudget_ruid-'147073065,1224850260',
                % По уходу за ребенком до 3-х лет
                pChildIllType_ruid-'147022918,119619099',
                pAvgSalaryRB_ruid-'147105585,1224850260',
                pAvgSalaryRB_Coef-3
                ]),
            fail.
        twg_avg_wage_in_params :-
            member([CutCalcType, CutDuration, CutPart], [[2, 6, 0.5], [3, 0, 0.5]]),
            new_param_list(wg_struct_sick, in,
                [pCutCalcType-CutCalcType, pCutDuration-CutDuration, pCutPart-CutPart]),
            fail.
        twg_avg_wage_in_params.
        
        :- twg_avg_wage_in_params.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-01-05T14:00:09+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189370_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_avg_wage"
      COMMENT: ~
      SCRIPT: | 
        %% twg_avg_wage
        % Зарплата и Отдел кадров -> Зарплата -> 03. Начисление зарплаты
        %   05. Начисление отпусков
        %   06. Начисление больничных
        %   12. Начисление по-среднему
        %
        
        :- style_check([-atom]).
        
        :- dynamic(debug_mode/0).
        % ! при использовании в ТП Гедымин
        % ! комментировать следующую строку
        %:- assertz(debug_mode).
        
        %%% begin debug mode section
        :- if(debug_mode).
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        %#INCLUDE params
        %#INCLUDE wg_data_mix
        :- ['../common/lib', '../common/params', '../common/wg_data_mix'].
        %#INCLUDE twg_avg_wage_sql
        :- [twg_avg_wage_sql].
        %#INCLUDE twg_avg_wage_in_params
        %:- [twg_avg_wage_in_params].
        %%
        
        %% facts
        :-  init_data,
            working_directory(_, 'kb'),
            [
            % section twg_avg_wage
            %  05. Начисление отпусков
            usr_wg_DbfSums, % 05, 06, 12
            usr_wg_MovementLine, % 05, 06, 12
            usr_wg_FCRate,
            usr_wg_TblCalDay, % 05, 06, 12
            %usr_wg_TblDayNorm, % 05, 06, 12
            %usr_wg_TblYearNorm,
            usr_wg_TblCalLine, % 05, 06, 12
            usr_wg_TblCal_FlexLine, % 05, 06, 12
            usr_wg_HourType, % 05, 06
            usr_wg_TblCharge, % 05, 06, 12
            usr_wg_FeeType, % 05, 06, 12
            usr_wg_FeeTypeNoCoef,
            usr_wg_BadHourType,
            usr_wg_BadFeeType,
            usr_wg_SpecDep,
            %  06. Начисление больничных
            usr_wg_AvgWage,
            usr_wg_FeeTypeProp, % 06, 12
            wg_holiday,
            usr_wg_ExclDays,
            % 12. Начисление по-среднему
            usr_wg_TblChargeBonus,
            % section twg_struct
            %wg_holiday,
            wg_vacation_slice,
            wg_vacation_compensation,
            gd_const_budget,
            gd_const_AvgSalaryRB,
            %usr_wg_TblDayNorm,
            wg_job_ill_type,
            wg_child_ill_type,
            % section twg_rule
            usr_wg_pl_Rule
            ],
            working_directory(_, '..').
        %%
        
        %% dynamic state
        :- ['kb/param_list'].
        %%
        
        :- else.
        
        :- ps32k_lgt(64, 128, 64).
        
        :- endif.
        %%% end debug mode section
        
        % section twg_avg_wage
        % среднедневной заработок
        % - для отпусков
        % - для больничных
        % - для начисления по-среднему
        %
        
        /* реализация - секция правил */
        
        :- dynamic(wg_valid_rules/1).
        
        %% варианты правил расчета
        %  - для отпусков
        % [по расчетным месяцам, по среднечасовому]
        wg_valid_rules([by_calc_month, by_avg_houre]).
        %% варианты правил включения месяца в расчет
        % табель за месяц покрывает график [по дням и часам, по часам, по дням]
        wg_valid_rules([by_days_houres, by_houres, by_days]).
        %% дополнительные правила для включения месяца в расчет
        % [заработок за месяц не меньше любого из полных месяцев]
        % (для одинаковых коэфициентов осовременивания)
        wg_valid_rules([by_month_wage_any]).
        % [заработок за месяц не меньше каждого из полных месяцев]
        % (для одинаковых коэфициентов осовременивания)
        wg_valid_rules([-by_month_wage_all]).
        % [заработок за месяц не меньше среднемесячного по полным месяцам]
        wg_valid_rules([-by_month_avg_wage]).
        % [отсутствие в месяце плохих типов начислений и часов]
        wg_valid_rules([-by_month_no_bad_type]).
        
        %% варианты правил расчета
        %  - для больничных
        % [по расчетным дням итого за период]
        wg_valid_rules([by_calc_days_total]).
        % [по расчетным дням, по расчетным дням со справкой]
        wg_valid_rules([-by_calc_days, -by_calc_days_doc]).
        % [от ставки, по среднему заработку, по не полным месяцам]
        wg_valid_rules([by_rate, by_avg_wage, -by_not_full]).
        % [от БПМ]
        wg_valid_rules([by_budget]).
        %% варианты правил для исключения дней
        % [по табелю мастера, по табелю, по приказам]
        wg_valid_rules([by_cal_flex, by_cal, by_orders]).
        %% дополнительные правила для учета расчетных дней
        % [хотя бы один месяц полный, все месяцы полные]
        wg_valid_rules([by_calc_days_any, -by_calc_days_all]).
        
        %% варианты правил полных месяцев
        %  - для отпусков
        % табель за месяц покрывает график [по дням и часам, по часам, по дням]
        wg_full_month_rules([by_days_houres, by_houres, by_days]).
        %% варианты правил условно полных месяцев
        %  - для отпусков
        % [отсутствие в месяце плохих типов начислений и часов]
        wg_full_month_rules_cond([by_month_no_bad_type]).
        
        % правила запрещены по признаку
        %  - для отпусков
        wg_deny_flag_rules(flag_spec_dep, [by_days_houres, by_houres, by_days]).
        wg_deny_flag_rules(flag_spec_dep, [by_month_wage_all]).
        wg_deny_flag_rules(flag_spec_dep, [by_month_wage_any]).
        wg_deny_flag_rules(flag_spec_dep, [by_month_avg_wage]).
        
        % правило действительно
        is_valid_rule(Scope, PK, Y-M, Rule) :-
            wg_valid_rules(ValidRules),
            member(Rule, ValidRules),
            \+ is_deny_rule(Scope, PK, Y-M, Rule),
            !.
        
        % правило отвергается по признаку
        is_deny_rule(Scope, PK, Y-M, Rule) :-
            get_flag_rule(Scope, PK, Y-M, Flag),
            wg_deny_flag_rules(Flag, FlagRules),
            member(Rule, FlagRules),
            !.
        
        % получить признак
        get_flag_rule(Scope, PK, _, Flag) :-
            Flag = flag_spec_dep,
            % последний график рабочего времени
            get_last_schedule(Scope, PK, ScheduleKey),
            % равен графику специального отдела
            get_spec_dep(Scope, PK, ScheduleKey),
            !.
        
        % взять график специального отдела
        get_spec_dep(Scope, PK, SpecDepKey) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные по графику специального отдела
            get_data(Scope, kb, usr_wg_SpecDep, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fID-SpecDepKey]),
            !.
        
        /* реализация - расчет */
        
        % среднедневной заработок
        % Scope: wg_avg_wage_vacation ; wg_avg_wage_sick ; wg_avg_wage_avg
        %        для отпусков ; для больничных ; для начисления по-среднему
        avg_wage(Scope) :-
            % взять локальное время
            get_local_date_time(DT),
            % записать отладочную информацию
            new_param_list(Scope, debug, [start-Scope-DT]),
            % шаблон первичного ключа
            PK = [pEmplKey-_, pFirstMoveKey-_],
            % для каждого первичного ключа расчета из входных параметров
            get_param_list(Scope, in, PK),
            % запустить цикл механизма подготовки данных
            engine_loop(Scope, in, PK),
            % настроить правила
            wg_config_rules(Scope),
            % выполнить расчет
            eval_avg_wage(Scope, PK),
            % найти альтернативу
            fail.
        avg_wage(_) :-
            % больше альтернатив нет
            !.
        
        % выполнить расчет
        eval_avg_wage(Scope, PK) :-
            % взять локальное время
            get_local_date_time(DT1),
            % записать отладочную информацию
            new_param_list(Scope, debug, [begin-DT1|PK]),
            % удалить временные данные по расчету
            forall( get_param_list(Scope, temp, PK, Pairs),
                    dispose_param_list(Scope, temp, Pairs) ),
            % вычислить среднедневной заработок по сотруднику
            calc_avg_wage(Scope, PK, AvgWage, Variant),
            % записать результат
            ret_avg_wage(Scope, PK, AvgWage, Variant),
            % взять локальное время
            get_local_date_time(DT2),
            % записать отладочную информацию
            new_param_list(Scope, debug, [end-DT2|PK]),
            !.
        
        % записать результат
        ret_avg_wage(Scope, PK, AvgWage, Variant) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять дополнительные данные из первого движения
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey,
                        fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fMovementType-1,
                        fListNumber-ListNumber
                 ]),
            % для даты последнего приема на работу
            get_last_hire(Scope, PK, DateBegin),
            % записать выходные данные
            append(PK, [pListNumber-ListNumber,
                        pAvgWage-AvgWage, pVariant-Variant],
                    OutPairs),
            new_param_list(Scope, out, OutPairs),
            !.
        
        % среднедневной заработок по сотруднику
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для отпусков (по расчетным месяцам)
            Scope = wg_avg_wage_vacation, Rule = by_calc_month,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % проверка по табелю
            check_month_tab(Scope, PK, Periods),
            % проверка на отсутствие плохих типов начислений и часов
            check_month_no_bad_type(Scope, PK, Periods),
            % если есть хотя бы один расчетный месяц
            ( once( get_month_incl(Scope, PK, _, _, _) )
            ->
              % то проверка по заработку
              check_month_wage(Scope, PK, Periods)
              % иначе далее
            ; true ),
            % есть хотя бы один расчетный месяц
            once( get_month_incl(Scope, PK, _, _, _) ),
            % взять заработок
            findall( Wage,
                       % за каждый расчетный месяц
                     ( get_month_incl(Scope, PK, Y, M, _),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y, M, _, Wage) ),
            % в список заработков
            Wages ),
            % итоговый заработок за расчетные месяцы
            sum_list(Wages, Amount),
            % количество расчетных месяцев
            length(Wages, Num),
            % среднемесячное количество календарных дней
            get_param(Scope, in, pAvgDays-AvgDays),
            % среднедневной заработок
            catch( AvgWage0 is Amount / Num / AvgDays, _, fail ),
            AvgWage is round(AvgWage0),
            !.
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для отпусков (по среднечасовому)
            Scope = wg_avg_wage_vacation, Rule = by_avg_houre,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % взять заработок
            findall( Wage,
                       % за каждый период проверки
                     ( member(Y1-M1, Periods),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y1, M1, _, Wage),
                       Wage > 0 ),
            % в список заработков
            Wages ),
            % есть заработок
            \+ Wages = [],
            % всего за период
            sum_list(Wages, Amount),
            % взять часы
            findall( THoures,
                       % за период проверки
                     ( member(Y2-M2, Periods),
                       % взять данные по часам за месяц
                       get_month_norm_tab(Scope, PK, Y2-M2, _, _, _, THoures) ),
            % в список часов
            Durations),
            % всего часов по табелю
            sum_list(Durations, TotalTab),
            % среднечасовой заработок
            catch( AvgHoureWage is Amount / TotalTab, _, fail ),
            % расчитать график за год
            calc_year_norm(Scope, PK, NormDays),
            % сумма дней и часов по графику
            sum_days_houres(NormDays, _, TotalNorm),
            % среднемесячное количество расчетных рабочих часов
            AvgMonthNorm is TotalNorm / 12,
            % среднемесячное количество календарных дней
            get_param(Scope, in, pAvgDays-AvgDays),
            % среднедневной заработок
            catch( AvgWage0 is AvgHoureWage * AvgMonthNorm / AvgDays, _, fail ),
            AvgWage is round(AvgWage0),
            !.
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для больничных (по расчетным дням / со справкой)
            Scope = wg_avg_wage_sick,
            Rules = [by_calc_days_total-1, by_calc_days-2, by_calc_days_doc-1] ,
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % есть рабочие периоды
            \+ Periods = [],
            % для правила из списка
            member(Rule-IsAvgWageDoc, Rules),
            % где правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            get_param(Scope, run, pMonthQty-MonthQty),
              % если есть требуемое количество месяцев
            ( length(Periods, MonthQty) -> true
            ; % или соспоставление с признаком Справка
              get_param_list(Scope, run, [pIsAvgWageDoc-IsAvgWageDoc | PK])
            ),
            % и выполняется одно из правил по расчетным дням
            rule_month_days_sick(Scope, PK, Periods, _),
            % то выполнить расчет
            % взять заработок
            findall( Wage,
                       % за каждый период проверки
                     ( member(Y1-M1, Periods),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y1, M1, _, Wage) ),
            % в список заработков
            Wages ),
            % итоговый заработок
            sum_list(Wages, Amount),
            % взять расчетные дни
            findall( CalcDays,
                       % за каждый период проверки
                     ( member(Y2-M2, Periods),
                       % взять данные по расчетным дням
                       get_month_days_sick(Scope, PK, Y2, M2, _, CalcDays, _, _) ),
            % в список расчетных дней
            CalcDaysList ),
            % всего расчетных дней
            sum_list(CalcDaysList, TotalCalcDays),
            !,
            % среднедневной заработок
            catch( AvgWage0 is Amount / TotalCalcDays, _, fail ),
            AvgWage is round(AvgWage0),
            !.
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для больничных (от ставки при отсутствии заработка)
            Scope = wg_avg_wage_sick,
            Rule = by_rate,
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % есть требуемое количество месяцев
            get_param(Scope, run, pMonthQty-MonthQty),
            length(Periods, MonthQty),
            % взять заработок
            findall( Wage,
                       % за каждый период проверки
                     ( member(Y-M, Periods),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y, M, _, Wage),
                       Wage > 0
                     ),
            % в список заработков
            Wages ),
            % если нет заработка
            Wages = [],
            % то расчет от ставки при формировании структуры
            AvgWage is 0,
            !.
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для больничных (от ставки / по среднему заработку / по не полным месяцам)
            Scope = wg_avg_wage_sick,
            Rules = [by_rate, by_avg_wage, by_not_full],
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % есть рабочие периоды
            \+ Periods = [],
            get_param(Scope, run, pMonthQty-MonthQty),
            % есть требуемое количество месяцев
            ( length(Periods, MonthQty) -> true
            % или признак Справка
            ; get_param_list(Scope, run, [pIsAvgWageDoc-1 | PK])
            ),
            % собрать расчет по разным вариантам
            findall( AvgWage0-Rule0,
                     ( member(Rule0, Rules),
                       calc_avg_wage_sick(Scope, PK, Periods, AvgWage0, Rule0),
                       AvgWage0 > 0
                     ),
            % в список расчетов
            AvgWageList),
            % выбор по более выгодному варианту
            max_member(AvgWage1-Rule, AvgWageList),
              % от ставки - расчет при формировании структуры
            ( memberchk(Rule, [by_rate])
             -> AvgWage = 0
            ; % иначе - по выбранному варианту
              AvgWage = AvgWage1
            ),
            !.
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для больничных (от ставки без периодов со справкой)
            Scope = wg_avg_wage_sick, Rule = by_rate,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % если нет рабочих периодов
            Periods = [],
            % но есть признак Справка
            get_param_list(Scope, run, [pIsAvgWageDoc-1 | PK]),
            % то расчет от ставки
            calc_avg_wage_sick(Scope, PK, Periods, AvgWage, Rule),
            !.
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            % - для больничных (от БПМ)
            Scope = wg_avg_wage_sick, Rule = by_budget,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % нет требуемого количества месяцев
            get_param(Scope, run, pMonthQty-MonthQty),
            \+ length(Periods, MonthQty),
            % расчет от БПМ при формировании структуры
            AvgWage is 0,
            !.
        calc_avg_wage(Scope, PK, AvgWage, Variant) :-
            % - для начисления по-среднему (по часам или дням)
            Scope = wg_avg_wage_avg,
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % взять заработок
            findall( Wage1,
                       % за каждый период проверки
                     ( member(Y1-M1, Periods),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y1, M1, _, Wage1),
                       % где значение больше 0
                       Wage1 > 0 ),
            % в список заработков
            Wages ),
              % есть требуемое количество месяцев
            ( get_param(Scope, run, pMonthQty-MonthQty),
              length(Wages, MonthQty)
            -> true
            ; % или первый период проверки
              Periods = [Y-M|_],
              % и период последнего приема на работу
              get_last_hire(Scope, PK, DateIn),
              % совпадают
              atom_date(DateIn, date(Y, M, _))
            ),
            % итоговый заработок
            sum_list(Wages, Amount),
            % признак расчета по часам
            get_param(Scope, run, pCalcByHoure-CalcByHoure),
            ( CalcByHoure = 1 -> Variant = avg_houre ; Variant = avg_day),
            % взять отработанное время
            findall( TWork,
                       % за период проверки
                     ( member(Y2-M2, Periods),
                       % взять данные по дням и часам за месяц
                       get_month_norm_tab(Scope, PK, Y2-M2, _, TDays, _, THoures),
                       % для заработка
                       get_month_wage(Scope, PK, Y2, M2, _, Wage2),
                       % значение которого больше 0
                       Wage2 > 0,
                       % признаку расчета по часам
                       ( CalcByHoure = 1 -> TWork = THoures ; TWork = TDays ) ),
            % в список
            TWorkList),
            % всего отработано по табелю
            sum_list(TWorkList, TotalTab),
            % средний заработок
            catch( AvgWage0 is Amount / TotalTab, _, fail ),
            AvgWage is round(AvgWage0),
            !.
        calc_avg_wage(Scope, PK, AvgWage, Variant) :-
            % - для начисления по-среднему (нужно больше месяцев)
            Scope = wg_avg_wage_avg,
            % периоды для проверки
            get_periods(Scope, PK, [Y-M|_]),
            atom_date(FirstDate, date(Y, M, 1)),
            % для даты последнего приема на работу
            get_last_hire(Scope, PK, DateIn),
            % если дата последнего приема на работу меньше первой даты расчета
            DateIn @< FirstDate,
            % и не превышен лимит
            get_param_list(Scope, run, [pMonthLimitQty-MonthLimitQty, pMonthBefore-MonthBefore]),
            \+ MonthBefore > MonthLimitQty,
            % то для расчета нужно больше месяцев
            AvgWage = 0, Variant = need_more,
            !.
        calc_avg_wage(Scope, PK, AvgWage, Variant) :-
            % - для начисления по-среднему (по начислению за текущий месяц)
            Scope = wg_avg_wage_avg,
            % нет периодов для проверки
            get_periods(Scope, PK, []),
            % если следующий период
            append(PK, [pDateCalcTo-DateTo], Pairs),
            get_param_list(Scope, run, Pairs),
            atom_date(DateTo, date(Y, M, _)),
            % и период последнего приема на работу
            get_last_hire(Scope, PK, DateIn),
            % совпадают
            atom_date(DateIn, date(Y, M, _)),
            % то требуется итоговый расчет для текущего месяца
            AvgWage = 0, Variant = by_current_month,
            !.
        calc_avg_wage(Scope, PK, AvgWage, Variant) :-
            % - для начисления по-среднему (нет требуемого количества месяцев)
            Scope = wg_avg_wage_avg,
            % периоды для проверки
            get_periods(Scope, PK, [Y-M|_]),
            atom_date(FirstDate, date(Y, M, 1)),
            % взять дату последнего приема на работу
            get_last_hire(Scope, PK, DateIn),
            % если дата последнего приема на работу не меньше первой даты расчета
            \+ DateIn @< FirstDate,
            % то для расчета нет требуемого количества месяцев
            AvgWage = 0, Variant = no_data,
            !.
        
        % выбор варианта расчета среднедневного заработка
        % - для больничных
        calc_avg_wage_sick(Scope, PK, Periods, AvgWage, Rule) :-
            % от ставки
            Rule = by_rate,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % взять данные по среднедневной ставке (окладу)
            findall( AvgWage0,
                     ( member(Y-M, Periods),
                       atom_date(TheDate, date(Y, M, 1)),
                       get_avg_wage_rate(Scope, PK, TheDate, AvgWage0)
                     ),
            % в список среднедневных заработков
            AvgWageList),
            % среднедневной заработок
            sum_list(AvgWageList, AvgWageAmount),
            length(Periods, MonthQty),
            catch( AvgWage0 is AvgWageAmount / MonthQty, _, AvgWage0 = 0 ),
            AvgWage is round(AvgWage0),
            !.
        calc_avg_wage_sick(Scope, PK, Periods, AvgWage, Rule) :-
            % по среднему заработку
            Rule = by_avg_wage,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные по среднедневному заработку
            findall( AvgSumma,
                     ( member(Y-M, Periods),
                       get_data(Scope, kb, usr_wg_AvgWage, [
                                   fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                   fCalYear-Y, fCalMonth-M, fAvgSumma-AvgSumma])
                     ),
            % в список среднедневных заработков
            AvgSummaList),
            % максимальный среднедневной заработок
            max_list(AvgSummaList, MaxAvgSumma),
            AvgWage is round(MaxAvgSumma),
            !.
        calc_avg_wage_sick(Scope, PK, Periods, AvgWage, Rule) :-
            % по не полным месяцам
            Rule = by_not_full,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % если есть требуемое количество месяцев
            get_param(Scope, run, pMonthQty-MonthQty),
            length(Periods, MonthQty),
            % то выполнить расчет
            % взять заработок
            findall( Wage,
                       % за каждый период проверки
                     ( member(Y1-M1, Periods),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y1, M1, _, Wage) ),
            % в список заработков
            Wages ),
            % итоговый заработок
            sum_list(Wages, Amount),
            % взять расчетные дни
            findall( CalcDays,
                       % за каждый период проверки
                     ( member(Y2-M2, Periods),
                       % взять данные по расчетным дням
                       get_month_days_sick(Scope, PK, Y2, M2, _, CalcDays, _, _) ),
            % в список расчетных дней
            CalcDaysList ),
            % всего расчетных дней
            sum_list(CalcDaysList, TotalCalcDays),
            % среднедневной заработок
            catch( AvgWage0 is Amount / TotalCalcDays, _, fail ),
            AvgWage is round(AvgWage0),
            !.
        
        % правила для учета расчетных дней
        % - для больничных
        rule_month_days_sick(Scope, PK, Periods, Rule) :-
            Rule = by_calc_days_total,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            get_param(Scope, run, pLimitDays-LimitDays),
            findall( CalcDays,
                     ( member(Y-M, Periods),
                       get_month_days_sick(Scope, PK, Y, M, _, CalcDays, _, _)
                     ),
            CalcDaysList ),
            sum_list(CalcDaysList, TotalDays),
            % есть требуемое количество дней
            \+ TotalDays < LimitDays,
            !.
        rule_month_days_sick(Scope, PK, Periods, Rule) :-
            Rule = by_calc_days_any,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % есть хотя бы один полный месяц
            member(Y-M, Periods),
            get_month_days_sick(Scope, PK, Y, M, _, _, IsFullMonth, IsSpecMonth),
            ( IsFullMonth = 1 ; IsSpecMonth = 1 ),
            !.
        rule_month_days_sick(Scope, PK, Periods, Rule) :-
            Rule = by_calc_days_all,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % есть рабочие периоды
            \+ Periods = [],
            % все месяцы полные
            is_full_all_month_sick(Scope, PK, Periods),
            !.
        
        % все месяцы полные
        % - для больничных
        is_full_all_month_sick(_, _, []):-
            % все месяцы проверены
            !.
        is_full_all_month_sick(Scope, PK, [Y-M|Periods]) :-
            % есть данные по расчетным дням для полного месяца
            get_month_days_sick(Scope, PK, Y, M, _, _, IsFullMonth, IsSpecMonth),
            ( IsFullMonth = 1 ; IsSpecMonth = 1 ),
            !,
            % проверить остальные месяцы
            is_full_all_month_sick(Scope, PK, Periods).
        
        % подготовка временных данных для расчета
        prep_avg_wage(Scope, PK, Periods) :-
            % формирование временных данных по графику работы
            make_schedule(Scope, PK),
            % периоды для проверки
            get_periods(Scope, PK, Periods),
            % добавление временных данных по расчету дней и часов
            add_month_norm_tab(Scope, PK, Periods),
            % подготовка дополнительных временных данных
            prep_avg_wage_extra(Scope, PK, Periods),
            % добавление временных данных по расчету заработков
            add_month_wage(Scope, PK, Periods),
            !.
        
        % подготовка дополнительных временных данных
        prep_avg_wage_extra(Scope, _, _) :-
            % - для отпусков
            Scope = wg_avg_wage_vacation,
            !.
        prep_avg_wage_extra(Scope, PK, Periods) :-
            % - для больничных
            Scope = wg_avg_wage_sick,
            % добавление временных данных по расчетным дням
            add_month_days_sick(Scope, PK, Periods),
            !.
        prep_avg_wage_extra(Scope, PK, _) :-
            % - для начисления по-среднему
            Scope = wg_avg_wage_avg,
            % подготовка фактов по начислениям
            prep_TblCharge(Scope, PK),
            !.
        
        % подготовка фактов по начислениям
        prep_TblCharge(Scope, PK) :-
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            PredName/Arity = usr_wg_TblCharge/10,
            once( gd_pl_ds(Scope, kb, PredName, Arity, _) ),
            Args = [EmplKey, FirstMoveKey, _, _, DateBegin,
                    Debit, FeeTypeKey, DOW, HOW, PayPeriod],
            Term =.. [PredName|Args],
            catch( Term, _, fail ), \+ PayPeriod < 2,
            Debit1 is round(Debit / PayPeriod),
            % добавление фактов по начислениям
            add_TblCharge(PayPeriod, [PredName, EmplKey, FirstMoveKey],
                            DateBegin, [Debit1, FeeTypeKey], DOW, HOW),
            fail.
        prep_TblCharge(Scope, PK) :-
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            PredName/Arity = usr_wg_TblChargeBonus/8,
            once( gd_pl_ds(Scope, kb, PredName, Arity, _) ),
            PredName1/Arity1 = usr_wg_TblCharge/10,
            once( gd_pl_ds(Scope, kb, PredName1, Arity1, _) ),
            Args = [EmplKey, FirstMoveKey, _, _, DateBegin,
                    Debit, FeeTypeKey, PayPeriod],
            Term =.. [PredName|Args],
            catch( Term, _, fail ), \+ PayPeriod < 2,
            Debit1 is round(Debit / PayPeriod),
            % добавление фактов по начислениям
            add_TblCharge(PayPeriod, [PredName1, EmplKey, FirstMoveKey],
                            DateBegin, [Debit1, FeeTypeKey], 0, 0),
            fail.
        prep_TblCharge(_, _) :-
            !.
        
        % добавление фактов по начислениям
        add_TblCharge(0, _, _, _, _, _) :-
            !.
        add_TblCharge(PayPeriod, List1, DateBegin, List3, DOW, HOW) :-
            atom_date(DateBegin, date(CalYear, CalMonth, _)),
            List2 = [CalYear, CalMonth, DateBegin],
            append([List1, List2, List3, [DOW, HOW, 1]], List),
            Term =.. List, assertz( Term ),
            PayPeriod1 is PayPeriod - 1,
            date_add(DateBegin, 1, month, DateBegin1),
            !,
            add_TblCharge(PayPeriod1, List1, DateBegin1, List3, 0, 0).
        
        % периоды для проверки
        get_periods(Scope, PK, Periods) :-
            % взять временные данные по списку периодов
            get_param_list(Scope, temp, [pPeriods-Periods|PK]),
            !.
        get_periods(Scope, PK, Periods) :-
            % взять даты ограничения расчета
            append(PK, [pDateCalcFrom-DateFrom, pDateCalcTo-DateTo], Pairs1),
            get_param_list(Scope, run, Pairs1),
            % сформировать список периодов
            make_periods(Scope, PK, DateFrom, DateTo, Periods, 0),
            % добавить временные данные по списку периодов
            append(PK, [pPeriods-Periods], Pairs2),
            new_param_list(Scope, temp, Pairs2),
            !.
        
        % сформировать список периодов
        make_periods(_, _, DateFrom, DateTo, [], _) :-
            DateFrom @>= DateTo,
            !.
        make_periods(Scope, PK, DateFrom, DateTo, [Y-M|Periods], NormOption) :-
            atom_date(DateFrom, date(Y, M, _)),
            % период является рабочим
            is_work_period(Scope, PK, Y-M, NormOption),
            % добавить месяц
            date_add(DateFrom, 1, month, DateFrom1),
            !,
            make_periods(Scope, PK, DateFrom1, DateTo, Periods, NormOption).
        make_periods(Scope, PK, DateFrom, DateTo, Periods, NormOption) :-
            % добавить месяц
            date_add(DateFrom, 1, month, DateFrom1),
            !,
            make_periods(Scope, PK, DateFrom1, DateTo, Periods, NormOption).
        
        %  период является рабочим
        is_work_period(_, _, _, NormOption) :-
            % есть признак расчета нормы времени
            NormOption = 1,
            !.
        is_work_period(Scope, PK, Y-M, _) :-
            % календарных дней в месяце
            month_days(Y, M, MonthDays),
            % последняя дата месяца
            atom_date(LastMonthDate, date(Y, M, MonthDays)),
            % определить дату последнего приема на работу
            get_last_hire(Scope, PK, DateIn),
            % если дата приема на работу не больше последней даты месяца
            DateIn @=< LastMonthDate,
            % то период является рабочим
            !.
        
        % добавление временных данных по расчету дней и часов
        add_month_norm_tab(_, _, []):-
            % больше месяцев для проверки нет
            !.
        add_month_norm_tab(Scope, PK, [Y-M|Periods]) :-
            % проверить данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, _, _, _, _),
            !,
            % проверить остальные месяцы
            add_month_norm_tab(Scope, PK, Periods).
        add_month_norm_tab(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            add_month_norm_tab(Scope, PK, Periods).
        
        % добавление временных данных по расчету заработков
        add_month_wage(_, _, []):-
            % больше месяцев для проверки нет
            !.
        add_month_wage(Scope, PK, [Y-M|Periods]) :-
            % проверить данные по заработку
            get_month_wage(Scope, PK, Y, M, _, _),
            !,
            % проверить остальные месяцы
            add_month_wage(Scope, PK, Periods).
        add_month_wage(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            add_month_wage(Scope, PK, Periods).
        
        % взять данные по заработку за месяц
        get_month_wage(Scope, PK, Y, M, MonthModernCoef, ModernWage) :-
            % - для отпусков
            Scope = wg_avg_wage_vacation,
            % взять из временных параметров данные по заработку
            append(PK, [pYM-Y-M, pModernCoef-MonthModernCoef, pModernWage-ModernWage],
                    Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_wage(Scope, PK, Y, M, MonthModernCoef, ModernWage) :-
            % - для отпусков
            Scope = wg_avg_wage_vacation,
            % расчитать заработок за месяц
            cacl_month_wage(Scope, PK, Y, M, Wage, MonthModernCoef, ModernWage, SalaryOld, SalaryNew),
            % записать во временные параметры данные по заработку
            append(PK, [pYM-Y-M,
                        pWage-Wage, pModernCoef-MonthModernCoef, pModernWage-ModernWage,
                        pSalaryOld-SalaryOld, pSalaryNew-SalaryNew],
                    Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        get_month_wage(Scope, PK, Y, M, 1.0, Wage) :-
            % - для больничных
            Scope = wg_avg_wage_sick,
            % взять из временных параметров данные по заработку
            append(PK, [pYM-Y-M, pWage-Wage],
                    Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_wage(Scope, PK, Y, M, 1.0, Wage) :-
            % - для больничных
            Scope = wg_avg_wage_sick,
            % расчитать заработок за месяц
            cacl_month_wage_sick(Scope, PK, Y, M, Wage0),
            % контроль заработка за месяц
            check_month_wage_sick(Scope, PK, Y, M, Wage0, Wage),
            % записать во временные параметры данные по заработку
            append(PK, [pYM-Y-M, pWage-Wage], Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        get_month_wage(Scope, PK, Y, M, 1.0, Wage) :-
            % - для начисления по-среднему
            Scope = wg_avg_wage_avg,
            % взять из временных параметров данные по заработку
            append(PK, [pYM-Y-M, pWage-Wage],
                    Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_wage(Scope, PK, Y, M, 1.0, Wage) :-
            % - для начисления по-среднему
            Scope = wg_avg_wage_avg,
            % расчитать заработок за месяц
            %cacl_month_wage_avg(Scope, PK, Y, M, Wage),
            % по методу для Больничных
            cacl_month_wage_sick(Scope, PK, Y, M, Wage),
            % записать во временные параметры данные по заработку
            append(PK, [pYM-Y-M, pWage-Wage], Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % контроль заработка за месяц
        check_month_wage_sick(Scope, PK, Y, M, Wage, MonthAvgSalary) :-
            % для декрета
            get_param_list(Scope, run, [pIsPregnancy-1 | PK]),
            % если в периодах
            get_periods(Scope, PK, Periods),
            % есть хоть один месяц
            Periods = [_|_],
            % но нет требуемого количества месяцев
            get_param(Scope, run, pMonthQty-MonthQty),
            \+ length(Periods, MonthQty),
            % взять среднюю зп по РБ
            atom_date(FirstMonthDate, date(Y, M, 1)),
            date_add(FirstMonthDate, 1, month, FirstMonthDate1),
            atom_date(FirstMonthDate1, date(Y1, M1, 1)),
            get_avg_salary_rb(Scope, Y1-M1, MonthAvgSalary0),
            % взять данные по расчетным дням
            get_month_days_sick(Scope, PK, Y, M, MonthDays, CalcDays, IsFullMonth, _),
            % сделать контроль превышения
            ( IsFullMonth =:= 1
             -> MonthAvgSalary is round(MonthAvgSalary0)
            ; MonthAvgSalary is round(MonthAvgSalary0 / MonthDays * CalcDays)
            ),
            Wage > MonthAvgSalary,
            !.
        check_month_wage_sick(_, _, _, _, Wage, Wage) :-
            !.
        
        % расчитать заработок за месяц
        % - для отпусков
        cacl_month_wage(Scope, PK, Y, M, Wage, MonthModernCoef, ModernWage, SalaryOld, SalaryNew) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            findall( ChargeOption-Debits0,
            (
            % параметры выбора начислений
            member(ChargeOption, [tbl_charge, dbf_sums]),
            % взять начисления
            findall( Debit-ModernCoef-SalaryOld0-SalaryNew0,
                  % для начисления по одному из параметров
                  % где дата совпадает с проверяемым месяцем
                  ( usr_wg_TblCharge_mix(Scope, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-TheDay,
                        fDebit-Debit, fFeeTypeKey-FeeTypeKey ],
                                            ChargeOption),
                  % и соответствующего типа
                  once( ( var(FeeTypeKey)
                        ; get_data(Scope, kb, usr_wg_FeeType, [
                                    fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                    fFeeTypeKey-FeeTypeKey ])
                        ; FeeTypeKey < 10
                        )
                      ),
                  % с коэффициентом осовременивания
                  get_modern_coef(Scope, PK, TheDay, FeeTypeKey, ModernCoef, SalaryOld0, SalaryNew0)
                  ),
            % в список начислений
            Debits0 )
            ),
            Debits0List ),
            % сформировать список начислений
            ( Debits0List = [tbl_charge-Debits1, dbf_sums-[]] ->
              Debits = Debits1
            ; Debits0List = [tbl_charge-Debits1, dbf_sums-Debits2],
              append([Debits1, Debits2], Debits)
            ),
            % всего за месяц
            sum_month_debit(Debits, Wage, ModernWage0),
            % средний за месяц коэффициент осовременивания
            catch( MonthModernCoef0 is ModernWage0 / Wage, _, fail),
            to_currency(MonthModernCoef0, MonthModernCoef, 2),
            % осовремененный заработок
            ModernWage is round(Wage * MonthModernCoef),
            % старый и новый оклады
            ( setof( SalaryOld0-SalaryNew0,
                    Debit ^ ModernCoef ^ member(Debit-ModernCoef-SalaryOld0-SalaryNew0, Debits),
                    [SalaryOld-SalaryNew]
                   )
            ; [SalaryOld-SalaryNew] = [0-0]
            ),
            !.
        
        % итого зарплата и осовремененная зарплата за месяц
        % - для отпусков
        sum_month_debit(Debits, Wage, ModernWage) :-
            sum_month_debit(Debits, Wage, ModernWage, 0, 0),
            !.
        %
        sum_month_debit([], Wage, ModernWage, Wage, ModernWage) :-
            !.
        sum_month_debit([Debit-ModernCoef-_-_ | Debits], Wage, ModernWage, Wage0, ModernWage0) :-
            Wage1 is Wage0 + Debit,
            ModernWage1 is ModernWage0 + Debit * ModernCoef,
            !,
            sum_month_debit(Debits, Wage, ModernWage, Wage1, ModernWage1).
        
        % коэффициент осовременивания
        get_modern_coef(Scope, PK, _, FeeTypeKey, 1.0, 0, 0) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % проверить тип начисления на исключение для осовременивания
            get_data(Scope, kb, usr_wg_FeeTypeNoCoef, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fFeeTypeKeyNoCoef-FeeTypeKey ]),
            !.
        get_modern_coef(Scope, PK, TheDay, _, ModernCoef, SalaryOld, SalaryNew) :-
            % взять параметр коэфициента и дату ограничения расчета
            append(PK, [pDateCalc-DateTo, pCoefOption-CoefOption], Pairs),
            get_param_list(Scope, run, Pairs),
            % сформировать дату ограничения выплаты
            date_add(DateTo, 1, month, DateTo1),
            % сформировать список движений дата-сумма
            findall( Date-Amount,
                     get_modern_coef_data(PK, Scope, Date, Amount, CoefOption, DateTo1),
            Movements ),
            % вычислить коэффициент
            calc_modern_coef(TheDay, Movements, ModernCoef, SalaryOld, SalaryNew),
            !.
        
        % взять данные для расчета коэфициента осовременивания
        %
        get_modern_coef_data(PK, Scope, Date, FCRateSum, CoefOption, DateTo) :-
            % справочник базовых величин - тарифная ставка 1-го разряда
            nonvar(CoefOption), CoefOption = fc_fcratesum,
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные из справочника по ставке
            get_data(Scope, kb, usr_wg_FCRate, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDate-Date, fFCRateSum-FCRateSum ]),
            % где дата меньше расчетной
            Date @< DateTo.
        %
        get_modern_coef_data(PK, Scope, DateBegin, Rate, CoefOption, DateTo) :-
            % движение - тарифная ставка 1-го разряда
            nonvar(CoefOption), CoefOption = ml_rate,
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные из движения по ставке
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fRate-Rate ]),
            % где дата меньше расчетной
            DateBegin @< DateTo.
        %
        get_modern_coef_data(PK, Scope, DateBegin, MSalary, CoefOption, DateTo) :-
            % движение - оклад
            nonvar(CoefOption), CoefOption = ml_msalary,
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные из движения по окладу
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fMSalary-MSalary ]),
            % где дата меньше расчетной
            DateBegin @< DateTo.
        
        % вычислить коэффициент
        calc_modern_coef(_, [ _-Rate | [] ], 1.0, Rate, Rate) :-
            % если последнее движение, то коэффициент 1
            !.
        calc_modern_coef(TheDay, [ Date1-Rate1, Date2-Rate2 | Movements ], ModernCoef, Rate1, RateLast) :-
            % если проверяемая дата больше или равна даты текущего движения
            TheDay @>= Date1,
            % и меньше даты следующего движения
            TheDay @< Date2,
            % то взять последнюю ставку из следующего и всех оставшихся движений
            last([Date2-Rate2 | Movements], _-RateLast),
            % и вычислить коэффициент для текущего движения
            catch( ModernCoef0 is RateLast / Rate1, _, fail),
            ( ModernCoef0 < 1.0, ModernCoef = 1.0 ; ModernCoef = ModernCoef0 ),
            !.
        calc_modern_coef(TheDay, [ _ | Movements ], ModernCoef, Rate, RateLast) :-
            % проверить для остальных движений
            !,
            calc_modern_coef(TheDay, Movements, ModernCoef, Rate, RateLast).
        
        % расчитать заработок за месяц
        % - для больничных
        cacl_month_wage_sick(Scope, PK, Y, M, Wage) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            findall( ChargeOption-Debits0,
            (
            % параметры выбора начислений
            member(ChargeOption, [tbl_charge, dbf_sums]),
            % взять начисления
            findall( Debit-FeeTypeKey,
                  % для начисления по одному из параметров
                  % где дата совпадает с проверяемым месяцем
                  ( usr_wg_TblCharge_mix(Scope, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-_,
                        fDebit-Debit, fFeeTypeKey-FeeTypeKey ],
                                            ChargeOption),
                  % и соответствующего типа
                  once( ( var(FeeTypeKey)
                        ; get_data(Scope, kb, usr_wg_FeeType, [
                                    fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                    fFeeTypeKey-FeeTypeKey ])
                        ; FeeTypeKey < 10
                        )
                      )
                  ),
            % в список начислений
            Debits0 )
            ),
            Debits0List ),
            % сформировать список начислений
            ( Debits0List = [tbl_charge-Debits1, dbf_sums-[]] ->
              Debits = Debits1
            ; Debits0List = [tbl_charge-Debits1, dbf_sums-Debits2],
              append([Debits1, Debits2], Debits)
            ),
            % всего за месяц
            sum_month_debit_sick(Scope, PK, Y, M, Debits, Wage),
            !.
        cacl_month_wage_sick(_, _, _, _, 0.0) :-
            !.
        
        % итого зарплата за месяц
        % - для больничных
        sum_month_debit_sick(Scope, PK, Y, M, Debits, Wage) :-
            % расчитать сумму начислений
            sum_month_debit_sick(Scope, PK, Y, M, Debits, Wage, 0.0),
            !.
        %
        sum_month_debit_sick(_, _, _, _, [], Wage, Wage) :-
            !.
        sum_month_debit_sick(Scope, PK, Y, M, [Debit-FeeTypeKey | Debits], Wage, Wage0) :-
            nonvar(FeeTypeKey),
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % тип начисления для пропорционального расчета
            ( get_data(Scope, kb, usr_wg_FeeTypeProp, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fFeeTypeKeyProp-FeeTypeKey ])
            -> true
            ; FeeTypeKey = 1 ),
            % взять коэфициент для пропорционального начисления
            get_prop_coef(Scope, PK, Y, M, PropCoef),
            % пропорциональный расчет
            Debit1 is round(Debit * PropCoef),
            Wage1 is Wage0 + Debit1,
            !,
            sum_month_debit_sick(Scope, PK, Y, M, Debits, Wage, Wage1).
        sum_month_debit_sick(Scope, PK, Y, M, [Debit-_ | Debits], Wage, Wage0) :-
            % обычный расчет
            Wage1 is Wage0 + Debit,
            !,
            sum_month_debit_sick(Scope, PK, Y, M, Debits, Wage, Wage1).
        
        % взять коэфициент для пропорционального начисления
        get_prop_coef(Scope, PK, Y, M, PropCoef) :-
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures),
            % расчитать коэфициент для пропорционального начисления
            calc_prop_coef(TDays, NDays, THoures, NHoures, PropCoef),
            !.
        
        % расчитать коэффициент для пропорционального начисления
        calc_prop_coef(TabDays, NormDays, TabHoures, NormHoures, PropCoef) :-
            ( TabDays =:= 0, % комментировать, если приоритет по часам
              TabHoures > 0,
              NormHoures > 0
             ->
              PropCoef is TabHoures / NormHoures
            ; TabDays > 0,
              NormDays > 0,
              PropCoef is TabDays / NormDays
            ),
            \+ PropCoef > 1.0,
            !.
        calc_prop_coef(_, _, _, _, 1.0) :-
            !.
        
        % добавление временных данных по расчетным дням
        % - для больничных
        add_month_days_sick(_, _, []):-
            % больше месяцев для проверки нет
            !.
        add_month_days_sick(Scope, PK, [Y-M|Periods]) :-
            % проверить данные по расчетным дням
            get_month_days_sick(Scope, PK, Y, M, _, _, _, _),
            !,
            % проверить остальные месяцы
            add_month_days_sick(Scope, PK, Periods).
        add_month_days_sick(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            add_month_days_sick(Scope, PK, Periods).
        
        % взять данные по расчетным дням
        % - для больничных
        get_month_days_sick(Scope, PK, Y, M, MonthDays, CalcDays, IsFullMonth, IsSpecMonth) :-
            % взять из временных параметров данные по расчетным дням
            append(PK, [pYM-Y-M, pRule-_,
                        pMonthDays-MonthDays, pExclDays-_,
                        pCalcDays-CalcDays, pIsFullMonth-IsFullMonth,
                        pIsSpecMonth-IsSpecMonth],
                    Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_days_sick(Scope, PK, Y, M, MonthDays, CalcDays, IsFullMonth, IsSpecMonth) :-
            % календарных дней в месяце
            month_days(Y, M, MonthDays),
            % исключаемые из месяца дни по правилам
            excl_month_days_sick(Scope, PK, Y, M, ExclDays0, SpecExclDays, Variant),
            % исключаемые из первого месяца работы дни
            excl_first_month_days_sick(Scope, PK, Y, M, ExclDays1),
            % исключаемые дни
            ExclDays is ExclDays0 + ExclDays1,
            % расчетные дни
            CalcDays is MonthDays - ExclDays,
            % Травма производственная
            ( get_param(Scope, in, pIllType-IllType),
              catch( wg_job_ill_type(IllType), _, fail)
             ->
              % расчитать табель за месяц
              calc_month_tab(Scope, PK, Y-M, TabDays),
              % сумма дней и часов по табелю
              sum_days_houres(TabDays, TDays, _),
              CalcDays1 = TDays
            ;
              CalcDays1 = CalcDays
            ),
            % полнота месяца
            ( CalcDays1 = MonthDays -> IsFullMonth = 1 ; IsFullMonth = 0 ),
            % все дни для исключения специальные
            ( ExclDays = SpecExclDays -> IsSpecMonth = 1 ; IsSpecMonth = 0 ),
            % записать во временные параметры данные по расчетным дням
            append(PK, [pYM-Y-M, pRule-Variant,
                        pMonthDays-MonthDays, pExclDays-ExclDays,
                        pCalcDays-CalcDays1, pIsFullMonth-IsFullMonth,
                        pIsSpecMonth-IsSpecMonth],
                    Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % исключаемые из месяца дни
        % - для больничных
        excl_month_days_sick(Scope, PK, Y, M, ExclDays, SpecExclDays, Rule) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % параметры выбора табеля
            member(TabelOption-Rule, [tbl_cal_flex-by_cal_flex, tbl_cal-by_cal]),
            % есть данные в табеле
            usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, TabelOption),
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % взять данные из табеля
            findall( ExclType,
                      % для проверяемого месяца
                    ( usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, HoureType, TabelOption),
                      % с контролем наличия типа часов
                      HoureType > 0,
                      % по типу часов для исключения из расчета
                      once( get_data(Scope, kb, usr_wg_HourType, [
                                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                        fID-HoureType, fExcludeForSickList-1,
                                        fExclType-ExclType] ) )
                    ),
            % в список дней для исключения
            ExclDaysList),
            % проверить список дней для исключения
            \+ ExclDaysList = [],
            % всего дней для исключения
            length(ExclDaysList, ExclDays),
            % сбор специальных исключаемых дней
            findall( SpecExclType,
                    ( member(SpecExclType, ExclDaysList),
                      memberchk(SpecExclType, ["kind_day"]) ),
            SpecExclDaysList),
            % всего специальных дней для исключения
            length(SpecExclDaysList, SpecExclDays),
            !.
        excl_month_days_sick(Scope, PK, Y, M, ExclDays, SpecExclDays, Rule) :-
            Rule = by_orders,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % нет данных в табеле
            \+ usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, tbl_cal_flex),
            \+ usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, tbl_cal),
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные
            findall( exlc_days([FromDate, ToDate, ExclType, OrderType, ExclWeekDay]),
                     % из приказов по дням исключения
                     get_data(Scope, kb, usr_wg_ExclDays, [
                                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                fExclType-ExclType, fOrderType-OrderType,
                                fExclWeekDay-ExclWeekDay,
                                fFromDate-FromDate, fToDate-ToDate] ),
            % в список периодов для исключения
            ExclPeriods),
            % сбор исключаемых дней по списку периодов
            collect_excl_days(ExclPeriods, Y, M, [], LogDays, []),
            % всего дней для исключения
            length(LogDays, ExclDays),
            \+ ExclDays =:= 0,
            % сбор специальных исключаемых дней по списку периодов
            collect_excl_days(ExclPeriods, Y, M, [], LogSpecDays, ["KINDDAYLINE"]),
            % всего специальных дней для исключения
            length(LogSpecDays, SpecExclDays),
            !.
        excl_month_days_sick(_, _, _, _, 0, 0, none) :-
            !.
        
        % сбор исключаемых дней по списку периодов
        collect_excl_days([], _, _, LogDays, LogDays, _) :-
            !.
        collect_excl_days([ExclPeriod|ExclPeriods], Y, M, LogDays0, LogDays2, SpecList) :-
            % сбор исключаемых дней за период
            collect_excl_days(ExclPeriod, Y, M, LogDays0, LogDays1, SpecList),
            !,
            collect_excl_days(ExclPeriods, Y, M, LogDays1, LogDays2, SpecList).
        
        % сбор исключаемых дней за период
        collect_excl_days(exlc_days([FromDate, ToDate | _]), _, _, LogDays, LogDays, _) :-
            FromDate @> ToDate,
            !.
        collect_excl_days(exlc_days([FromDate0|ExclDays]), Y, M, LogDays0, LogDays2, SpecList) :-
            \+ atom_date(FromDate0, date(Y, M, _)),
            date_add(FromDate0, 1, day, FromDate1),
            !,
            collect_excl_days(exlc_days([FromDate1|ExclDays]), Y, M, LogDays0, LogDays2, SpecList).
        collect_excl_days(exlc_days([FromDate0, ToDate, ExclType | ExclDays]), Y, M, LogDays0, LogDays2, SpecList) :-
            % добавление дня для исключения в журнал
            ( ( SpecList = [] ; memberchk(ExclType, SpecList) )
            -> add_excl_day(exlc_days([FromDate0, ExclType | ExclDays]), LogDays0, LogDays1)
            ; true ),
            date_add(FromDate0, 1, day, FromDate1),
            !,
            collect_excl_days(exlc_days([FromDate1, ToDate, ExclType | ExclDays]), Y, M, LogDays1, LogDays2, SpecList).
        
        % добавление дня для исключения в журнал
        add_excl_day(exlc_days([TheDate|_]), LogDays, LogDays) :-
            % при наличии даты в журнале
            memberchk(TheDate, LogDays),
            % журнал не изменять
            !.
        add_excl_day(exlc_days([TheDate, ExclType, OrderType | _]), LogDays, LogDays) :-
            % праздник из отпуска
            ExclType = "LEAVEDOCLINE",
            catch( wg_holiday(TheDate), _, fail ),
            % трудовой отпуск
            OrderType = 1,
            % в журнал не заносить
            !.
        add_excl_day(exlc_days([TheDate, ExclType, _, ExclWeekDay]), LogDays, [TheDate|LogDays]) :-
            % детский день согласно дню недели
            ExclType = "KINDDAYLINE",
            weekday(TheDate, ExclWeekDay),
            % занести в журнал
            !.
        add_excl_day(exlc_days([_, ExclType | _]), LogDays, LogDays) :-
            % прочие даты из приказа о детском дне
            ExclType = "KINDDAYLINE",
            % пропускать
            !.
        add_excl_day(exlc_days([TheDate|_]), LogDays, [TheDate|LogDays]) :-
            % дату для прочих случаев занести в журнал
            !.
        
        % исключаемые из первого месяца работы дни
        % - для больничных
        excl_first_month_days_sick(Scope, PK, Y, M, ExclDays) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для первого движения по типу 1 (прием на работу)
            % где дата совпадает с проверяемым месяцем
            get_data(Scope, kb, usr_wg_MovementLine, [
                fEmplKey-EmplKey, fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                fMoveYear-Y, fMoveMonth-M, fDateBegin-DateBegin, fMovementType-1 ]),
            % и является датой последнего приема на работу
            get_last_hire(Scope, PK, DateBegin),
            % исключить дни до принятия на работу
            atom_date(FirstMonthDate, date(Y, M, 1)),
            date_diff(FirstMonthDate, ExclDays, DateBegin),
            !.
        excl_first_month_days_sick(_, _, _, _, 0) :-
            !.
        
        % расчитать заработок за месяц
        % - для начисления по-среднему
        cacl_month_wage_avg(Scope, PK, Y, M, Wage) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            findall( ChargeOption-Debits0,
            (
            % параметры выбора начислений
            member(ChargeOption, [tbl_charge, dbf_sums]),
            % взять начисления
            findall( Debit,
                  % для начисления по одному из параметров
                  % где дата совпадает с проверяемым месяцем
                  ( usr_wg_TblCharge_mix(Scope, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-_,
                        fDebit-Debit, fFeeTypeKey-FeeTypeKey ],
                                            ChargeOption),
                  % и соответствующего типа
                  once( ( var(FeeTypeKey)
                        ; get_data(Scope, kb, usr_wg_FeeType, [
                                    fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                    fFeeTypeKey-FeeTypeKey ])
                        ; FeeTypeKey < 10
                        )
                      )
                  ),
            % в список начислений
            Debits0 )
            ),
            Debits0List ),
            % сформировать список начислений
            ( Debits0List = [tbl_charge-Debits1, dbf_sums-[]] ->
              Debits = Debits1
            ; Debits0List = [tbl_charge-Debits1, dbf_sums-Debits2],
              append([Debits1, Debits2], Debits)
            ),
            % всего за месяц
            sum_list(Debits, Wage),
            !.
        cacl_month_wage_avg(_, _, _, _, 0.0) :-
            !.
        
        % месяц работы полный
        is_full_month(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для первого движения по типу 1 (прием на работу)
            % где дата совпадает с проверяемым месяцем
            get_data(Scope, kb, usr_wg_MovementLine, [
                fEmplKey-EmplKey, fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                fMoveYear-Y, fMoveMonth-M, fDateBegin-DateBegin, fMovementType-1 ]),
            % и является датой последнего приема на работу
            get_last_hire(Scope, PK, DateBegin),
            !,
            % параметры выбора графика
            member(NormOption, [tbl_cal_flex, tbl_day_norm]),
            % первый рабочий день по графику для проверяемого месяца
            once( usr_wg_TblDayNorm_mix(Scope, PK, Y-M, TheDay, _, 1, NormOption) ),
            !,
            % больше или равен дате первого движения
            TheDay @>= DateBegin,
            % то первый месяц работы полный
            !.
        is_full_month(_, _, _) :-
            % проверяемый месяц не является первым месяцем работы
            !.
        
        % в месяце есть отработанные дни или часы
        is_month_worked(Scope, PK, Y-M) :-
            % если есть хотя бы один рабочий день
            usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, DOW, HOW, _, _),
            % с контролем наличия дней или часов
            once( (DOW > 0 ; HOW > 0 ) ),
            % то в месяце есть отработанные дни или часы
            !.
        
        % в месяце есть оплата
        is_month_paid(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если есть хотя бы одно начисление
            usr_wg_TblCharge_mix(Scope, [
                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                fCalYear-Y, fCalMonth-M, fDateBegin-_,
                fDebit-Debit, fFeeTypeKey-FeeTypeKey ],
                                    _),
            % с контролем суммы
            Debit > 0,
            % соответствующего типа
            ( var(FeeTypeKey)
            ; once( get_data(Scope, kb, usr_wg_FeeType, [
                            fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                            fFeeTypeKey-FeeTypeKey ]) )
            ; FeeTypeKey < 10
            ),
            % то в месяце есть оплата
            !.
        
        % взять расчетный месяц
        get_month_incl(Scope, PK, Y, M, Variant) :-
            append(PK, [pMonthIncl-MonthInclList], Pairs),
            get_param_list(Scope, temp, Pairs),
            member(Y-M-Variant, MonthInclList).
        
        % принять месяц для исчисления
        take_month_incl(Scope, PK, Y, M, Variant) :-
            append(PK, [pMonthIncl-MonthInclList], Pairs),
            get_param_list(Scope, temp, Pairs),
            keysort([Y-M-Variant | MonthInclList], MonthInclList1),
            append(PK, [pMonthIncl-MonthInclList1], Pairs1),
            dispose_param_list(Scope, temp, Pairs),
            new_param_list(Scope, temp, Pairs1),
            !.
        take_month_incl(Scope, PK, Y, M, Variant) :-
            append(PK, [pMonthIncl-[Y-M-Variant]], Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % проверка месяца по табелю
        % - для отпусков
        check_month_tab(_, _, []):-
            % больше месяцев для проверки нет
            !.
        check_month_tab(Scope, PK, [Y-M|Periods]) :-
            % месяц работы полный
            is_full_month(Scope, PK, Y-M),
            % в месяце есть отработанные дни или часы
            is_month_worked(Scope, PK, Y-M),
            % в месяце есть оплата
            is_month_paid(Scope, PK, Y-M),
            % и выполняется одно из правил
            rule_month_tab(Scope, PK, Y-M, Variant),
            % то принять месяц для исчисления
            take_month_incl(Scope, PK, Y, M, Variant),
            !,
            % проверить остальные месяцы
            check_month_tab(Scope, PK, Periods).
        check_month_tab(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            check_month_tab(Scope, PK, Periods).
        
        % правила включения месяца в расчет
        rule_month_tab(Scope, PK, Y-M, Rule) :-
            % по дням и часам за месяц
            Rule = by_days_houres,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures),
            % если табель равен графику по дням и часам
            TDays =:= NDays, THoures =:= NHoures,
            % то месяц включается в расчет
            !.
        rule_month_tab(Scope, PK, Y-M, Rule) :-
            % по часам за месяц
            Rule = by_houres,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, _, _, NHoures, THoures),
            % если табель покрывает график по часам
            THoures >= NHoures,
            % то месяц включается в расчет
            !.
        rule_month_tab(Scope, PK, Y-M, Rule) :-
            % по дням за месяц
            Rule = by_days,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, _, _),
            % если табель покрывает график по дням
            TDays >= NDays,
            % то месяц включается в расчет
            !.
        
        % взять данные по графику и табелю за месяц
        get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures) :-
            % взять из временных параметров дни и часы
            append(PK, [pYM-Y-M,
                        pTDays-TDays, pTHoures-THoures,
                        pNDays-NDays, pNHoures-NHoures],
                        Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures) :-
            % расчитать график и табель за месяц
            calc_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures),
            % записать во временные параметры дни и часы
            append(PK, [pYM-Y-M,
                        pTDays-TDays, pTHoures-THoures,
                        pNDays-NDays, pNHoures-NHoures],
                        Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % расчитать график и табель за месяц
        calc_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures) :-
            % расчитать график за месяц
            calc_month_norm(Scope, PK, Y-M, [tbl_cal_flex, tbl_day_norm], NormDays),
            % сумма дней и часов по графику
            sum_days_houres(NormDays, NDays, NHoures),
            % расчитать табель за месяц
            calc_month_tab(Scope, PK, Y-M, TabDays),
            % сумма дней и часов по табелю
            sum_days_houres(TabDays, TDays, THoures),
            !.
        
        % расчитать график за месяц по одному из параметров
        calc_month_norm(Scope, PK, Y-M, NormOptionList, NormDays) :-
            % параметры выбора графика
            member(NormOption, NormOptionList),
            % взять дату/часы
            findall( TheDay-1-WDuration,
                    % для рабочего дня
                    ( usr_wg_TblDayNorm_mix(Scope, PK, Y-M, TheDay, WDuration, 1, NormOption),
                    % с контролем наличия часов
                    WDuration > 0 ),
            % в список дата/часы графика
            NormDays),
            % проверить список графика
            \+ NormDays = [],
            !.
        calc_month_norm(_, _, _, _, []) :-
            !.
        
        % расчитать график за год по одному из параметров
        calc_year_norm(Scope, PK, NormDays) :-
            get_norm_periods(Scope, PK, Periods),
            calc_year_norm(Periods, Scope, PK, [], NormDays),
            !.
        %
        calc_year_norm([], _, _, NormDays, NormDays) :-
            !.
        calc_year_norm([Y-M|Periods], Scope, PK, NormDays0, NormDays) :-
            calc_month_norm(Scope, PK, Y-M, [tbl_day_norm], NormDays1),
            append(NormDays0, NormDays1, NormDays2),
            !,
            calc_year_norm(Periods, Scope, PK, NormDays2, NormDays).
        
        % нормативные периоды
        get_norm_periods(Scope, PK, Periods) :-
            % взять нормативные даты ограничения расчета
            append(PK, [pDateNormFrom-DateFrom, pDateNormTo-DateTo], Pairs),
            get_param_list(Scope, run, Pairs),
            % сформировать список периодов
            make_periods(Scope, PK, DateFrom, DateTo, Periods, 1),
            !.
        
        % проверка месяца по заработку
        % - для отпусков
        check_month_wage(_, _, []):-
            % больше месяцев для проверки нет
            !.
        check_month_wage(Scope, PK, [Y-M|Periods]) :-
            % если месяц еще не включен в расчет
            \+ get_month_incl(Scope, PK, Y, M, _),
            % и выполняется одно из правил
            rule_month_wage(Scope, PK, Y-M, Variant),
            % то принять месяц для исчисления
            take_month_incl(Scope, PK, Y, M, Variant),
            !,
            % проверить следующий месяц
            check_month_wage(Scope, PK, Periods).
        check_month_wage(Scope, PK, [_|Periods]) :-
            !,
            % проверить следующий месяц
            check_month_wage(Scope, PK, Periods).
        
        % заработок за месяц в сравнении с полными месяцами
        rule_month_wage(Scope, PK, Y-M, Rule) :-
            Shapes = [
                      % покрывает любой из полных месяцев
                      by_month_wage_any - wage_over_any,
                      % покрывает каждый из полных месяцев
                      by_month_wage_all - wage_over_list
                      ],
            member(Rule - Condition, Shapes),
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % варианты правил полных месяцев
            wg_full_month_rules(FullMonthRules),
            % взять заработок и коэффициент осовременивания за проверяемый месяц
            get_month_wage(Scope, PK, Y, M, ModernCoef, Wage),
            % взять заработок
            findall( Wage1,
                      % для расчетного месяца
                    ( get_month_incl(Scope, PK, Y1, M1, Variant1),
                      % который принят для исчисления по варианту полного месяца
                      memberchk(Variant1, FullMonthRules),
                      % с заработком и коэффициентом осовременивания за месяц
                      get_month_wage(Scope, PK, Y1, M1, ModernCoef1, Wage1),
                      % где коэффициенты для проверяемого и расчетного равны
                      ModernCoef =:= ModernCoef1 ),
            % в список заработков
            Wages1 ),
            % если заработок проверяемого месяца соответствует условию
            Term =.. [Condition, Wage, Wages1], Term,
            % то месяц включается в расчет
            !.
        % заработок за месяц не меньше среднемесячного по полным месяцам
        rule_month_wage(Scope, PK, Y-M, Rule) :-
            Rule = by_month_avg_wage,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % варианты правил полных месяцев
            wg_full_month_rules(FullMonthRules1),
            wg_full_month_rules_cond(FullMonthRules2),
            append(FullMonthRules1, FullMonthRules2, FullMonthRules),
            % взять заработок за проверяемый месяц
            get_month_wage(Scope, PK, Y, M, _, Wage),
            % взять заработок
            findall( Wage1,
                      % для расчетного месяца
                    ( get_month_incl(Scope, PK, Y1, M1, Variant1),
                      % который принят для исчисления по варианту полного месяца
                      memberchk(Variant1, FullMonthRules),
                      % с заработком  за месяц
                      get_month_wage(Scope, PK, Y1, M1, _, Wage1)
                    ),
            % в список заработков
            Wages1 ),
            % итоговый заработок за полные месяцы
            sum_list(Wages1, Amount),
            % количество полных месяцев
            length(Wages1, Num),
            % среднемесячный заработок
            catch( MonthAvgWage is round(Amount / Num), _, fail ),
            % заработок за месяц не меньше среднемесячного
            Wage >= MonthAvgWage,
            !.
        
        % заработок покрывает любое значение из списка
        wage_over_any(Over, [Head|_]) :-
            Over >= Head,
            !.
        wage_over_any(Over, [_|Tail]) :-
            !,
            wage_over_any(Over, Tail).
        
        % заработок покрывает все значения из списка
        wage_over_list(Over, [Head|[]]) :-
            Over >= Head,
            !.
        wage_over_list(Over, [Head|Tail]) :-
            Over >= Head,
            !,
            wage_over_list(Over, Tail).
        
        % проверка месяца по типу начислений и типу часов
        % - для отпусков
        check_month_no_bad_type(_, _, []):-
            % больше месяцев для проверки нет
            !.
        check_month_no_bad_type(Scope, PK, [Y-M|Periods]) :-
            % если месяц еще не включен в расчет
            \+ get_month_incl(Scope, PK, Y, M, _),
            % месяц работы полный
            is_full_month(Scope, PK, Y-M),
            % в месяце есть оплата
            is_month_paid(Scope, PK, Y-M),
            % и выполняется одно из правил
            rule_month_no_bad_type(Scope, PK, Y-M, Variant),
            % то принять месяц для исчисления
            take_month_incl(Scope, PK, Y, M, Variant),
            !,
            % проверить следующий месяц
            check_month_no_bad_type(Scope, PK, Periods).
        check_month_no_bad_type(Scope, PK, [_|Periods]) :-
            !,
            % проверить следующий месяц
            check_month_no_bad_type(Scope, PK, Periods).
        
        % отсутствие плохих типов начислений и часов
        rule_month_no_bad_type(Scope, PK, Y-M, Rule) :-
            Rule = by_month_no_bad_type,
            % правило действительно
            is_valid_rule(Scope, PK, _, Rule),
            % если нет плохих типов начислений и часов
            \+ month_bad_type(Scope, PK, Y-M),
            % то месяц включается в расчет
            !.
        
        % есть плохой тип часов
        month_bad_type(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если есть хотя бы один день по табелю
            usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, HoureType, _),
            % с плохим типом часов
            nonvar(HoureType),
            HoureType > 0,
            once( get_data(Scope, kb, usr_wg_BadHourType, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey, fID-HoureType]) ),
            !.
        % есть плохой тип начислений
        month_bad_type(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если есть хотя бы одно начисление
            % где дата совпадает с проверяемым месяцем
            usr_wg_TblCharge_mix(Scope, [
                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                fCalYear-Y, fCalMonth-M, fDateBegin-_,
                fDebit-_, fFeeTypeKey-FeeTypeKey ],
                                    _),
            % с плохим типом начисления
            nonvar(FeeTypeKey),
            FeeTypeKey > 0,
            once( get_data(Scope, kb, usr_wg_BadFeeType, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey, fID-FeeTypeKey]) ),
            !.
        month_bad_type(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % нет данных в табеле
            \+ usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, tbl_cal_flex),
            \+ usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, tbl_cal),
            % из приказов по дням исключения
            get_data(Scope, kb, usr_wg_ExclDays, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fExclType-ExclType, fHourType-HoureType,
                        fFromDate-FromDate, fToDate-ToDate] ),
            % для отпусков
            ExclType = "LEAVEDOCLINE",
            % с плохим типом часов
            nonvar(HoureType),
            HoureType > 0,
            once( get_data(Scope, kb, usr_wg_BadHourType, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey, fID-HoureType]) ),
            % входящих в проверяемый месяц
            ( atom_date(FromDate, date(Y, M, _)) ; atom_date(ToDate, date(Y, M, _)) ),
            !.
        month_bad_type(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % нет данных в табеле
            \+ usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, tbl_cal_flex),
            \+ usr_wg_TblCalLine_mix(Scope, PK, Y-M, _, _, _, _, tbl_cal),
            % из приказов по дням исключения
            get_data(Scope, kb, usr_wg_ExclDays, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fExclType-ExclType,
                        fFromDate-FromDate, fToDate-ToDate] ),
            % для больничных
            ExclType = "SICKLISTJOURNAL",
            % входящих в проверяемый месяц
            ( atom_date(FromDate, date(Y, M, _)) ; atom_date(ToDate, date(Y, M, _)) ),
            !.
        
        /* реализация - механизм подготовки данных */
        
        %% engine_loop(+Scope, +Type, +PK)
        %
        
        % args handler
        engine_loop(Scope, Type, PK) :-
            \+ ground([Scope, Type, PK]),
            !,
            fail.
        % fail handler
        engine_loop(Scope, _, PK) :-
            engine_fail_step(Type),
            get_param_list(Scope, Type, PK),
            !,
            fail.
        % deal handler
        engine_loop(Scope, Type, PK) :-
            engine_deal_step(Type),
            !,
            get_param_list(Scope, Type, PK),
            !.
        % data handler
        engine_loop(Scope, Type, PK) :-
            engine_data_step(Type, TypeNextStep),
            get_param_list(Scope, Type, PK),
            \+ get_param_list(Scope, TypeNextStep, PK),
            prepare_data(Scope, Type, PK, TypeNextStep),
            !,
            engine_loop(Scope, TypeNextStep, PK).
        engine_loop(Scope, Type, PK) :-
            engine_data_step(Type, TypeNextStep),
            !,
            engine_loop(Scope, TypeNextStep, PK).
        % restart handler
        engine_loop(Scope, Type, PK) :-
            engine_restart_step(Type, TypeNextStep),
            forall( ( get_param_list(Scope, ParamType, PK, Pairs),
                      \+ ParamType = TypeNextStep ),
                    dispose_param_list(Scope, ParamType, Pairs)
                  ),
            !,
            engine_loop(Scope, TypeNextStep, PK).
        % error handler
        engine_loop(Scope, Type, PK) :-
            engine_error_step(TypeNextStep),
            \+ get_param_list(Scope, TypeNextStep, PK),
            get_local_date_time(DT),
            append(PK, [Type, DT], PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            !,
            fail.
        
        %
        engine_data_step(in, run).
        engine_data_step(run, query).
        engine_data_step(query, data).
        %
        engine_deal_step(run) :-
            debug_mode,
            !.
        engine_deal_step(data).
        %
        engine_fail_step(out).
        engine_fail_step(error).
        %
        engine_restart_step(restart, in).
        %
        engine_error_step(error).
        
         %
        %%
        
        /* реализация - подготовка данных */
        
        % in-run
        prepare_data(Scope, Type, PK, TypeNextStep) :-
            memberchk(Scope, [wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg]),
            Type = in, TypeNextStep = run,
            % MonthQty, MonthBonusQty, Pairs01, Pairs02
            ( get_param_list(Scope, Type, [pCommon-1], Pairs01) ; Pairs01 = [] ),
            get_param_list(Scope, Type, [pMonthQty-MonthQty], Pairs02),
            ( member_list([pMonthBonusQty-MonthBonusQty], Pairs02) ; MonthBonusQty = 0 ),
            % DateCalc, MonthOffset, MonthBefore, Pairs
            append(PK, [pDateCalc-DateCalc], Pairs03),
            get_param_list(Scope, Type, Pairs03, Pairs),
            ( member_list([pMonthOffset-MonthOffset], Pairs) ; MonthOffset = 0 ),
            ( member_list([pMonthBefore-MonthBefore], Pairs) ; MonthBefore = 0 ),
            % DateCalcFrom, DateCalcTo
            atom_date(DateCalc, date(Y0, M0, _)),
            atom_date(DateCalcTo0, date(Y0, M0, 1)),
            MonthOffset1 is (- MonthOffset),
            date_add(DateCalcTo0, MonthOffset1, month, DateCalcTo),
            MonthAdd is (- (MonthQty + MonthBefore)),
            date_add(DateCalcTo, MonthAdd, month, DateCalcFrom),
            % DateNormFrom, DateNormTo
            %date_add(DateCalcTo, -1, day, DateCalcTo1),
            date_add(DateCalcTo, 0, day, DateCalcTo1), % ?
            atom_date(DateCalcTo1, date(Y, _, _)),
            atom_date(DateNormFrom, date(Y, 1, 1)),
            Y1 is Y + 1,
            atom_date(DateNormTo, date(Y1, 1, 1)),
            % DateBonusFrom
            MonthBonusQty1 is (- MonthBonusQty),
            date_add(DateCalcFrom, MonthBonusQty1, month, DateBonusFrom),
            % PairsNextStep
            append([Pairs,
                        [
                        pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo,
                        pDateNormFrom-DateNormFrom, pDateNormTo-DateNormTo,
                        pDateBonusFrom-DateBonusFrom, pDateBonusTo-DateCalcFrom
                        ],
                    Pairs01, Pairs02
                    ],
                    PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            !.
        
        % run-query
        prepare_data(Scope, Type, PK, TypeNextStep) :-
            memberchk(Scope, [wg_avg_wage_vacation, wg_avg_wage_sick, wg_avg_wage_avg]),
            Type = run, TypeNextStep = query,
            get_param_list(Scope, Type, PK, Pairs),
            forall( ( gd_pl_ds(Scope, kb, PredicateName, Arity, _),
                      Query = PredicateName/Arity,
                      is_valid_sql(Query),
                      get_sql(Scope, kb, Query, SQL, Params),
                      member_list(Params, Pairs),
                      prepare_sql(SQL, Params, PrepSQL),
                      append(PK, [pQuery-Query, pSQL-PrepSQL], PairsNextStep),
                      \+ get_param_list(Scope, TypeNextStep, PairsNextStep)
                    ),
                    new_param_list(Scope, TypeNextStep, PairsNextStep)
                  ),
            !.
        
        /* реализация - расширение для клиента */
        
        %  05. Начисление отпусков
        
        % загрузка входных данных по сотруднику
        % CoefOption: fc_fcratesum ; ml_rate ; ml_msalary
        avg_wage_in(EmplKey, FirstMoveKey, DateCalc, MonthOffset, CoefOption) :-
            Scope = wg_avg_wage_vacation, Type = in,
            new_param_list(Scope, Type,
                [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                 pDateCalc-DateCalc, pMonthOffset-MonthOffset,
                 pCoefOption-CoefOption]),
            !.
        
        % выгрузка детальных выходных данных по сотруднику
        avg_wage_det(EmplKey, FirstMoveKey,
                        Period, Rule, Wage, ModernCoef, ModernWage,
                        TabDays, NormDays, TabHoures, NormHoures,
                        SalaryOld, SalaryNew) :-
            % параметры контекста
            Scope = wg_avg_wage_vacation, Type = temp,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для каждого периода
            % взять данные по табелю и графику
            append(PK, [pYM-Y-M,
                            pTDays-TabDays, pTHoures-TabHoures,
                            pNDays-NormDays, pNHoures-NormHoures],
                    Pairs),
            get_param_list(Scope, Type, Pairs),
            once( (
                % если для первого движения по типу 1 (прием на работу)
                % где дата совпадает с проверяемым месяцем
                get_data(Scope, kb, usr_wg_MovementLine, [
                    fEmplKey-EmplKey,
                    fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                    fMoveYear-Y, fMoveMonth-M, fDateBegin-Period, fMovementType-1 ]),
                % и является датой последнего приема на работу
                get_last_hire(Scope, PK, Period)
                % то период есть дата начала работы
                ;
                % иначе сформировать дату периода, как первый день месяца
                atom_date(Period, date(Y, M, 1))
                ) ),
            % взять данные по правилам расчета
            append(PK, [pMonthIncl-MonthIncl], Pairs1),
            once( ( get_param_list(Scope, Type, Pairs1) ; MonthIncl = [] ) ),
            once( ( memberchk(Y-M-Rule, MonthIncl) ; Rule = none ) ),
            % взять данные по заработку
            once( ( ( append(PK, [pYM-Y-M,
                                    pWage-Wage, pModernCoef-ModernCoef, pModernWage-ModernWage,
                                    pSalaryOld-SalaryOld, pSalaryNew-SalaryNew],
                                Pairs2),
                      get_param_list(Scope, Type, Pairs2) )
                      ; [Wage, ModernCoef, ModernWage, SalaryOld, SalaryNew] = [0, 1, 0, 0, 0] ) ),
            %
            % есть отработанные часы или заработок
            once( ( TabHoures > 0 ; ModernWage > 0 ) ),
            true.
        
        %  06. Начисление больничных
        
        % загрузка входных данных по сотруднику
        avg_wage_sick_in(EmplKey, FirstMoveKey, DateCalc, IsAvgWageDoc, IsPregnancy, IllType) :-
            Scope = wg_avg_wage_sick, Type = in,
            new_param_list(Scope, Type, [
                            pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                            pDateCalc-DateCalc, pIsAvgWageDoc-IsAvgWageDoc,
                            pIsPregnancy-IsPregnancy, pIllType-IllType ]),
            !.
        
        % выгрузка детальных выходных данных по сотруднику
        avg_wage_sick_det(EmplKey, FirstMoveKey,
                            Period, Rule,
                            MonthDays, ExclDays, CalcDays, IsFullMonth, IsSpecMonth,
                            Wage,
                            TabDays, NormDays, TabHoures, NormHoures) :-
            % параметры контекста
            Scope = wg_avg_wage_sick, Type = temp,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для каждого периода
            % взять данные по расчетным дням
            append(PK, [pYM-Y-M, pRule-Rule,
                        pMonthDays-MonthDays, pExclDays-ExclDays,
                        pCalcDays-CalcDays, pIsFullMonth-IsFullMonth,
                        pIsSpecMonth-IsSpecMonth],
                    Pairs),
            get_param_list(Scope, temp, Pairs),
            % взять данные по заработку
            append(PK, [pYM-Y-M, pWage-Wage], Pairs1),
            get_param_list(Scope, Type, Pairs1),
            % взять данные по табелю и графику
            append(PK, [pYM-Y-M,
                            pTDays-TabDays, pTHoures-TabHoures,
                            pNDays-NormDays, pNHoures-NormHoures],
                    Pairs2),
            get_param_list(Scope, Type, Pairs2),
            once( (
                % если для первого движения по типу 1 (прием на работу)
                % где дата совпадает с проверяемым месяцем
                get_data(Scope, kb, usr_wg_MovementLine, [
                    fEmplKey-EmplKey,
                    fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                    fMoveYear-Y, fMoveMonth-M, fDateBegin-Period, fMovementType-1 ]),
                % и является датой последнего приема на работу
                get_last_hire(Scope, PK, Period)
                % то период есть дата начала работы
                ;
                % иначе сформировать дату периода, как первый день месяца
                atom_date(Period, date(Y, M, 1))
                ) ),
            true.
        
        %  12. Начисление по-среднему
        
        % загрузка входных данных по сотруднику
        avg_wage_avg_in(EmplKey, FirstMoveKey, DateCalc, CalcByHoure, MonthBefore, MonthOffset) :-
            Scope = wg_avg_wage_avg, Type = in,
            new_param_list(Scope, Type,
                [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                 pDateCalc-DateCalc, pCalcByHoure-CalcByHoure,
                 pMonthBefore-MonthBefore, pMonthOffset-MonthOffset]),
            !.
        
        % выгрузка детальных выходных данных по сотруднику
        avg_wage_avg_det(EmplKey, FirstMoveKey,
                            Period, Wage,
                            TabDays, NormDays, TabHoures, NormHoures) :-
            % параметры контекста
            Scope = wg_avg_wage_avg, Type = temp,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для каждого периода
            % взять данные по заработку
            append(PK, [pYM-Y-M, pWage-Wage], Pairs1),
            get_param_list(Scope, Type, Pairs1),
            % взять данные по табелю и графику
            append(PK, [pYM-Y-M,
                            pTDays-TabDays, pTHoures-TabHoures,
                            pNDays-NormDays, pNHoures-NormHoures],
                    Pairs2),
            get_param_list(Scope, Type, Pairs2),
            once( (
                % если для первого движения по типу 1 (прием на работу)
                % где дата совпадает с проверяемым месяцем
                get_data(Scope, kb, usr_wg_MovementLine, [
                    fEmplKey-EmplKey,
                    fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                    fMoveYear-Y, fMoveMonth-M, fDateBegin-Period, fMovementType-1 ]),
                % и является датой последнего приема на работу
                get_last_hire(Scope, PK, Period)
                % то период есть дата начала работы
                ;
                % иначе сформировать дату периода, как первый день месяца
                atom_date(Period, date(Y, M, 1))
                ) ),
            true.
        
        
        %  05, 06, 12
        
        % выгрузка SQL-запросов по сотруднику
        avg_wage_sql(Scope, EmplKey, FirstMoveKey, PredicateName, Arity, SQL) :-
            Type = query, TypeNextStep = data,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            Query = PredicateName/Arity,
            append(PK, [pQuery-Query, pSQL-SQL], Pairs),
            get_param_list(Scope, Type, Pairs),
            \+ get_param_list(Scope, TypeNextStep, Pairs).
        
        % подтвеждение формирования фактов по сотруднику
        avg_wage_kb(Scope, EmplKey, FirstMoveKey, PredicateName, Arity, SQL) :-
            Type = query, TypeNextStep = data,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            Query = PredicateName/Arity,
            append(PK, [pQuery-Query, pSQL-SQL], Pairs),
            get_param_list(Scope, Type, Pairs),
            \+ get_param_list(Scope, TypeNextStep, Pairs),
            new_param_list(Scope, TypeNextStep, Pairs),
            !.
        
        % выгрузка данных выполнения по сотруднику
        avg_wage_run(Scope, EmplKey, FirstMoveKey, DateCalcFrom, DateCalcTo) :-
            Type = run,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            append(PK, [pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo], Pairs),
            get_param_list(Scope, Type, Pairs).
        
        % выгрузка выходных данных по сотруднику
        avg_wage_out(Scope, EmplKey, FirstMoveKey, AvgWage, Variant) :-
            Type = out,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные по результатам расчета
            append(PK, [pAvgWage-AvgWage, pVariant-Variant], Pairs),
            get_param_list(Scope, Type, Pairs).
        
        % удаление данных по сотруднику
        avg_wage_clean(Scope, EmplKey, FirstMoveKey) :-
            gd_pl_ds(Scope, Type, Name, _, _),
            del_data(Scope, Type, Name, [fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey]),
            fail.
        avg_wage_clean(Scope, EmplKey, FirstMoveKey) :-
            get_scope_type(Scope-Type),
            get_param_list(Scope, Type, [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey], Pairs),
            dispose_param_list(Scope, Type, Pairs),
            fail.
        avg_wage_clean(_, _, _) :-
            !.
        
        avg_wage_err(Scope, ErrMessage) :-
            Type = error,
            get_param(Scope, Type, pError-ErrMessage),
            true.
        
        /**/
        
        % section twg_struct
        % расчет структуры
        % - для отпусков
        % - для больничных
        %
        
        /* реализация */
        
        %
        struct_vacation_sql(DocKey, DateBegin, DateEnd, PredicateName, Arity, SQL) :-
            Scope = wg_struct_vacation, NextType = run,
            Pairs = [pDocKey-DocKey, pDateBegin-DateBegin, pDateEnd-DateEnd],
            get_sql(Scope, kb, Query, SQL0, Params),
            is_valid_sql(Query),
            Query = PredicateName/Arity,
            member_list(Params, Pairs),
            prepare_sql(SQL0, Params, SQL),
            Pairs1 = [pDocKey-DocKey, pQuery-Query, pSQL-SQL],
            new_param_list(Scope, NextType, Pairs1).
        
        %
        struct_vacation_in(DateCalc, _, _, AvgWage, _) :-
            wg_vacation_compensation(DateFrom, Duration, 1),
            atom_date(DateCalc, date(Year, Month, _)),
            month_days(Year, Month, Days),
            atom_date(AccDate, date(Year, Month, Days)),
            atom_date(DateFrom, date(Y, M, _)),
            atom_date(IncludeDate, date(Y, M, 1)),
            Summa is Duration * AvgWage,
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pDuration-Duration, pSumma-Summa,
                        pDateBegin-AccDate, pDateEnd-AccDate,
                        pVcType-0
                        ],
            new_param_list(struct_vacation, out, OutPairs),
            !.
        struct_vacation_in(DateCalc, DateBegin, DateEnd, AvgWage, SliceOption) :-
            atom_date(DateCalc, date(Year, Month, _)),
            month_days(Year, Month, Days),
            atom_date(AccDate, date(Year, Month, Days)),
            once( (SliceOption = 0, FilterVcType = 0 ; true) ),
            findall( VcType-Slice,
                        ( wg_vacation_slice(VcType, Slice), VcType = FilterVcType ),
                     SliceList0 ),
            keysort(SliceList0, [Slice0|SliceList1]),
            append(SliceList1, [Slice0], SliceList),
            struct_vacation_calc(SliceList, _-0, AccDate, DateBegin, DateEnd, AvgWage),
            !.
        
        %
        struct_vacation_calc([Slice|SliceList], _-Slice0, AccDate, DateBegin, DateEnd, AvgWage) :-
            Slice0 =:= 0,
            !,
            struct_vacation_calc(SliceList, Slice, AccDate, DateBegin, DateEnd, AvgWage).
        struct_vacation_calc(_, _, _, '', '', _) :-
            !.
        struct_vacation_calc([], _-Slice, _, _, _, _) :-
            Slice =:= 0,
            !.
        struct_vacation_calc(SliceList, VcType-Slice, AccDate, DateBegin, DateEnd, AvgWage) :-
            make_period(DateBegin, DateEnd, DateBegin1, DateEnd1, DateBegin2, DateEnd2, Slice, Slice2),
            atom_date(DateBegin1, date(Y, M, _)),
            atom_date(IncludeDate, date(Y, M, 1)),
            sum_vacation_days(DateBegin1, DateEnd1, 1, Duration),
            Summa is Duration * AvgWage,
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pDuration-Duration, pSumma-Summa,
                        pDateBegin-DateBegin1, pDateEnd-DateEnd1,
                        pVcType-VcType
                        ],
            new_param_list(struct_vacation, out, OutPairs),
            !,
            struct_vacation_calc(SliceList, VcType-Slice2, AccDate, DateBegin2, DateEnd2, AvgWage).
        
        %
        sum_vacation_days(DateBegin, DateBegin, Duration0, Duration1) :-
            ( catch( wg_holiday(DateBegin), _, fail ), Duration1 is Duration0 - 1
            ; Duration1 = Duration0 ),
            !.
        sum_vacation_days(DateBegin, DateEnd, Duration0, Duration) :-
            date_add(DateBegin, 1, day, DateBegin1),
            ( catch( wg_holiday(DateBegin), _, fail ), Duration1 = Duration0
            ; Duration1 is Duration0 + 1 ),
            !,
            sum_vacation_days(DateBegin1, DateEnd, Duration1, Duration).
        
        %
        struct_sick_sql(EmplKey, FirstMoveKey, DateBegin, DateEnd, PredicateName, Arity, SQL) :-
            Scope = wg_struct_sick, Type = in, NextType = run,
            % формирование параметров выполнения
            DateCalcFrom = DateBegin,
            date_add(DateEnd, 1, day, DateCalcTo),
            atom_date(DateBegin, date(Y, M, _)),
            atom_date(DateNormFrom, date(Y, M, 1)),
            date_add(DateEnd, 1, month, DateEnd1),
            atom_date(DateEnd1, date(Y1, M1, _)),
            atom_date(DateNormTo, date(Y1, M1, 1)),
            ParamPairs = [
                          pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                          pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo,
                          pDateNormFrom-DateNormFrom, pDateNormTo-DateNormTo
                         ],
            ( get_param_list(Scope, Type, [pCommon-1], CommonPairs) -> true
            ; CommonPairs = []
            ),
            ( get_param_list(Scope, Type, [pBudgetPart-_], InPairs) -> true
            ; InPairs = []
            ),
            append([ParamPairs, CommonPairs, InPairs], Pairs),
            new_param_list(Scope, NextType, Pairs),
            % формирование SQL-запроса
            get_sql(Scope, kb, Query, SQL0, Params),
            is_valid_sql(Query),
            Query = PredicateName/Arity,
            member_list(Params, Pairs),
            prepare_sql(SQL0, Params, SQL),
            % добавление SQL-запроса к параметрам выполнения
            SQLPairs = [
                        pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                        pQuery-Query, pSQL-SQL
                       ],
            new_param_list(Scope, NextType, SQLPairs),
            true.
        
        %
        struct_sick_err(ErrMessage) :-
            Scope = wg_struct_sick, Type = error,
            get_param(Scope, Type, pError-ErrMessage),
            true.
        
        %
        struct_sick_in(
            DateCalc, DateBegin, DateEnd, AvgWage, CalcType0,
            BudgetOption, ByRateOption, IsPregnancy, IllType,
            ViolatDB, ViolatDE
        ) :-
            Scope = wg_struct_sick, Type = in, NextType = run,
            % шаблон первичного ключа
            PK = [pEmplKey-_, pFirstMoveKey-_],
            % по сотруднику из параметров выполнения
            get_param_list(Scope, NextType, PK),
            % формирование временных данных по графику работы
            make_schedule(Scope, PK),
            % формирование временных данных параметров расчета
            Pairs0 = [
                      pDateCalc-DateCalc,
                      pBudgetOption-BudgetOption, pByRateOption-ByRateOption,
                      pIsPregnancy-IsPregnancy, pIllType-IllType,
                      pViolatDB-ViolatDB, pViolatDE-ViolatDE
                     ],
            append(PK, Pairs0, Pairs),
            new_param_list(Scope, temp, Pairs),
            % дата начисления
            atom_date(DateCalc, date(Year, Month, _)),
            month_days(Year, Month, Days),
            atom_date(AccDate, date(Year, Month, Days)),
            % количество дней
            date_diff(DateBegin, Duration0, DateEnd),
            Duration is Duration0 + 1,
            % тип расчета
            ( BudgetOption = 1
             -> get_param(Scope, Type, pBugetCalcType-CalcType)
            ; CalcType = CalcType0
            ),
            % формирование списка отрезков
            sick_slice_list(Scope, Type, CalcType, Duration, SliceList0),
            % переходящие дни
            date_diff(DateCalc, DurationBefore, DateBegin),
            % исключение из списка отрезков
            sick_slice_list_excl(SliceList0, SliceList, DurationBefore),
            % расчет структуры
            struct_sick_calc(SliceList, _-0, AccDate, DateBegin, DateEnd, AvgWage, Scope, PK),
            !.
        
        % формирование списка отрезков
        sick_slice_list(Scope, Type, CalcType, Duration, SliceList) :-
            Params = [
                      pFirstCalcType-FirstCalcType,
                      pFirstDuration-FirstDuration,
                      pFirstPart-FirstPart
                     ],
            get_param_list(Scope, Type, Params),
            sick_slice_list(Scope, Type, [1.0-Duration], CalcType, FirstCalcType, FirstPart-FirstDuration, SliceList),
            !.
        %
        sick_slice_list(_, _, SliceList0, CalcType, CalcType, FirstSlice, [FirstSlice|SliceList0]) :-
            !.
        sick_slice_list(Scope, Type, [_-Duration], CalcType, _, FirstPart-FirstDuration, SliceList) :-
            Params = [
                      pCutCalcType-CalcType,
                      pCutDuration-CutDuration,
                      pCutPart-CutPart
                     ],
            get_param_list(Scope, Type, Params),
            Part2 is FirstPart * CutPart,
            Duration2 is FirstDuration - CutDuration,
            append([[0.0-CutDuration], [Part2-Duration2], [CutPart-Duration]], SliceList),
            !.
        sick_slice_list(_, _, SliceList, _, _, _, SliceList) :-
            !.
        
        % исключение из списка отрезков
        sick_slice_list_excl(SliceList, SliceList, 0) :-
            !.
        sick_slice_list_excl([LastSlice|[]], [LastSlice], _) :-
            !.
        sick_slice_list_excl([Slice|SliceList], [Slice1|SliceList1], DurationBefore) :-
            sick_slice_excl(Slice, Slice1, DurationBefore, DurationBefore1),
            !,
            sick_slice_list_excl(SliceList, SliceList1, DurationBefore1).
        
        % исключение отрезка
        sick_slice_excl(Part-Duration, Part-Duration1, DurationBefore, DurationBefore1) :-
            Duration0 is Duration - DurationBefore,
            ( Duration0 > 0
             -> Duration1 = Duration0
            ; Duration1 = 0
            ),
            DurationBefore0 is DurationBefore - Duration,
            ( DurationBefore0 > 0
             -> DurationBefore1 = DurationBefore0
            ; DurationBefore1 = 0
            ),
            !.
        
        % расчет структуры
        struct_sick_calc([Slice|SliceList], _-Slice0, AccDate, DateBegin, DateEnd, AvgWage, Scope, PK) :-
            Slice0 =:= 0,
            !,
            struct_sick_calc(SliceList, Slice, AccDate, DateBegin, DateEnd, AvgWage, Scope, PK).
        struct_sick_calc(_, _, _, '', '', _, _, _) :-
            !.
        struct_sick_calc([], _-Slice, _, _, _, _, _, _) :-
            Slice =:= 0,
            !.
        struct_sick_calc(SliceList, SickPart0-Slice, AccDate, DateBegin, DateEnd, AvgWage0, Scope, PK) :-
            % сформировать период
            make_period(
                DateBegin, DateEnd,
                DateBegin1, DateEnd1,
                DateBegin2, DateEnd2,
                Slice, Slice2,
                Scope, PK, SickPart1
            ),
            % дата начисления
            atom_date(DateBegin1, date(Y, M, _)),
            atom_date(IncludeDate, date(Y, M, 1)),
            % взять временные данные параметров расчета
            Pairs0 = [
                      pBudgetOption-BudgetOption, pByRateOption-ByRateOption,
                      pIsPregnancy-IsPregnancy, pIllType-IllType
                     ],
            append(PK, Pairs0, Pairs),
            get_param_list(Scope, temp, Pairs),
            % расчет части периода с учетом нарушения режима
            SickPart is SickPart0 * 1.0 * SickPart1,
            Percent is SickPart * 100,
            date_add(DateEnd1, 1, day, DateEnd11),
            % сумма дней и часов периода
            sum_sick_days(DateBegin1, DateEnd11, 0, DOI, 0, HOI, IllType, Scope, PK, 0),
              % если расчет от БПМ
            ( BudgetOption = 1,
              get_avg_wage_budget(Scope, in, Y-M, AvgWage),
              Summa is round(DOI * AvgWage * SickPart)
            ; % или расчет от Ставки при отсутствии заработка
              ByRateOption = 1,
              AvgWage0 =:= 0,
              get_avg_wage_rate(Scope, PK, IncludeDate, AvgWage),
              Summa is round(DOI * AvgWage * SickPart)
              % или есть признак Декретный
            ; IsPregnancy = 1,
              Summa is round(DOI * AvgWage0 * SickPart)
              % иначе проверка на превышение по среднему заработку в РБ
            ; Summa0 is round(DOI * AvgWage0 * SickPart),
              % для среднедневной зп для месяца по среднемесячной зп в РБ
              avg_wage_by_avg_salary(Scope, Y-M, AvgWage1),
              % процент не учитывается
              Summa1 is round(DOI * AvgWage1),
              % берется минимальная сумма
              Summa is min(Summa0, Summa1)
            ),
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pPercent-Percent, pDOI-DOI, pHOI-HOI, pSumma-Summa,
                        pDateBegin-DateBegin1, pDateEnd-DateEnd1
                        ],
            new_param_list(Scope, out, OutPairs),
            !,
            struct_sick_calc(SliceList, SickPart0-Slice2, AccDate, DateBegin2, DateEnd2, AvgWage0, Scope, PK).
        
        %
        make_period(
            DateBegin, DateEnd,
            DateBegin1, DateEnd1,
            DateBegin2, DateEnd2,
            Slice, Slice2
        ) :-
            make_period(
                DateBegin, DateEnd,
                DateBegin1, DateEnd1,
                DateBegin2, DateEnd2,
                Slice, Slice2,
                '', [], _
            ),
            !.
        %
        make_period(
            DateBegin, DateEnd,
            DateBegin, DateEnd1,
            DateBegin2, DateEnd2,
            Slice, Slice2,
            Scope, PK, SickPart1
        ) :-
            head_period(DateBegin, DateEnd, DateEnd1, Slice, Slice2, Scope, PK, SickPart1),
            teil_period(DateEnd, DateEnd1, DateBegin2, DateEnd2),
            !.
        
        %
        head_period(DateBegin, DateEnd, DateBegin, Slice, Slice2, Scope, PK, SickPart1) :-
           % следующий день
           date_add(DateBegin, 1, day, DateBegin1),
           atom_date(DateBegin, date(Y, M, _)),
             % является днем следующего месяца
           ( \+ atom_date(DateBegin1, date(Y, M, _)),
             next_slice(DateBegin, Slice, Slice2)
             % больше даты окончания
           ; DateBegin1 @> DateEnd,
             Slice2 = 0
             % достигнут конец отрезка
           ; Slice =:= 1,
             next_slice(DateBegin, Slice, Slice2)
             % является днем начала нарушения режима
           ; violat_date(begin, DateBegin1, Scope, PK, _),
             next_slice(DateBegin, Slice, Slice2)
             % или текущий день является днем окончания нарушения режима
           ; violat_date(end, DateBegin, Scope, PK, _),
             next_slice(DateBegin, Slice, Slice2)
           ),
           % проверка на вхождение в период нарушения режима
           violat_date(period, DateBegin, Scope, PK, SickPart1),
           !.
        head_period(DateBegin, DateEnd, DateEnd1, Slice0, Slice2, Scope, PK, SickPart1) :-
           date_add(DateBegin, 1, day, DateBegin1),
           next_slice(DateBegin, Slice0, Slice1),
           !,
           head_period(DateBegin1, DateEnd, DateEnd1, Slice1, Slice2, Scope, PK, SickPart1).
        
        %
        violat_date(period, _, '', [], 1.0) :-
            !.
        violat_date(CheckType, InDate, Scope, PK, ViolatPart) :-
            get_param(Scope, in, pViolatPart-ViolatPart),
            get_param_list(Scope, temp, [pViolatDB-ViolatDB, pViolatDE-ViolatDE | PK]),
            is_date(ViolatDB), ViolatDB @> '1994-01-01',
            is_date(ViolatDE), ViolatDE @> '1994-01-01',
            ( CheckType = begin,
              InDate =@= ViolatDB
            ; CheckType = end,
              InDate =@= ViolatDE
            ; CheckType = period,
              InDate @>= ViolatDB,
              InDate @=< ViolatDE
            ),
            !.
        violat_date(period, _, _, _, 1.0) :-
            !.
        
        %
        next_slice(DateBegin, Slice, Slice) :-
           catch( wg_holiday(DateBegin), _, fail ),
           !.
        next_slice(_, Slice, Slice2) :-
           Slice2 is Slice - 1,
           !.
        
        %
        teil_period(DateEnd, DateEnd, '', '') :-
            !.
        teil_period(DateEnd, DateEnd1, DateBegin2, DateEnd) :-
            date_add(DateEnd1, 1, day, DateBegin2),
            !.
        
        % сумма дней и часов периода
        sum_sick_days(DateBegin, DateBegin, DOI, DOI, HOI, HOI, _, _, _, _) :-
            !.
        sum_sick_days(DateBegin, DateEnd, DOI0, DOI, HOI0, HOI, IllType, Scope, PK, Holiday) :-
            % добавить дней и часов по графику
            add_sick_norm(DateBegin, DOI0, HOI0, DOI1, HOI1, IllType, Scope, PK, Holiday, Holiday1),
            % следующий день
            date_add(DateBegin, 1, day, DateBegin1),
            !,
            sum_sick_days(DateBegin1, DateEnd, DOI1, DOI, HOI1, HOI, IllType, Scope, PK, Holiday1).
        
        % добавить дней и часов по графику
        add_sick_norm(TheDay, DOI, HOI, DOI, HOI, IllType, Scope, PK, Holiday, 1) :-
            % По уходу за ребенком до 3-х лет
            catch( wg_child_ill_type(IllType), _, fail),
            \+ once( ( member(NormOption, [tbl_cal_flex, tbl_day_norm]),
              usr_wg_TblDayNorm_mix(Scope, PK, _, TheDay, WDuration, 1, NormOption),
                       WDuration > 0
                     )
                   ),
            get_param_list(Scope, temp, [pDateCalc-DateCalc | PK]),
            ( TheDay =@= DateCalc ; Holiday =@= 1 ),
            !.
        add_sick_norm(TheDay, DOI0, HOI0, DOI1, HOI1, IllType, Scope, PK, _, 0) :-
            ( member(NormOption, [tbl_cal_flex, tbl_day_norm]),
              usr_wg_TblDayNorm_mix(Scope, PK, _, TheDay, WDuration, 1, NormOption),
              WDuration > 0,
              DOI1 is DOI0 + 1,
              HOI1 is HOI0 + WDuration
            ;   % Травма производственная
              ( catch( wg_job_ill_type(IllType), _, fail),
                DOI1 = DOI0
              ; DOI1 is DOI0 + 1
              ),
              HOI1 = HOI0
            ),
            !.
        
        %
        struct_vacation_out(AccDate, IncludeDate, Duration, Summa, DateBegin, DateEnd, VcType) :-
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pDuration-Duration, pSumma-Summa,
                        pDateBegin-DateBegin, pDateEnd-DateEnd,
                        pVcType-VcType
                       ],
            get_param_list(struct_vacation, out, OutPairs).
        
        %
        struct_sick_out(AccDate, IncludeDate, Percent, DOI, HOI, Summa, DateBegin, DateEnd) :-
            Scope = wg_struct_sick,
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pPercent-Percent, pDOI-DOI, pHOI-HOI, pSumma-Summa,
                        pDateBegin-DateBegin, pDateEnd-DateEnd
                       ],
            get_param_list(Scope, out, OutPairs).
        
        % взять среднедневную ставку на текущий месяц
        get_avg_wage_rate(Scope, PK, TheDate, AvgWage) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % текущий месяц
            atom_date(TheDate, date(Y, M, _)),
            % календарных дней в текущем месяце
            month_days(Y, M, MonthDays),
            atom_date(LastDate, date(Y, M, MonthDays)),
            % взять данные по ставке
            findall( PayFormKey0-SalaryKey0-TSalary0-THoureRate0,
                       % из данных по движению
                     ( get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                 fDateBegin-DateBegin,
                                 fPayFormKey-PayFormKey0, fSalaryKey-SalaryKey0,
                                 fTSalary-TSalary0, fTHoureRate-THoureRate0 ]),
                       % где дата меньше или равна последней дате месяца
                       DateBegin @=< LastDate ),
            % в список ставок
            RateList ),
            % взять последние данные по ставке
            last(RateList, PayFormKey-SalaryKey-TSalary-THoureRate),
              % если форма оплаты оклад
            ( PayFormKey = SalaryKey,
              % то расчет по тарифному окладу
              AvgWage is TSalary / MonthDays
            ; % иначе
              % расчитать график за месяц
              calc_month_norm(Scope, PK, Y-M, [tbl_cal_flex, tbl_day_norm], NormDays),
              % сумма дней и часов по графику
              sum_days_houres(NormDays, _, NHoures),
              % расчет от часовой тарифной ставки
              AvgWage is NHoures * THoureRate / MonthDays
            ),
            !.
        
        % взять среднедневной БПМ на текущий месяц
        get_avg_wage_budget(Scope, Type, Y-M, AvgWageBudget) :-
            % первая дата месяца
            atom_date(FirstMonthDate, date(Y, M, 1)),
            % взять БПМ
            findall( Budget0,
                          % взять данные по БПМ
                        ( get_data(Scope, kb, gd_const_budget, [
                                    fConstDate-ConstDate, fBudget-Budget0]),
                          % где дата константы меньше или равна первой дате месяца
                          ConstDate @=< FirstMonthDate
                        ),
            % в список БПМ
            BudgetList),
            % проверить список БПМ
            \+ BudgetList = [],
            % последние данные по БПМ за месяц
            last(BudgetList, MonthBudget),
            % календарных дней в месяце
            month_days(Y, M, MonthDays),
            % коэфициент для расчета по БПМ
            get_param(Scope, Type, pBudgetPart-BudgetPart),
            % среднедневной БПМ
            AvgWageBudget is MonthBudget * BudgetPart / MonthDays,
            !.
        get_avg_wage_budget(Scope, _, _, 0) :-
            new_param_list(Scope, error, [
                            pError-"Введите константу 'Бюджет прожиточного минимума'"]),
            !.
        
        % среднедневная зп для месяца по среднемесячной зп в РБ
        avg_wage_by_avg_salary(Scope, Y-M, MonthAvgWage) :-
            % взять среднюю зп по РБ
            get_avg_salary_rb(Scope, Y-M, MonthAvgSalary),
            % взять расчетный коэфициент
            get_param(Scope, in, pAvgSalaryRB_Coef-AvgSalaryRB_Coef),
            % календарных дней в месяце
            month_days(Y, M, MonthDays),
            % расчитать среднедневную зп для месяца
            MonthAvgWage is round(MonthAvgSalary * AvgSalaryRB_Coef / MonthDays),
            !.
        
        % section twg_rule
        % Правила расчета
        %
        
        % настроить правила
        wg_config_rules(Scope) :-
            memberchk(Scope, [wg_avg_wage_vacation, wg_avg_wage_sick]),
            findall( Rules, wg_valid_rules(Rules), RulesList),
            append(RulesList, RulesSet),
            wg_change_rules(Scope, RulesSet, RulesSet1),
            retractall( wg_valid_rules(_) ),
            assertz( wg_valid_rules(RulesSet1) ),
            !.
        wg_config_rules(_).
        
        wg_change_rules(_, [], []) :-
            !.
        wg_change_rules(Scope, [Rule0|Rules], [Rule1|Rules1]) :-
            ( Rule0 = -Rule -> true ; Rule0 = Rule ),
            atom_string(Rule, Atom),
            get_data(Scope, kb, usr_wg_pl_Rule, [fAtom-Atom, fEnabled-Enabled]),
            ( Enabled = 0, Rule1 = -Rule ; Rule1 = Rule ),
            !,
            wg_change_rules(Scope, Rules, Rules1).
        wg_change_rules(Scope, [Rule|Rules], [Rule|Rules1]) :-
            !,
            wg_change_rules(Scope, Rules, Rules1).
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-03-11T10:27:39+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "151042959_187967073 wg_data_mix"
          - 
            ADDFUNCTIONKEY: "151189470_18175251 twg_avg_wage_sql"
          - 
            ADDFUNCTIONKEY: "151189471_18175251 twg_avg_wage_in_params"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362817_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee_sql"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee_sql
        %  спецификации и sql-шаблоны для базы знаний twg_fee
        %
        
        :-  style_check(-atom),
            GetSQL = [gd_pl_ds/5, get_sql/5],
            %dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql(
                    [
                    usr_wg_MovementLine/15,
                    gd_contact/2,
                    usr_wg_TblCharge/14,
                    usr_wg_TblCharge_Prev/12,
                    usr_wg_TblCharge_AlimonyDebt/9,
                    usr_wg_FeeType/4,
                    usr_wg_FeeType_Taxable/3,
                    usr_wg_FeeType_Dict/6,
                    usr_wg_TblCalLine/7,
                    usr_wg_TblCal_FlexLine/68,
                    usr_wg_FCRate/2,
                    gd_const_budget/2,
                    usr_wg_Variables/2,
                    usr_wg_Alimony/12,
                    usr_wg_TransferType/4,
                    usr_wg_TransferScale/3,
                    usr_wg_AlimonyDebt/8,
                    usr_wg_Alimony_FeeDoc/2,
                    usr_wg_AlimonyDebt_delete/0,
                    -
                    ]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            memberchk(Functor/Arity, ValidSQL),
            !.
        
        /* база знаний */
        
        gd_pl_ds(Scope, kb, usr_wg_MovementLine, 15, [
            fEmplKey-integer, fDocumentKey-integer, fFirstMoveKey-integer,
            fMoveYear-integer, fMoveMonth-integer, fDateBegin-date,
            fScheduleKey-integer, fMovementType-integer,
            fRate-float, fListNumber-string, fMSalary-float,
            fPayFormKey-integer, fSalaryKey-integer, fTSalary-float, fAvgWageRate-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_MovementLine(EmplKey, DocumentKey, FirstMoveKey,
        %   MoveYear, MoveMonth, DateBegin,
        %   ScheduleKey, MovementType, Rate, ListNumber, MSalary,
        %   PayFormKey, SalaryKey, TSalary, AvgWageRate)
        get_sql(Scope, kb, usr_wg_MovementLine/15,
        "
        SELECT
          ml.USR$EMPLKEY,
          ml.DOCUMENTKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          EXTRACT(YEAR FROM ml.USR$DATEBEGIN) AS MoveYear,
          EXTRACT(MONTH FROM ml.USR$DATEBEGIN) AS MoveMonth,
          ml.USR$DATEBEGIN,
          ml.USR$SCHEDULEKEY,
          ml.USR$MOVEMENTTYPE,
          COALESCE(ml.USR$RATE, 0) AS Rate,
          ml.USR$LISTNUMBER,
          COALESCE(ml.USR$MSALARY, 0) AS MSalary,
          COALESCE(ml.USR$PAYFORMKEY, 0) AS PayFormKey,
          (SELECT id FROM GD_P_GETID(pPayFormSalary_ruid)) AS SalaryKey,
          COALESCE(ml.USR$TSALARY, 0) AS TSalary,
          8 * COALESCE(USR$THOURRATE, 0) AS AvgWageRate
        FROM
          USR$WG_MOVEMENTLINE ml
        JOIN
          USR$WG_KINDOFWORK kw
            ON kw.ID = ml.USR$KINDOFWORKKEY
        WHERE
          ml.USR$EMPLKEY = pEmplKey
          AND
          ml.USR$KINDOFWORKKEY =
            (SELECT id FROM GD_P_GETID(pKindOfWork_Basic_ruid))
        ORDER BY
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE,
          ml.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pPayFormSalary_ruid-_, pKindOfWork_Basic_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, gd_contact, 2, [
            fID-integer, fName-string
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % gd_contact(ID, Name)
        get_sql(Scope, kb, gd_contact/2,
        "
        SELECT
          c.ID, c.NAME
        FROM
          GD_CONTACT c
        WHERE
          c.ID = pEmplKey
        UNION ALL
        SELECT
          c.ID, c.NAME
        FROM
          GD_CONTACT c
        JOIN
          USR$WG_ALIMONY al
            ON al.USR$RECIPIENT = c.ID
        WHERE
          al.USR$EMPLKEY = pEmplKey
        ",
            [
            pEmplKey-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge, 14, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fDOW-float, fHOW-float,
            fTotalYear-integer, fTotalMonth-integer, fTotalDateBegin-date
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TblCharge(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, DOW, HOW, TotalYear, TotalMonth, TotalDateBegin)
        get_sql(Scope, kb, usr_wg_TblCharge/14,
        "
        SELECT
          tch.USR$DOCUMENTKEY,
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY,
          tch.USR$DOW,
          tch.USR$HOW,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS TotalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS TotalMonth,
          t.USR$DATEBEGIN AS TotalDateBegin
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tch.USR$TOTALDOCKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          tch.USR$TOTALDOCKEY = pTotalDocKey
        ",
            [
            pEmplKey-_, pTotalDocKey-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge_Prev, 12, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fTotalYear-integer, fTotalMonth-integer, fTotalDateBegin-date
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TblCharge_Prev(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, TotalYear, TotalMonth, TotalDateBegin)
        get_sql(Scope, kb, usr_wg_TblCharge_Prev/12,
        "
        SELECT
          tch.USR$DOCUMENTKEY,
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS TotalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS TotalMonth,
          t.USR$DATEBEGIN AS TotalDateBegin
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tch.USR$TOTALDOCKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          t.USR$DATEBEGIN >= 'pDatePrevCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDatePrevCalcTo'
        ",
            [
            pEmplKey-_,
            pDatePrevCalcFrom-_, pDatePrevCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge_AlimonyDebt, 9, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TblCharge_AlimonyDebt(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_TblCharge_AlimonyDebt/9,
        "
        SELECT
          tch.USR$DOCUMENTKEY,
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY
        FROM
          USR$WG_TBLCHARGE tch
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          tch.USR$DATEBEGIN < 'pDateCalcFrom'
          AND
          tch.USR$FEETYPEKEY =
            (SELECT id FROM GD_P_GETID(pFeeType_AlimonyDebt_ruid))
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pFeeType_AlimonyDebt_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType, 4, [
            fEmplKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer, fAvgDayHOW-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_FeeType(EmplKey, FeeGroupKey, FeeTypeKey, AvgDayHOW)
        get_sql(Scope, kb, usr_wg_FeeType/4,
        "
        SELECT
          pEmplKey AS EmplKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY,
          ft_avg.USR$AVGDAYHOW
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY =
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_ruid))
        ",
            [
            pEmplKey-_, pFeeGroupKey_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Taxable, 3, [
            fEmplKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_FeeType_Taxable(EmplKey, FeeGroupKey, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_FeeType_Taxable/3,
        "
        SELECT
          pEmplKey AS EmplKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY =
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_IncomeTax_ruid))
        ",
            [
            pEmplKey-_, pFeeGroupKey_IncomeTax_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Dict, 6, [
            fID-integer, fAlias-string, fName-string,
            fRoundByFeeType-integer, fRoundType-integer, fRoundValue-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_FeeType_Dict(ID, Alias, Name, RoundByFeeType, RoundType, RoundValue)
        get_sql(Scope, kb, usr_wg_FeeType_Dict/6,
        "
        SELECT
          ft.ID,
          CASE ft.ID
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_Alimony_ruid))
                THEN 'ftAlimony'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_Fine_ruid))
                THEN 'ftFine'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_HolidayComp_ruid))
                THEN 'ftHolidayComp'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_IncomeTax_ruid))
                THEN 'ftIncomeTax'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_TransferDed_ruid))
                THEN 'ftTransferDed'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_AlimonyDebt_ruid))
                THEN 'ftAlimonyDebt'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_FineDebt_ruid))
                THEN 'ftFineDebt'
            ELSE
                'unknown'
          END
            AS Alias,
          USR$NAME,
          USR$ROUNDBYFEETYPE,
          USR$ROUNDTYPE,
          USR$ROUNDVALUE
        FROM
          USR$WG_FEETYPE ft
        ",
            [
            pFeeType_Alimony_ruid-_,
            pFeeType_Fine_ruid-_,
            pFeeType_HolidayComp_ruid-_,
            pFeeType_IncomeTax_ruid-_,
            pFeeType_TransferDed_ruid-_,
            pFeeType_AlimonyDebt_ruid-_,
            pFeeType_FineDebt_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCalLine, 7, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDate-date,
            fDuration-float, fHoureType-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TblCalLine(EmplKey, FirstMoveKey, CalYear, CalMonth, Date, Duration, HoureType)
        get_sql(Scope, kb, usr_wg_TblCalLine/7,
        "
        SELECT
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tcl.USR$DATE) AS CalYear,
          EXTRACT(MONTH FROM tcl.USR$DATE) AS CalMonth,
          tcl.USR$DATE,
          tcl.USR$DURATION,
          tcl.USR$HOURTYPE
        FROM
          USR$WG_TBLCAL tc
        JOIN
          USR$WG_TBLCALLINE tcl
            ON tcl.MASTERKEY = tc.DOCUMENTKEY
        WHERE
          tc.USR$EMPLKEY = pEmplKey
          AND
          tcl.USR$DATE >= 'pDateCalcFrom'
          AND
          tcl.USR$DATE < 'pDateCalcTo'
        ORDER BY
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          tcl.USR$DATE
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, [
            fFlexType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fS1-variant, fH1-variant, fS2-variant, fH2-variant,
            fS3-variant, fH3-variant, fS4-variant, fH4-variant,
            fS5-variant, fH5-variant, fS6-variant, fH6-variant,
            fS7-variant, fH7-variant, fS8-variant, fH8-variant,
            fS9-variant, fH9-variant, fS10-variant, fH10-variant,
            fS11-variant, fH11-variant, fS12-variant, fH12-variant,
            fS13-variant, fH13-variant, fS14-variant, fH14-variant,
            fS15-variant, fH15-variant, fS16-variant, fH16-variant,
            fS17-variant, fH17-variant, fS18-variant, fH18-variant,
            fS19-variant, fH19-variant, fS20-variant, fH20-variant,
            fS21-variant, fH21-variant, fS22-variant, fH22-variant,
            fS23-variant, fH23-variant, fS24-variant, fH24-variant,
            fS25-variant, fH25-variant, fS26-variant, fH26-variant,
            fS27-variant, fH27-variant, fS28-variant, fH28-variant,
            fS29-variant, fH29-variant, fS30-variant, fH30-variant,
            fS31-variant, fH31-variant
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TblCal_FlexLine(FlexType, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, S1, H1, ..., S31, H31)
        get_sql(Scope, kb, usr_wg_TblCal_FlexLine/68,
        "
        SELECT
          CASE gd.DOCUMENTTYPEKEY
            WHEN
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Plan_ruid))
                THEN 'plan'
            WHEN
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Fact_ruid))
                THEN 'fact'
            ELSE
                'unknown'
          END
            AS FlexType,
          tcfl.USR$EMPLKEY,
          tcfl.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth,
          t.USR$DATEBEGIN,
          tcfl.USR$S1, tcfl.USR$H1, tcfl.USR$S2, tcfl.USR$H2,
          tcfl.USR$S3, tcfl.USR$H3, tcfl.USR$S4, tcfl.USR$H4,
          tcfl.USR$S5, tcfl.USR$H5, tcfl.USR$S6, tcfl.USR$H6,
          tcfl.USR$S7, tcfl.USR$H7, tcfl.USR$S8, tcfl.USR$H8,
          tcfl.USR$S9, tcfl.USR$H9, tcfl.USR$S10, tcfl.USR$H10,
          tcfl.USR$S11, tcfl.USR$H11, tcfl.USR$S12, tcfl.USR$H12,
          tcfl.USR$S13, tcfl.USR$H13, tcfl.USR$S14, tcfl.USR$H14,
          tcfl.USR$S15, tcfl.USR$H15, tcfl.USR$S16, tcfl.USR$H16,
          tcfl.USR$S17, tcfl.USR$H17, tcfl.USR$S18, tcfl.USR$H18,
          tcfl.USR$S19, tcfl.USR$H19, tcfl.USR$S20, tcfl.USR$H20,
          tcfl.USR$S21, tcfl.USR$H21, tcfl.USR$S22, tcfl.USR$H22,
          tcfl.USR$S23, tcfl.USR$H23, tcfl.USR$S24, tcfl.USR$H24,
          tcfl.USR$S25, tcfl.USR$H25, tcfl.USR$S26, tcfl.USR$H26,
          tcfl.USR$S27, tcfl.USR$H27, tcfl.USR$S28, tcfl.USR$H28,
          tcfl.USR$S29, tcfl.USR$H29, tcfl.USR$S30, tcfl.USR$H30,
          tcfl.USR$S31, tcfl.USR$H31
        FROM
          GD_DOCUMENT gd
        JOIN
          USR$WG_TBLCAL_FLEXLINE tcfl
            ON gd.ID = tcfl.DOCUMENTKEY
        JOIN
          USR$WG_TBLCAL_FLEX tcf
            ON tcf.DOCUMENTKEY = tcfl.MASTERKEY
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tcf.USR$TOTALDOCKEY
        WHERE
          tcfl.USR$EMPLKEY = pEmplKey
          AND
          t.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDateCalcTo'
         ORDER BY
           tcfl.USR$EMPLKEY,
           tcfl.USR$FIRSTMOVEKEY,
           t.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pTblCal_DocType_Plan_ruid-_, pTblCal_DocType_Fact_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FCRate, 2, [
            fDate-date, fMinWage-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_FCRate(Date, MinWage)
        get_sql(Scope, kb, usr_wg_FCRate/2,
        "
        SELECT
          fc.USR$WG_DATE,
          fc.USR$WG_MINWAGE
        FROM
          USR$WG_FCRATE fc
        WHERE
          fc.USR$WG_DATE >= 'pStartDate'
        ORDER BY
          fc.USR$WG_DATE
        ",
            [
            pStartDate-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, gd_const_budget, 2, [
            fConstDate-date, fBudget-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % gd_const_budget(ConstDate, Budget)
        get_sql(Scope, kb, gd_const_budget/2,
        "
        SELECT
          cv.CONSTDATE,
          CAST(cv.CONSTVALUE AS DECIMAL(15,4)) AS Budget
        FROM
          GD_CONSTVALUE cv
        JOIN
          GD_CONST c
            ON c.ID  =  cv.CONSTKEY
        WHERE
          cv.CONSTDATE >= 'pStartDate'
          AND
          cv.CONSTKEY =
            (SELECT id FROM GD_P_GETID(pBudget_ruid))
        ORDER BY
          cv.CONSTDATE
        ",
            [
            pStartDate-_, pBudget_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_Variables, 2, [
            fAlias-string, fName-string
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_Varuables(Alias, Name)
        get_sql(Scope, kb, usr_wg_Variables/2,
        "
        SELECT
          'vBV' AS Alias,
          USR$NAME
        FROM
          USR$WG_VARIABLES
        WHERE
          ID = (SELECT id FROM GD_P_GETID(pVar_BV_ruid))
        UNION ALL
        SELECT
          'vForAlimony' AS Alias,
          USR$NAME
        FROM
          USR$WG_VARIABLES
        WHERE
          ID = (SELECT id FROM GD_P_GETID(pVar_ForAlimony_ruid))
        UNION ALL
        SELECT
          'vForFine' AS Alias,
          USR$NAME
        FROM
          USR$WG_VARIABLES
        WHERE
          ID = (SELECT id FROM GD_P_GETID(pVar_ForFine_ruid))
        ",
            [
            pVar_BV_ruid-_, pVar_ForAlimony_ruid-_, pVar_ForFine_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_Alimony, 12, [
            fDocKey-integer, fEmplKey-integer,
            fDateBegin-date, fDateEnd-date,
            fDebtSum-float, fFormula-string,
            fTransferTypeKey-integer, fRecipient-integer,
            fRestPercent-float, fChildCount-integer,
            fPercent-float, fLivingWagePerc-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_Alimony(DocKey, EmplKey, DateBegin, DateEnd, DebtSum, Formula, TransferTypeKey, Recipient, RestPercent, ChildCount, Percent, LivingWagePerc)
        get_sql(Scope, kb, usr_wg_Alimony/12,
        "
        SELECT
          calc.DOCUMENTKEY,
          calc.USR$EMPLKEY,
          calc.USR$DATEBEGIN,
          COALESCE(calc.USR$DATEEND, CAST('pNullDate' AS DATE)) AS DateEnd,
          calc.USR$DEBTSUM,
          calc.USR$FORMULA,
          calc.USR$TRANSFERTYPEKEY,
          calc.USR$RECIPIENT,
          calc.USR$RESTPERCENT,
          calc.USR$CHILDCOUNT,
          calc.USR$PERCENT,
          calc.USR$LIVINGWAGEPERC
        FROM
          USR$WG_ALIMONY calc
        JOIN
          GD_DOCUMENT d
            ON calc.DOCUMENTKEY = d.ID
        WHERE
          d.COMPANYKEY = <COMPANYKEY/>
          AND
          d.DOCUMENTTYPEKEY = (SELECT id FROM GD_P_GETID(pDocType_ruid))
          AND
          calc.USR$EMPLKEY = pEmplKey
          AND
          calc.USR$DATEBEGIN < 'pDateCalcTo'
          AND
          COALESCE(calc.USR$DATEEND, 'pNullDate') >= 'pDateCalcFrom'
        ORDER BY
          calc.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_, pDocType_ruid-_,
            pNullDate-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TransferType, 4, [
            fID-integer, fParent-integer,
            fDateBegin-date, fName-string
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TransferType(ID, Parent, DateBegin, Name)
        get_sql(Scope, kb, usr_wg_TransferType/4,
        "
        SELECT
          tt.ID,
          COALESCE(tt.PARENT, 0) AS Parent,
          COALESCE(tt.USR$DATE, current_date) AS DateBegin,
          tt.USR$NAME
        FROM
          USR$WG_TRANSFERTYPE tt
        ORDER BY
          Parent, DateBegin, tt.ID
        ",
            [
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TransferScale, 3, [
            fTranferTypeKey-integer,
            fStartSum-float, fPercent-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_TransferScale(TranferTypeKey, StartSum, Percent)
        get_sql(Scope, kb, usr_wg_TransferScale/3,
        "
        SELECT
          ts.USR$TRANSFERTYPEKEY,
          COALESCE(ts.USR$STARTSUM, 0) AS StartSum,
          COALESCE(ts.USR$PERCENT, 0) AS Percent
        FROM
          USR$WG_TRANSFERSCALE ts
        ORDER BY
          ts.USR$TRANSFERTYPEKEY, StartSum
        ",
            [
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_AlimonyDebt, 8, [
            fDocKey-integer, fEmplKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateDebt-date,
            fAlimonyKey-integer, fTotalDocKey-integer, fDebtSum-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_AlimonyDebt(DocKey, EmplKey, CalYear, CalMonth, DateDebt, AlimonyKey, TotalDocKey, DebtSum)
        get_sql(Scope, kb, usr_wg_AlimonyDebt/8,
        "
        SELECT
          aldebt.DOCUMENTKEY,
          al.USR$EMPLKEY,
          EXTRACT(YEAR FROM aldebt.USR$DATEDEBT) AS CalYear,
          EXTRACT(MONTH FROM aldebt.USR$DATEDEBT) AS CalMonth,
          aldebt.USR$DATEDEBT,
          aldebt.USR$ALIMONYKEY,
          aldebt.USR$TOTALDOCKEY,
          aldebt.USR$DEBTSUM
        FROM
          USR$WG_ALIMONYDEBT aldebt
        JOIN
          USR$WG_ALIMONY al
            ON al.DOCUMENTKEY = aldebt.USR$ALIMONYKEY
        WHERE
          al.USR$EMPLKEY = pEmplKey
          AND
          aldebt.USR$DATEDEBT < 'pDateCalcTo'
          AND
          aldebt.USR$DATEDEBT >=
            (SELECT FIRST 1
               ml.USR$DATEBEGIN
             FROM
               USR$WG_MOVEMENTLINE ml
             WHERE
               ml.USR$EMPLKEY = pEmplKey
               AND
               ml.DOCUMENTKEY = ml.USR$FIRSTMOVE
               AND
               ml.USR$MOVEMENTTYPE = 1
             ORDER BY
               ml.USR$DATEBEGIN DESC
            )
        ORDER BY
          aldebt.USR$DATEDEBT
        ",
            [
            pEmplKey-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        
        gd_pl_ds(Scope, kb, usr_wg_Alimony_FeeDoc, 2, [
            fDocKey-integer, fEmplKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_Alimony(DocKey, EmplKey)
        get_sql(Scope, kb, usr_wg_Alimony_FeeDoc/2,
        "
        SELECT
          calc.DOCUMENTKEY,
          calc.USR$EMPLKEY
        FROM
          USR$WG_ALIMONY calc
        JOIN
          GD_DOCUMENT d
            ON calc.DOCUMENTKEY = d.ID
        WHERE
          d.COMPANYKEY = <COMPANYKEY/>
          AND
          calc.USR$EMPLKEY = pEmplKey
          AND
          calc.USR$DATEBEGIN < 'pDateCalcTo'
          AND
          COALESCE(calc.USR$DATEEND, 'pNullDate') >= 'pDateCalcFrom'
        UNION ALL
        SELECT
          aldebt.DOCUMENTKEY,
          al.USR$EMPLKEY
        FROM
          USR$WG_ALIMONYDEBT aldebt
        JOIN
          USR$WG_ALIMONY al
            ON al.DOCUMENTKEY = aldebt.USR$ALIMONYKEY
        WHERE
          al.USR$EMPLKEY = pEmplKey
          AND
          aldebt.USR$DATEDEBT < 'pDateCalcTo'
          AND
          aldebt.USR$DATEDEBT >=
            (SELECT FIRST 1
               ml.USR$DATEBEGIN
             FROM
               USR$WG_MOVEMENTLINE ml
             WHERE
               ml.USR$EMPLKEY = pEmplKey
               AND
               ml.DOCUMENTKEY = ml.USR$FIRSTMOVE
               AND
               ml.USR$MOVEMENTTYPE = 1
             ORDER BY
               ml.USR$DATEBEGIN DESC
            )
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pNullDate-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        /* удаление данных */
        
        gd_pl_ds(Scope, cmd, usr_wg_AlimonyDebt_delete, 0, [
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        % usr_wg_AlimonyDebt_delete
        get_sql(Scope, cmd, usr_wg_AlimonyDebt_delete/0,
        "
        DELETE
        FROM
          USR$WG_ALIMONYDEBT aldebt
        WHERE
          COALESCE(aldebt.USR$MANUALDEBT, 0) = 0
          AND
          aldebt.USR$DATEDEBT >= 'pDateCalcFrom'
          AND
          aldebt.USR$DATEDEBT < 'pDateCalcTo'
          AND
          aldebt.USR$ALIMONYKEY IN
            (SELECT al.DOCUMENTKEY FROM USR$WG_ALIMONY al WHERE al.USR$EMPLKEY = pEmplKey)
          AND
          aldebt.USR$DATEDEBT >=
            (SELECT FIRST 1
               ml.USR$DATEBEGIN
             FROM
               USR$WG_MOVEMENTLINE ml
             WHERE
               ml.USR$EMPLKEY = pEmplKey
               AND
               ml.DOCUMENTKEY = ml.USR$FIRSTMOVE
               AND
               ml.USR$MOVEMENTTYPE = 1
             ORDER BY
               ml.USR$DATEBEGIN DESC
            )
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]).
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-01-06T15:36:14+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362816_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 195362815_166214404
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee_in_params"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee_in_params
        %  входные параметры для twg_fee
        %
        
        %:- ['../gd_pl_state/date', '../common/lib', '../common/params'].
        
        twg_fee_in_params:-
            Type = in, Section = pCommon,
            member(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать общие входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pStartDate-'2012-01-01', pNullDate-'2100-01-01',
                pKindOfWork_Basic_ruid-'147017405,119619099',       % Основное место работы
                pPayFormSalary_ruid-'147009181,119619099',          % Форма оплаты Оклад
                pFeeGroupKey_IncomeTax_ruid-'147021000,274788016',  % Облагается ПН
                pDocType_Total_ruid-'147567052,119619099',          % 99. Итоговое начисление
                pTblCal_DocType_Plan_ruid-'147567935,1514418708',   % Календарный график
                pTblCal_DocType_Fact_ruid-'187613422,1596169984',   % Табель мастера
                pBudget_ruid-'147073065,1224850260'                 % БПМ
                ]),
            fail.
        twg_fee_in_params:-
            Type = in, Section = pAlimony,
            member(Scope, [
                wg_fee_alimony, wg_fee_fine
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pVar_BV_ruid-'147021364,256548741',           % БВ
                pVar_ForAlimony_ruid-'147068435,453357870',   % ДЛЯАЛИМЕНТОВ
                pVar_ForFine_ruid-'147049304,1011422021',     % ДЛЯШТРАФОВ
                pFeeType_Alimony_ruid-'147567138,119619099',       % Алименты
                pFeeType_Fine_ruid-'147049310,1011422021',         % Штрафы
                pFeeType_HolidayComp_ruid-'147076028,274788016',   % Компенсация отпуска
                pFeeType_IncomeTax_ruid-'147567139,119619099',     % Подоходный
                pFeeType_TransferDed_ruid-'147069035,453357870',   % Расходы по переводу
                pFeeType_AlimonyDebt_ruid-'147067786,453357870',   % Долг по алиментам
                pFeeType_FineDebt_ruid-'147049310,1011422021'      % Долг по штрафам (Штрафы)
                ]),
            fail.
        twg_fee_in_params:-
            Type = in, Section = pAlimony,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pFeeGroupKey_ruid-'147732349,375143752',   % Для алиментов
                pDocType_ruid-'147067079,453357870'        % 04. Алименты
                ]),
            fail.
        twg_fee_in_params:-
            Type = in, Section = pAlimony,
            member(Scope, [
                wg_fee_fine
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pFeeGroupKey_ruid-'147049301,1011422021',  % Для штрафов
                pDocType_ruid-'147050774,1011422021'       % 11. Штрафы
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 1,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pRestPercent-0.3,  % Процент остатка
                pPercent-0.2,      % Процент списания долга
                pCalcDelta-100     % Дельта для расчета при нехватке средств
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 1,
            member(Scope, [
                wg_fee_fine
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pRestPercent-0.5,  % Процент остатка
                pPercent-0.2,      % Процент списания долга
                pCalcDelta-100     % Дельта для расчета при нехватке средств
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 2,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % Процент от БПМ (не менее) от количества детей
            member([ChildQtyCmp, LivingWagePerc],
                [ ['=:=0', 0.0], ['=1', 0.5], ['=2', 0.75], ['>=3', 1.0] ]),
            % записать входные параметры
            new_param_list(Scope, Type,
                [pChildQtyCmp-ChildQtyCmp, pLivingWagePerc-LivingWagePerc]),
            fail.
        twg_fee_in_params.
        
        :- twg_fee_in_params.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-01-06T15:36:29+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362815_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee
        % Зарплата и Отдел кадров -> Зарплата -> 02. Прочие доходы, расходы, льготы
        %    04. Алименты
        %    11. Штрафы
        %
        
        :- style_check([-atom]).
        
        :- dynamic(debug_mode/0).
        % ! при использовании в ТП Гедымин
        % ! комментировать следующую строку
        %:- assertz(debug_mode).
        
        %%% begin debug mode section
        :- if(debug_mode).
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        %#INCLUDE params
        %#INCLUDE wg_data_mix
        :- ['../common/lib', '../common/params', '../common/wg_data_mix'].
        %#INCLUDE twg_fee_sql
        :- [twg_fee_sql].
        %#INCLUDE twg_fee_in_params
        %:- [twg_fee_in_params].
        %%
        
        %% facts
        :-  init_data,
            working_directory(_, 'kb'),
            [
            usr_wg_MovementLine,
            gd_contact,
            usr_wg_TblCharge,
            usr_wg_TblCharge_Prev,
            usr_wg_TblCharge_AlimonyDebt,
            usr_wg_FeeType,
            usr_wg_FeeType_Taxable,
            usr_wg_FeeType_Dict,
            usr_wg_TblCalLine,
            usr_wg_TblCal_FlexLine,
            usr_wg_FCRate,
            gd_const_budget,
            usr_wg_Variables,
            usr_wg_Alimony,
            usr_wg_TransferType,
            usr_wg_TransferScale,
            usr_wg_AlimonyDebt,
            usr_wg_Alimony_FeeDoc
            ],
            working_directory(_, '..').
        %%
        
        %% dynamic state
        :- ['kb/param_list'].
        %%
        
        :- ps32k_lgt(64, 128, 64).
        
        :- endif.
        %%% end debug mode section
        
        /* реализация - расчет */
        
        % расчет итогового начисления
        fee_calc(Scope) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            % для каждого сотрудника
            get_param(Scope, in, pEmplKey-EmplKey),
            % выполнить расчет
            fee_calc(Scope, EmplKey),
            % найти альтернативу
            fail.
        fee_calc(_) :-
            % больше альтернатив нет
            !.
        
        % выполнить расчет
        fee_calc(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, begin-Section),
            % удалить временные данные по расчету
            forall( get_param(Scope, Type, pEmplKey-EmplKey, Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % расчет табеля
            calc_tab(Scope, EmplKey),
            % расчет суммы
            calc_amount(Scope, EmplKey),
            % расчет формулы
            calc_formula(Scope, EmplKey),
            % расчет расходов по переводу
            calc_transf(Scope, EmplKey, 1),
            % контроль остатка
            check_rest(Scope, EmplKey),
            % начисление долгов
            add_debt(Scope, EmplKey),
            % списание долгов
            drop_debt(Scope, EmplKey),
            % расчет итога
            calc_total(Scope, EmplKey),
            % записать отладочную информацию
            param_list_debug(Scope, end-Section),
            !.
        
        % расчет табеля
        calc_tab(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCalcTab,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % последний прием на работу
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_last_hire(Scope, PK, DateIn),
            % начало итогового месяца
            get_param_list(Scope, in, [pEmplKey-EmplKey, pDateBegin-DateBegin]),
            atom_date(DateBegin, date(YearBegin, MonthBegin, _)),
            month_days(YearBegin, MonthBegin, DaysBegin),
            % окончание итогового месяца
            atom_date(DateEnd, date(YearBegin, MonthBegin, DaysBegin)),
            % последний прием на работу до окончания итогового месяца
            DateIn @=< DateEnd,
            % Общий табель за итоговый месяц
            atom_date(DateBegin, date(Y, M, _)),
            calc_month_tab(Scope, PK, Y-M, TabDays),
            sum_days_houres(TabDays, TDays, THoures),
            % спецификация временных данных
            append([ [Section-1], PK,
                     [pYM-Y-M, pTDays-TDays, pTHoures-THoures] ],
                        TabPairs),
            % добавить временные данные
            new_param_list(Scope, Type, TabPairs),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fDateBegin-ADateBegin, fDateEnd-ADateEnd ],
            % спецификация временных данных
            append([ [Section-2], PK,
                     [pAlimonyKey-AlimonyKey, pDateBegin-ADateBegin, pDateEnd-ADateEnd],
                     [pYM-Y-M, pTCoef-TCoef,
                      pADays-ADays, pAHoures-AHoures,
                      pTDays-TDays, pTHoures-THoures] ],
                        AlimonyPairs),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % посчитать Дни и Часы для периода действия алиментов
                      sum_days_houres(TabDays, ADays, AHoures, ADateBegin, ADateEnd),
                      % вычислить Коеффициент от Общего табеля
                      catch( TCoef is AHoures / THoures, _, TCoef = 1.0),
                      % добавить временные данные
                      new_param_list(Scope, Type, AlimonyPairs)
                    )
                  ),
            !.
        
        % расчет суммы
        calc_amount(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCalcAmount,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация Начислений по Предыдущему периоду
            SpecTblChargePrev = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fDebit-Debit, fCredit-Credit,
                        fFeeTypeKey-FeeTypeKey ],
            % спецификация временных данных
            AmountPaidPairs = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyAmountPaid-AlimonyAmountPaid,
                        pAlimonyAmount-AlimonyAmount, pAlimonyCoef-AlimonyCoef ],
            SumPaidPairs = [
                        Section-5, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonySumPaid-AlimonySumPaid,
                        pAlimonySum-AlimonySum, pAlimonyCoef-AlimonyCoef ],
            % сумма по Предыдущему периоду
            % где дата Зачисления соответствует Текущему периоду
            calc_amount_by_shape(Scope, EmplKey, 1),
            get_param_list(Scope, Type, [
                            Section-1, pEmplKey-EmplKey,
                            pForAlimony-ForAlimony1 ]),
            % сумма по Предыдущему периоду
            calc_amount_by_shape(Scope, EmplKey, 2),
            get_param_list(Scope, Type, [
                            Section-2, pEmplKey-EmplKey,
                            pForAlimony-ForAlimony2 ]),
            % Коэффициент для Переходящего начисления
            catch( AlimonyCoef is ForAlimony1 / ForAlimony2, _, AlimonyCoef = 0.0 ),
            % начислено Алиментов по Предыдущему периоду
            fee_type_alias(Scope, "ftAlimony", Alias),
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-Alias ]),
            findall( AlimonySum,
                     ( get_data(Scope, kb, usr_wg_TblCharge_Prev, SpecTblChargePrev),
                       AlimonySum is Credit - Debit
                     ),
            AlimonySumList),
            sum_list(AlimonySumList, AlimonyAmount),
            % Оплачено по Предыдущему периоду
            AlimonyAmountPaid is round(AlimonyAmount * AlimonyCoef) * 1.0,
            % сумма по Текущему периоду
            calc_amount_by_shape(Scope, EmplKey, 3),
            % добавить временные данные
            new_param_list(Scope, Type, AmountPaidPairs),
            forall( get_data(Scope, kb, usr_wg_TblCharge_Prev, SpecTblChargePrev),
                    ( AlimonySum is Credit - Debit,
                      AlimonySumPaid is round(AlimonySum * AlimonyCoef) * 1.0,
                      % добавить временные данные
                      new_param_list(Scope, Type, SumPaidPairs)
                    )
                  ),
            !.
        
        % подстановка псевдонима
        fee_type_alias(wg_fee_alimony, "ftAlimony", "ftAlimony").
        fee_type_alias(wg_fee_fine, "ftAlimony", "ftFine").
        fee_type_alias(wg_fee_alimony, "vForAlimony", "vForAlimony").
        fee_type_alias(wg_fee_fine, "vForAlimony", "vForFine").
        fee_type_alias(wg_fee_alimony, "ftAlimonyDebt", "ftAlimonyDebt").
        fee_type_alias(wg_fee_fine, "ftAlimonyDebt", "ftFine"). % ftFineDebt
        fee_type_alias(wg_fee_alimony, "ftTransferDed", "ftTransferDed").
        fee_type_alias(wg_fee_fine, "ftTransferDed", "ftTransferDed").
        
        % расчет суммы по шаблону
        calc_amount_by_shape(Scope, EmplKey, Shape) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCalcAmount,
            % собрать начисления по Группе начислений
            fee_group_charges(Scope, EmplKey, Charges, Shape),
            % Общая сумма
            charges_sum(Charges, AmountAll),
            % Исключаемые начисления
            charges_excl(Scope, EmplKey, Charges, ChargesExcl),
            % Исключаемая сумма
            charges_sum(ChargesExcl, [debit(1), credit(0)], AmountExcl),
            % Подоходный налог (ПН)
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-IncomeTaxFeeType, fAlias-"ftIncomeTax" ]),
            charges_sum(Charges, [debit(0), credit(1)], [IncomeTaxFeeType], IncomeTax),
            % собрать виды начислений, облагаемые ПН
            findall( TaxableFeeType,
                     get_data(Scope, kb, usr_wg_FeeType_Taxable, [
                                 fEmplKey-EmplKey, fFeeTypeKey-TaxableFeeType ]),
            TaxableFeeTypeList),
            % Облагаемая ПН сумма
            charges_sum(Charges, [debit(1), credit(0)], TaxableFeeTypeList, AmountTaxable),
            % Коеффициент ПН
            ( AmountTaxable =:= 0, IncomeTaxCoef = 0
            ; IncomeTaxCoef is IncomeTax / AmountTaxable
            ),
            % Облагаемая ПН Исключаемая сумма
            charges_sum(ChargesExcl, [debit(1), credit(0)], TaxableFeeTypeList, AmountTaxableExcl),
            % Исключаемый ПН
            IncomeTaxExcl is round(AmountTaxableExcl * IncomeTaxCoef) * 1.0,
            % Расчетная сумма = Общая сумма - Исключаемая сумма - Исключаемый ПН
            ForAlimony is round(AmountAll - AmountExcl - IncomeTaxExcl) * 1.0,
            % спецификация временных данных
            AmountPairs = [
                        Section-Shape, pEmplKey-EmplKey, pForAlimony-ForAlimony,
                        pAmountAll-AmountAll, pAmountExcl-AmountExcl, pIncomeTaxExcl-IncomeTaxExcl,
                        pAmountTaxableExcl-AmountTaxableExcl, pIncomeTaxCoef-IncomeTaxCoef,
                        pIncomeTax-IncomeTax, pAmountTaxable-AmountTaxable ],
            % добавить временные данные
            new_param_list(Scope, Type, AmountPairs),
            !.
        
        % расчет формулы
        calc_formula(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCalcFormula,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fFormula-Formula,
                        fChildCount-_, fLivingWagePerc-_ ],
            % спецификации временных данных
            FormulaPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-_,
                        pAlimonySum-_,  pByBudget-_,
                        pWithPrev-_, pForAlimonyPrev-_,
                        pFormula-Formula, pForAlimony-_, pBV-BV,
                        pResult-_, pEval-_, pTCoef-_,
                        pChildCount-_, pLivingWagePerc-_,
                        pBudgetConst-BudgetConst, pBudgetPart-_ ],
            % сумма БВ
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            get_min_wage(Scope, DateCalcTo, BV),
            % БПМ
            get_budget(Scope, DateCalcTo, BudgetConst),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % получить сумму по формуле
                      calc_formula_by_spec(Scope, EmplKey, SpecAlimony, FormulaPairs),
                      % добавить временные данные
                      new_param_list(Scope, Type, FormulaPairs)
                    )
                  ),
            !.
        
        % расчет формулы по спецификациям
        calc_formula_by_spec(Scope, EmplKey, SpecAlimony, FormulaPairs) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCalcFormula,
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fFormula-Formula,
                        fChildCount-ChildCount0, fLivingWagePerc-LivingWagePerc0 ],
            % сопоставить с данными по умолчанию
            LivingWagePerc1 is LivingWagePerc0 / 100,
            fit_data(Scope,
                        [pChildCount-ChildCount0, pLivingWagePerc-LivingWagePerc1],
                        [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc]),
            % спецификация временных данных
            FormulaPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-AlimonySum,
                        pAlimonySum-AlimonySum, pByBudget-ByBudget,
                        pWithPrev-WithPrev, pForAlimonyPrev-ForAlimonyPrev,
                        pFormula-Formula, pForAlimony-ForAlimony, pBV-BV,
                        pResult-Result, pEval-Eval, pTCoef-TCoef,
                        pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc,
                        pBudgetConst-BudgetConst, pBudgetPart-BudgetPart ],
            % составить Формулу
            get_data(Scope, kb, usr_wg_Variables, [fAlias-"vBV", fName-Var_BV]),
            replace_all(Formula, Var_BV, BV, Formula1),
            get_for_alimony(Scope, Type, EmplKey, AlimonyKey, ForAlimony, WithPrev, ForAlimonyPrev),
            fee_type_alias(Scope, "vForAlimony", Alias),
            get_data(Scope, kb, usr_wg_Variables, [fAlias-Alias, fName-Var_ForAlimony]),
            replace_all(Formula1, Var_ForAlimony, ForAlimony, Formula2),
            replace_all(Formula2, ",", ".", Formula3),
            % вычислить Результат
            ( catch( term_to_atom(Expr, Formula3), _, fail ),
              catch( Eval is round(Expr) * 1.0, _, fail), FormulaError = 0
            ; Eval = 0.0, FormulaError = 1
            ),
            get_param_list(Scope, Type, [
                            pCalcTab-2, pAlimonyKey-AlimonyKey, pTCoef-TCoef ]),
            Result is round(Eval * TCoef) * 1.0,
            % Часть БПМ
            ( ChildCount > 0 ->
              BudgetPart is round(BudgetConst * LivingWagePerc * TCoef) * 1.0
            ; BudgetPart = 0.0
            ),
            % Оплачено по Предыдущему периоду
            once( ( get_param_list(Scope, Type, [
                                    pCalcAmount-5, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                                    pAlimonySumPaid-AlimonySumPaid ])
                  ; AlimonySumPaid = 0.0
                  )
                ),
            % сумма Удержания c Контролем от БПМ
            ( FormulaError = 0,
              Result + AlimonySumPaid < BudgetPart
            ->
              AlimonySum0 is BudgetPart - AlimonySumPaid,
              ByBudget = 1
            ; AlimonySum0 = Result,
              ByBudget = 0
            ),
            % Округление
            get_round_data(Scope, EmplKey, "ftAlimony", RoundType, RoundValue),
            round_sum(AlimonySum0, AlimonySum, RoundType, RoundValue),
            !.
        
        % взять сумму Для алиментов
        get_for_alimony(Scope, Type, EmplKey, AlimonyKey, ForAlimony, WithPrev, ForAlimony1) :-
            get_param_list(Scope, Type, [
                            pCalcAmount-3, pEmplKey-EmplKey, pForAlimony-ForAlimony3 ]),
            get_param(Scope, run, pDateCalcFrom-DateCalcFrom),
            get_data(Scope, kb, usr_wg_Alimony, [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fDateBegin-ADateBegin ]),
            get_param_list(Scope, Type, [
                            pCalcAmount-1, pEmplKey-EmplKey, pForAlimony-ForAlimony1 ]),
            ( ADateBegin @>= DateCalcFrom,
              ForAlimony1 > 0
             ->
              ForAlimony is ForAlimony3 + ForAlimony1,
              WithPrev = 1
            ; ForAlimony is ForAlimony3,
              WithPrev = 0
            ),
            !.
        
        % расчет расходов по переводу
        calc_transf(Scope, EmplKey, Stage) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCalcTransf,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fEmplKey-EmplKey, fDocKey-AlimonyKey,
                        fTransferTypeKey-TransferTypeKey0, fRecipient-Recipient0 ],
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyCharge-AlimonyCharge ],
            % спецификация параметров списания долгов алиментов
            DropDebtParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCharge-DropDebtCharge ],
            % спецификация временных данных
            TransfPairs = [
                        Section-Stage, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey1,
                        pTransfCharge-TransfCharge, pTransfByGroup-TransfByGroup,
                        pTransferTypeKey-TransferTypeKey, pRecipient-Recipient,
                        pForTransfAmount-ForTransfAmount, pTransfPercent-TransfPercent ],
            % спецификации данных для расходов по переводу
            AlimonyData = [
                        AlimonyKey, TransferTypeKey0, Recipient1, AlimonyCharge ],
            DropDebtData = [
                        AlimonyKey, TransferTypeKey0, Recipient1, DropDebtCharge ],
            AggrTransfData = [
                        AlimonyKey1, TransfByGroup, TransferTypeKey, Recipient,
                        ForTransfAmount, TransfPercent, TransfCharge ],
            % собрать данные для расходов по переводу
            findall( AlimonyData,
                     ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                       TransferTypeKey0 > 0,
                       %( Recipient0 > 0 ->
                       ( Recipient0 > -1 -> % проверка пока отключена
                         Recipient1 = Recipient0
                       ; Recipient1 is -AlimonyKey
                       ),
                       get_param_list(Scope, Type, AlimonyParams)
                     ),
            AlimonyDataList ),
            findall( DropDebtData,
                     ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                       TransferTypeKey0 > 0,
                       %( Recipient0 > 0 ->
                       ( Recipient0 > -1 -> % проверка пока отключена
                         Recipient1 = Recipient0
                       ; Recipient1 is -AlimonyKey
                       ),
                       get_param_list(Scope, Type, DropDebtParams)
                     ),
            DropDebtDataList ),
            append(AlimonyDataList, DropDebtDataList, TransfDataList),
            % агрегировать суммы расходов по переводам
            aggr_fransf(Scope, EmplKey, TransfDataList, AggrTransfDataList),
            % удалить временные данные по переводам
            forall( get_param_list(Scope, Type, [Section-_, pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % для всех расходов по переводам
            forall( ( member(AggrTransfData, AggrTransfDataList),
                      TransfCharge > 0
                    ),
                    % добавить временные данные
                    new_param_list(Scope, Type, TransfPairs)
                  ),
            !.
        
        % агрегировать суммы расходов по переводам
        aggr_fransf(_, _, [], []) :-
            !.
        aggr_fransf(Scope, EmplKey, [TransfData|TransfDataList], [TransfAggrData|TransfAggrDataList]) :-
            aggr_fransf(Scope, EmplKey, TransfData, [TransfData|TransfDataList], TransfDataList1, TransfAggrData),
            !,
            aggr_fransf(Scope, EmplKey, TransfDataList1, TransfAggrDataList).
        %
        aggr_fransf(Scope, EmplKey, TransfData, TransfDataList, TransfDataList1, TransfAggrData) :-
            % спецификации данных для расходов по переводу
            TransfData = [AlimonyKey, TransferTypeKey, Recipient, _],
            TransfAggrData = [
                        AlimonyKey, TransfByGroup, TransferTypeKey, Recipient,
                        ForTransfAmount, TransfPercent, TransfCharge ],
            % собрать суммы по Группе [Документ, Вид перевода, Получатель]
            findall( AlimonyCharge,
                     member([_, TransferTypeKey, Recipient, AlimonyCharge],
                             TransfDataList),
            AlimonyChargeList),
            % Итог по группе
            sum_list(AlimonyChargeList, ForTransfAmount),
            % Признак группы
            ( length(AlimonyChargeList, 1),
              TransfByGroup = 0
            ;
              TransfByGroup = 1
            ),
            % Процент для расхода на перевод
            get_transf_percent(Scope, EmplKey, TransferTypeKey, ForTransfAmount, TransfPercent),
            % Сумма расхода по переводу
            TransfCharge0 is ForTransfAmount * TransfPercent / 100,
            get_round_data(Scope, EmplKey, "ftTransferDed", RoundType, RoundValue),
            round_sum(TransfCharge0, TransfCharge, RoundType, RoundValue),
            % если есть Группа
            ( TransfByGroup = 1,
              % исключить Группу из списка данных
              findall( [AlimonyKey1, TransferTypeKey1, Recipient1, AlimonySum1],
                       ( member([AlimonyKey1, TransferTypeKey1, Recipient1, AlimonySum1], TransfDataList),
                         \+ [TransferTypeKey, Recipient] = [TransferTypeKey1, Recipient1]
                       ),
              TransfDataList1)
            ; % иначе исключить Текущие данные
              selectchk(TransfData, TransfDataList, TransfDataList1)
            ),
            !.
        
        % контроль остатка
        check_rest(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCheckRest,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fRestPercent-RestPercent0 ],
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonySum-AlimonySum ],
            % спецификация параметров контроля
            CheckParams = [
                        pCalcAmount-3, pEmplKey-EmplKey,
                        pAmountAll-AmountAll ],
            % спецификация временных данных
            CheckPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyAmount-AlimonyAmount, pCheckAmount-CheckAmount,
                        pAmountAll-AmountAll, pRestPercent-RestPercent, pRestAmount-RestAmount,
                        pFeeAmount-FeeAmount
                         ],
            AlimonyPairs = [
                        Section-2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCoef-AlimonyCoef,
                        pAlimonySum-AlimonySum, pAlimonyAmount-AlimonyAmount ],
            % Итог по алиментам
            findall( AlimonySum,
                     get_param_list(Scope, Type, AlimonyParams),
            AlimonySumList),
            sum_list(AlimonySumList, AlimonyAmount),
            % Процент остатка
            findall( RestPercent0,
                     get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
            RestPercentList),
            min_list(RestPercentList, RestPercent0),
            RestPercent1 is RestPercent0 / 100,
            fit_data(Scope, [pRestPercent-RestPercent1], [pRestPercent-RestPercent]),
            get_param_list(Scope, Type, CheckParams),
            % сумма Удержаний
            get_fee_amount(Scope, EmplKey, FeeAmount),
            % сумма Остатка
            RestAmount is round(AmountAll * RestPercent) * 1.0,
            % сумма Контроля
            CheckAmount is round(AmountAll - RestAmount - FeeAmount) * 1.0,
            % добавить временные данные
            new_param_list(Scope, Type, CheckPairs),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( get_param_list(Scope, Type, AlimonyParams),
                      % вычислить коеффициент от Итога
                      catch( AlimonyCoef is AlimonySum / AlimonyAmount, _, AlimonyCoef = 1.0),
                      % добавить временные данные
                      new_param_list(Scope, Type, AlimonyPairs)
                    )
                  ),
            % Дельта для расчета при нехватке средств
            get_param(Scope, fit, pCalcDelta-CalcDelta),
            % контроль остатка по сумме Контроля
            check_rest_amount(Scope, EmplKey, CheckAmount, 0, CalcDelta, 0),
            !.
        
        % сумма Удержаний
        get_fee_amount(Scope, EmplKey, FeeAmount) :-
            % собрать документы по алиментам и штрафам
            findall( DocKey,
                     get_data(Scope, kb, usr_wg_Alimony_FeeDoc, [
                                fDocKey-DocKey, fEmplKey-EmplKey ]),
            DocKeyList ),
            \+ DocKeyList = [],
            % взять суммы
            findall( ChargeSum,
                      % по начислениям
                    ( get_data(Scope, kb, usr_wg_TblCharge, [
                                fDocKey-DocKey, fEmplKey-EmplKey,
                                fDebit-Debit, fCredit-Credit ]),
                      ChargeSum is Credit - Debit,
                      % для документов
                      memberchk(DocKey, DocKeyList)
                    ),
            % в список
            ChargeSumList ),
            % итоговая сумма
            sum_list(ChargeSumList, FeeAmount),
            !.
        get_fee_amount(_, _, 0.0) :-
            !.
        
        % контроль остатка по сумме Контроля
        check_rest_amount(Scope, EmplKey, CheckAmount, CalcDelta0, CalcDelta, CalcSwitch) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pCheckRest,
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyCharge-AlimonyCharge ],
            % спецификация параметров переводов
            TransfParams = [
                        pCalcTransf-_, pEmplKey-EmplKey, pTransfCharge-TransfCharge ],
            % спецификация временных данных
            CheckPairs = [
                        Section-3, pEmplKey-EmplKey,
                        pBalance-Balance, pChargeAmount-ChargeAmount,
                        pAlimonyChargeAmount-AlimonyChargeAmount, pTransfAmount-TransfAmount,
                        pReserveAmount-ReserveAmount, pCheckAmount-CheckAmount,
                        pCalcDelta-CalcDelta, pChargeStep-ChargeStep ],
            % сумма к Удержанию
            findall( AlimonyCharge,
                     get_param_list(Scope, Type, AlimonyParams),
            AlimonyChargeList),
            sum_list(AlimonyChargeList, AlimonyChargeAmount),
            findall( TransfCharge,
                     get_param_list(Scope, Type, TransfParams),
            TransfChargeList),
            sum_list(TransfChargeList, TransfAmount),
            ChargeAmount is AlimonyChargeAmount + TransfAmount,
            % сумма Контроля не меньше суммы к Удержанию
            ( \+ CheckAmount < ChargeAmount -> true ; ChargeAmount =:= 0 ),
            % сумма Баланса
            Balance is CheckAmount - ChargeAmount,
            % сумма Резерва
            ReserveAmount is CheckAmount - CalcDelta0 * CalcSwitch,
            % количество Итераций
            ChargeStep is CalcDelta0 / CalcDelta,
            % добавить временные данные
            new_param_list(Scope, Type, CheckPairs),
            !.
        check_rest_amount(Scope, EmplKey, CheckAmount, CalcDelta0, CalcDelta, CalcSwitch) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            % увеличить Дельту
            CalcDelta1 is CalcDelta0 + CalcDelta * CalcSwitch,
            % сумма Резерва
            ReserveAmount0 is CheckAmount - CalcDelta1,
            ( ReserveAmount0 > 0, ReserveAmount = ReserveAmount0
            ; ReserveAmount = 0.0
            ),
            % распределить суммы по Коэффициентам от суммы Резерва
            charge_by_coef(Scope, EmplKey, ReserveAmount),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 2),
            !,
            check_rest_amount(Scope, EmplKey, CheckAmount, CalcDelta1, CalcDelta, 1).
        
        % распределить суммы по Коэффициентам от суммы Резерва
        charge_by_coef(Scope, EmplKey, ReserveAmount) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp,
            % спецификации параметров алиментов
            CalcFormulaParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-_ ],
            CheckRestParams = [
                        pCheckRest-2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCoef-AlimonyCoef ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimony", RoundType, RoundValue),
            % для всех Алиментов
            forall( get_param_list(Scope, Type, CalcFormulaParams, Pairs),
                    ( % вычислить Пропорцию
                      get_param_list(Scope, Type, CheckRestParams),
                      AlimonyCharge0 is ReserveAmount * AlimonyCoef,
                      round_sum(AlimonyCharge0, AlimonyCharge, RoundType, RoundValue),
                      % заменить сумму Удержания
                      replace_list(Pairs,
                                      [pAlimonyCharge-_],
                                      [pAlimonyCharge-AlimonyCharge],
                                          Pairs1),
                      dispose_param_list(Scope, Type, Pairs),
                      new_param_list(Scope, Type, Pairs1)
                    )
                  ),
            !.
        
        % начисление долгов
        add_debt(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pAddDebt,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификации параметров алиментов
            CalcFormulaParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum,
                        pChildCount-ChildCount ],
            % спецификация временных данных
            AddDebtPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyDebt-AlimonyDebt,
                        pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            forall( ( % для всех Алиментов
                      get_param_list(Scope, Type, CalcFormulaParams),
                      % с заполненным Количеством детей или Штрафов
                      ( ChildCount > 0 -> true ; Scope = wg_fee_fine )
                    ),
                    ( % рассчитать сумму Долга по алиментам
                      AlimonyDebt0 is AlimonySum - AlimonyCharge,
                              % при наличии Долга по алиментам
                      once( ( round_sum(AlimonyDebt0, AlimonyDebt, RoundType, RoundValue),
                              AlimonyDebt > 0,
                              % добавить временные данные
                              new_param_list(Scope, Type, AddDebtPairs)
                            ; % иначе продолжить
                              true
                            )
                          )
                     )
                  ),
            !.
        
        % списание долгов
        drop_debt(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pDropDebt,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % нет новых долгов
            \+ get_param_list(Scope, Type, [pAddDebt-1, pEmplKey-EmplKey]),
            % последний прием на работу
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_last_hire(Scope, PK, DateIn),
            % есть данные по долгам
            once( ( get_data(Scope, kb, usr_wg_AlimonyDebt, [
                                fEmplKey-EmplKey, fDateDebt-DateDebt ]),
                    DateDebt @>= DateIn
                  )
                ),
            % спецификация параметров Контроля
            CheckRestParams = [
                        pCheckRest-3, pEmplKey-EmplKey, pBalance-Balance ],
            % Контроль Баланса
            get_param_list(Scope, Type, CheckRestParams),
            Balance > 0,
            % Подготовка данных по Cписанию долгов
            drop_debt_prep_data(Scope, EmplKey, DateIn, Balance),
            % Списание долгов
            drop_debt_charge(Scope, EmplKey),
            % Контроль остатка после Списания долгов
            drop_debt_check_rest(Scope, EmplKey),
            !.
        drop_debt(Scope, _) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            !.
        
        % Подготовка данных по Cписанию долгов
        drop_debt_prep_data(Scope, EmplKey, DateIn, Balance) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pDropDebt,
            CutRoundType = 3,
            % спецификация Алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fPercent-Percent ],
            % спецификации временных данных по Расчету Алиментов
            FormulaPairs = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pTCoef-TCoef ],
            % спецификация Долгов по алиментам
            SpecAlimonyDebt = [
                        fDocKey-AlimonyDebtKey, fEmplKey-EmplKey,
                        fCalYear-Y, fCalMonth-M, fDateDebt-DateDebt,
                        fAlimonyKey-AlimonyKey, fDebtSum-DebtSum ],
            % спецификация Списания долгов по алиментам
            SpecAlimonyPaid = [
                        fDocKey-AlimonyDebtKey, fEmplKey-EmplKey,
                        fDebit-Debit, fCredit-Credit ],
            % спецификации временных данных
            RestDebtPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pRestSum-RestSum, pDebtSum-DebtSum, pPaidSum-PaidSum,
                        pYM-Y-M, pDateDebt-DateDebt ],
            DropDebtPairs = [
                        Section-2, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey,
                        pDropDebtAmount-DropDebtAmount, pRestDebtAmount-RestDebtAmount,
                        pDebtAmount-DebtAmount, pPaidDebtAmount-PaidDebtAmount,
                        pEvalDebtAmount-EvalDebtAmount,
                        pForAlimony-ForAlimony, pDebtPercent-DebtPercent ],
            TotalDebtPairs = [
                        Section-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance,
                        pDropDebtTotal-DropDebtTotal, pRestDebtTotal-RestDebtTotal,
                        pDebtTotal-DebtTotal, pPaidDebtTotal-PaidDebtTotal,
                        pCalcDelta-CalcDelta, pChargeStep-0 ],
            CoefDebtPairs = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCoef-DropDebtCoef ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % сумма Баланса для Cписания долгов по алиментам
            round_sum(Balance, DropDeptBalance, CutRoundType, RoundValue),
            DropDeptBalance > 0,
            % для всех Долгов по алиментам
            forall( ( get_data(Scope, kb, usr_wg_AlimonyDebt, SpecAlimonyDebt),
                      DateDebt @>= DateIn
                    ),
                    ( % суммировать Cписание долгов
                      findall( PaidSum0,
                               ( get_data(Scope, kb, usr_wg_TblCharge_AlimonyDebt, SpecAlimonyPaid),
                                 PaidSum0 is Credit - Debit
                               ),
                      PaidSumList ),
                      sum_list(PaidSumList, PaidSum),
                      % вычислить Остаток
                      RestSum0 is DebtSum - PaidSum,
                      round_sum(RestSum0, RestSum, CutRoundType, RoundValue),
                      % добавить временные данные
                      once( ( RestSum > 0,
                              new_param_list(Scope, Type, RestDebtPairs)
                            ; true
                            )
                          )
                    )
                  ),
            % для всех Алиментов
            forall( ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                      get_param_list(Scope, Type, FormulaPairs)
                    ),
                    ( % суммировать Долги
                      findall( DebtSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      DebtList ),
                      sum_list(DebtList, DebtAmount),
                      % суммировать Оплату по долгам
                      findall( PaidSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      PaidList ),
                      sum_list(PaidList, PaidDebtAmount),
                      % суммировать Остатки по долгам
                      findall( RestSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      RestList ),
                      sum_list(RestList, RestDebtAmount),
                      % сумма Для алиментов
                      get_param_list(Scope, Type, [
                            pCalcAmount-3, pEmplKey-EmplKey, pForAlimony-ForAlimony ]),
                      % Процент Списания долга
                      Percent1 is Percent / 100,
                      fit_data(Scope, [pPercent-Percent1], [pPercent-DebtPercent]),
                      % расчет Списания долга
                      EvalDebtAmount0 is ForAlimony * DebtPercent * TCoef,
                      round_sum(EvalDebtAmount0, EvalDebtAmount, RoundType, RoundValue),
                      % сумма Списания долга
                      ( EvalDebtAmount < RestDebtAmount
                       ->
                        DropDebtAmount = EvalDebtAmount
                      ; DropDebtAmount = RestDebtAmount
                      ),
                      % добавить временные данные
                      once( ( DropDebtAmount > 0,
                              new_param_list(Scope, Type, DropDebtPairs)
                            ; true
                            )
                          )
                    )
                  ),
            % Общая сумма Остатков по долгам
            findall( RestDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            RestDebtAmountList ),
            sum_list(RestDebtAmountList, RestDebtTotal),
            RestDebtTotal > 0,
            % Общая сумма Долгов
            findall( DebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            DebtAmountList ),
            sum_list(DebtAmountList, DebtTotal),
            % Общая сумма Оплаты по долгам
            findall( PaidDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            PaidDebtAmountList ),
            sum_list(PaidDebtAmountList, PaidDebtTotal),
            % Общая сумма Списания долга
            findall( DropDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            DropDebtAmountList ),
            sum_list(DropDebtAmountList, DropDebtTotal),
            DropDebtTotal > 0,
            % Дельта для расчета при нехватке средств
            get_param(Scope, fit, pCalcDelta-CalcDelta),
            % добавить временные данные
            new_param_list(Scope, Type, TotalDebtPairs),
            % для всех Списаний долгов по Алиментам
            forall( get_param_list(Scope, Type, DropDebtPairs),
                    ( % рассчитать Пропорцию
                      DropDebtCoef is DropDebtAmount / DropDebtTotal,
                      % добавить временные данные
                      new_param_list(Scope, Type, CoefDebtPairs)
                    )
                  ),
            !.
        
        % Списание долгов
        drop_debt_charge(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pDropDebt,
            % Итоги для Списания долгов
            TotalDebtParams = [
                        Section-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance, pDropDebtTotal-DropDebtTotal ],
            get_param_list(Scope, Type, TotalDebtParams),
            ( DropDeptBalance < DropDebtTotal,
              ByDropDebtCoef = 1
            ; ByDropDebtCoef = 0
            ),
            % Списание долгов по Балансу
            drop_debt_charge(Scope, EmplKey, DropDeptBalance, ByDropDebtCoef),
            !.
        % Списание долгов по Балансу
        drop_debt_charge(Scope, EmplKey, DropDeptBalance, ByDropDebtCoef) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, Section = pDropDebt,
            % спецификации параметров Долгов по алиментам
            RestDebtParams = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pRestSum-RestSum, pDateDebt-DateDebt ],
            DropDebtParams = [
                        Section-2, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtAmount-DropDebtAmount ],
            CoefDebtParams = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCoef-DropDebtCoef ],
            % спецификация временных данных по Списанию долгов
            DropDebtChargePairs = [
                        Section-5, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pDropDebtCharge-_, pByDropDebtCoef-ByDropDebtCoef ],
            % удалить временные данные по Списанию долгов
            forall( get_param_list(Scope, Type, [Section-5, pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % для всех Долгов по алиментам
            forall( get_param_list(Scope, Type, DropDebtParams),
                    ( % собрать Остатки долгов
                      findall( DateDebt-AlimonyDebtKey-RestSum,
                               get_param_list(Scope, Type, RestDebtParams),
                      RestDebtDataList0 ),
                      % в порядке их образования
                      msort(RestDebtDataList0, RestDebtDataList),
                      % определить Баланс для Списания долгов
                      ( ByDropDebtCoef = 0 ->
                        DropDeptBalance1 is DropDeptBalance
                      ; get_param_list(Scope, Type, CoefDebtParams),
                        DropDeptBalance1 is DropDeptBalance * DropDebtCoef
                      ),
                      round_sum(DropDeptBalance1, DropDeptBalance2, RoundType, RoundValue),
                      % списать Остатки долгов
                      drop_debt_charge(Scope, RestDebtDataList, DropDebtChargePairs, DropDebtAmount, DropDeptBalance2, RoundType, RoundValue)
                    )
                  ),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 3),
            !.
        
        % списать Остатки долгов
        drop_debt_charge(Scope, RestDebtDataList, _, DropDebtAmount, DropDeptBalance, _, _) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            ( RestDebtDataList = [] ; DropDebtAmount =< 0 ; DropDeptBalance =< 0 ),
            !.
        drop_debt_charge(Scope, [_-AlimonyDebtKey-RestSum|RestDebtDataList], DropDebtChargePairs, DropDebtAmount, DropDeptBalance, RoundType, RoundValue) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp,
            % определить сумму Списания
            ( RestSum < DropDebtAmount  ->
              DropDebtCharge0 is RestSum
            ; DropDebtCharge0 is DropDebtAmount
            ),
            ( DropDebtCharge0 < DropDeptBalance  ->
              DropDebtCharge1 is DropDebtCharge0
            ; DropDebtCharge1 is DropDeptBalance
            ),
            round_sum(DropDebtCharge1, DropDebtCharge, RoundType, RoundValue),
            member_list([pAlimonyDebtKey-AlimonyDebtKey, pDropDebtCharge-DropDebtCharge],
                            DropDebtChargePairs),
            % добавить временные данные
            new_param_list(Scope, Type, DropDebtChargePairs),
            % новая спецификация временных данных
            replace_list(DropDebtChargePairs,
                            [pAlimonyDebtKey-AlimonyDebtKey, pDropDebtCharge-DropDebtCharge],
                            [pAlimonyDebtKey-_, pDropDebtCharge-_],
                                DropDebtChargePairs1),
            % новый Баланс для Списания долгов
            DropDebtAmount1 is DropDebtAmount - DropDebtCharge,
            DropDeptBalance1 is DropDeptBalance - DropDebtCharge,
            !,
            drop_debt_charge(Scope, RestDebtDataList, DropDebtChargePairs1, DropDebtAmount1, DropDeptBalance1, RoundType, RoundValue).
        
        % Контроль остатка после Списания долгов
        drop_debt_check_rest(Scope, EmplKey) :-
            Type = temp, NextType = out,
            % спецификация параметров Контроля остатка
            CheckParams = [
                        pCheckRest-1, pEmplKey-EmplKey,
                        pCheckAmount-CheckAmount ],
            % спецификация параметров Общего итога
            TotalParams = [
                        pCalcTotal-1, pEmplKey-EmplKey,
                        pAllChargeTotal-AllChargeTotal ],
            % спецификация параметров Итога Списания долгов
            TotalDebtParams = [
                        pDropDebt-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance,
                        pCalcDelta-CalcDelta, pChargeStep-ChargeStep ],
            % сумма Контроля остатка
            get_param_list(Scope, Type, CheckParams),
            % сумма Итога
            calc_total(Scope, EmplKey),
            get_param_list(Scope, NextType, TotalParams),
            % Контроль остатка
            AllChargeTotal > CheckAmount,
            % уменьшение Баланса для Списания долгов
            get_param_list(Scope, Type, TotalDebtParams, TotalDebtPairs),
            DropDeptBalance1 is DropDeptBalance - CalcDelta,
            DropDeptBalance1 > 0,
            % Списание долгов по Балансу
            drop_debt_charge(Scope, EmplKey, DropDeptBalance1, 1),
            % изменение Итога Списания долгов
            ChargeStep1 is ChargeStep + 1,
            replace_list(TotalDebtPairs,
                            [pDropDeptBalance-DropDeptBalance],
                            [pDropDeptBalance-DropDeptBalance1],
                                TotalDebtPairs1),
            replace_list(TotalDebtPairs1,
                            [pChargeStep-ChargeStep],
                            [pChargeStep-ChargeStep1],
                                TotalDebtPairs2),
            dispose_param_list(Scope, Type, TotalDebtPairs),
            new_param_list(Scope, Type, TotalDebtPairs2),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 3),
            !,
            drop_debt_check_rest(Scope, EmplKey).
        drop_debt_check_rest(_, _) :-
            !.
        
        % расчет итога
        calc_total(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, NextType = out, Section = pCalcTotal,
            % записать отладочную информацию
            param_list_debug(Scope, NextType-Section),
            % спецификации параметров
            AlimonyChargeParams = [
                        pCheckRest-3, pEmplKey-EmplKey,
                        pAlimonyChargeAmount-AlimonyChargeAmount ],
            DropDebtChargeParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pDropDebtCharge-DropDebtCharge ],
            TransfChargeParams = [
                        pCalcTransf-_, pEmplKey-EmplKey,
                        pTransfCharge-TransfCharge ],
            % спецификация временных данных
            TotalPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAllChargeTotal-AllChargeTotal,
                        pAlimonyChargeTotal-AlimonyChargeAmount,
                        pDropDebtChargeTotal-DropDebtChargeTotal,
                        pTransfChargeTotal-TransfChargeTotal ],
            % Итог по Алиментам
            once( ( get_param_list(Scope, Type, AlimonyChargeParams)
                  ; AlimonyChargeAmount = 0
                  )
                ),
            % Итог по Списанию Долгов
            findall( DropDebtCharge,
                     get_param_list(Scope, Type, DropDebtChargeParams),
            DropDebtChargeList),
            sum_list(DropDebtChargeList, DropDebtChargeTotal),
            % Итог по Расходам на переводы
            findall( TransfCharge,
                     get_param_list(Scope, Type, TransfChargeParams),
            TransfChargeList),
            sum_list(TransfChargeList, TransfChargeTotal),
            % Общий итог
            AllChargeTotal is AlimonyChargeAmount + DropDebtChargeTotal + TransfChargeTotal,
            % удалить выходные данные по расчету
            forall( get_param(Scope, NextType, pEmplKey-EmplKey, Pairs),
                    dispose_param_list(Scope, NextType, Pairs) ),
            % добавить выходные данные
            new_param_list(Scope, NextType, TotalPairs),
            !.
        
        /* реализация - сервис */
        
        % взять параметры Округления
        get_round_data(Scope, _, Alias0, RoundType, RoundValue) :-
            fee_type_alias(Scope, Alias0, Alias),
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fAlias-Alias, fRoundByFeeType-1,
                        fRoundType-RoundType, fRoundValue-RoundValue ]),
            !.
        get_round_data(Scope, EmplKey, _, RoundType, RoundValue) :-
            get_param_list(Scope, in, [
                        pEmplKey-EmplKey,
                        pRoundType-RoundType, pRoundValue-RoundValue ]),
            !.
        
        % Процент для расхода на перевод
        get_transf_percent(Scope, EmplKey, TransferTypeKey, Sum, Percent) :-
            get_param_list(Scope, run, [pEmplKey-EmplKey, pDateCalcTo-DateCalcTo]),
            findall( TransferData,
                     get_transf_type(Scope, DateCalcTo, TransferTypeKey, TransferData),
            TransferDataList),
            msort(TransferDataList, TransferDataList1),
            last(TransferDataList1, _-TransferTypeKey1),
            get_transf_scale(Scope, TransferTypeKey1, Sum, Percent),
            !.
        get_transf_percent(_, _, _, _, 0.0) :-
            !.
        
        % Расценки на перевод
        get_transf_type(Scope, DateCalcTo, TransferTypeKey0, DateBegin-TransferTypeKey) :-
            get_data(Scope, kb, usr_wg_TransferType, [
                        fID-TransferTypeKey, fParent-TransferTypeKey0,
                        fDateBegin-DateBegin ]),
            \+ get_data(Scope, kb, usr_wg_TransferType, [
                            fParent-TransferTypeKey]),
            DateBegin @< DateCalcTo.
        get_transf_type(Scope, DateCalcTo, TransferTypeKey0, TransferData) :-
            get_data(Scope, kb, usr_wg_TransferType, [
                        fID-TransferTypeKey1, fParent-TransferTypeKey0 ]),
            get_transf_type(Scope, DateCalcTo, TransferTypeKey1, TransferData).
        
        % Шкала расценок
        get_transf_scale(Scope, TransferTypeKey, Sum, Percent) :-
            findall( StartSum-Percent0,
                     ( get_data(Scope, kb, usr_wg_TransferScale, [
                                 fTranferTypeKey-TransferTypeKey,
                                 fStartSum-StartSum, fPercent-Percent0 ]),
                       Sum >= StartSum ),
            ScaleDataList),
            msort(ScaleDataList, ScaleDataList1),
            last(ScaleDataList1, _-Percent),
            !.
        get_transf_scale(_, _, _, 0.0) :-
            !.
        
        % собрать начисления по Группе начислений
        fee_group_charges(Scope, EmplKey, Charges, Shape) :-
            % спецификация для начислений
            SpecTblCharge =  [
                fEmplKey-EmplKey,
                fCalYear-Y, fCalMonth-M, fDateBegin-DateBegin,
                fDebit-Debit, fCredit-Credit,
                fFeeTypeKey-FeeTypeKey ],
            % спецификация для группы начислений
            SpecFeeType =  [
                fEmplKey-EmplKey, fFeeTypeKey-FeeTypeKey ],
            % спецификация данных начисления
            ChargeData = [
                Y-M, DateBegin, Debit, Credit, FeeTypeKey ],
            % текущее Итоговое начисление
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateBegin-DateBegin0 ]),
            atom_date(DateBegin0, date(Y0, M0, _)),
            % выбор набора данных по шаблону расчета
            memberchk(Shape-DatasetName, [
                            1-usr_wg_TblCharge_Prev, % предыдущий - зачисление текущий
                            2-usr_wg_TblCharge_Prev, % предыдущий
                            3-usr_wg_TblCharge ]),   % текущий
            % взять данные
            findall( ChargeData,
                      % по начислениям
                    ( get_data(Scope, kb, DatasetName, SpecTblCharge),
                      % соответствующего типа
                      get_data(Scope, kb, usr_wg_FeeType, SpecFeeType),
                      % с фильтром для шаблона расчета
                      ( Shape = 1, Y-M = Y0-M0 -> true ; \+ Shape = 1 ),
                      % и контролем суммы
                      ( \+ Debit =:= 0 -> true ; \+ Credit =:= 0 )
                    ),
            % в список
            Charges ),
            !.
        
        % исключаемые начисления
        charges_excl(Scope, EmplKey, Charges, ChargesExcl) :-
            % спецификация данных начисления
            ChargeData = [
                _-_, DateBegin, _, _, FeeTypeKey ],
            % собрать исключаемые начисления
            findall( ChargeData,
                     ( member(ChargeData, Charges),
                       is_fee_type_excl(Scope, EmplKey, DateBegin, FeeTypeKey)
                     ),
            ChargesExcl ),
            !.
        
        % сумма начислений
        charges_sum(Charges, Amount) :-
            charges_sum(Charges, [], [], 0, Amount),
            !.
        %
        charges_sum(Charges, Options, Amount) :-
            charges_sum(Charges, Options, [], 0, Amount),
            !.
        %
        charges_sum(Charges, Options, ValidFeeTypes, Amount) :-
            charges_sum(Charges, Options, ValidFeeTypes, 0, Amount),
            !.
        %
        charges_sum([], _, _, Amount, Amount) :-
            !.
        charges_sum([Charge|Charges], Options, ValidFeeTypes, Amount0, Amount) :-
            charge_acc(Charge, Options, ValidFeeTypes, Amount0, Amount1),
            !,
            charges_sum(Charges, Options, ValidFeeTypes, Amount1, Amount).
        
        % накопление суммы начислений
        charge_acc(ChargeData, Options, ValidFeeTypes, Amount0, Amount1) :-
            % спецификация данных
            ChargeData = [
                _-_, _, Debit, Credit, FeeTypeKey ],
            % если тип начисления действителен
            ( ValidFeeTypes = [] ; memberchk(FeeTypeKey, ValidFeeTypes) ),
            % установить опции
            ( memberchk(debit(InclDebit), Options) ; InclDebit = 1 ),
            ( memberchk(credit(InclCredit), Options) ; InclCredit = 1 ),
            % и произвести накопление
            Amount1 is Amount0 + Debit * InclDebit - Credit * InclCredit,
            !.
        charge_acc(_, _, _, Amount, Amount) :-
            !.
        
        % тип начисления исключается из расчета
        is_fee_type_excl(Scope, EmplKey, DateBegin, FeeTypeKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            % если вид начисления "Компенсация отпуска"
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-Alias ]),
            memberchk(Alias, ["ftHolidayComp"]),
            % и сотрудник уволен в месяце текущей даты
            is_fired(Scope, EmplKey, DateBegin),
            !.
        
        % сотрудник уволен в месяце текущей даты
        is_fired(Scope, EmplKey, DateBegin) :-
            atom_date(DateBegin, date(Y, M, _)),
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey,
                        fMoveYear-Y, fMoveMonth-M,
                        fMovementType-3 ]),
            !.
        
        % сопоставить с данными по умолчанию
        fit_data(Scope, [Name-Value0], [Name-Value]) :-
            % - для алиментов и штрафов (Процент остатка)
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = fit,
            Name = pRestPercent,
            ( Value0 > 0, Value = Value0
            ; get_param(Scope, Type, Name-Value)
            ),
            !.
        % сопоставить с данными по умолчанию
        fit_data(Scope, [Name-Value0], [Name-Value]) :-
            % - для алиментов и штрафов (Процент списания долга)
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = fit,
            Name = pPercent,
            ( Value0 > 0, Value = Value0
            ; get_param(Scope, Type, Name-Value)
            ),
            !.
        fit_data(Scope, Pairs0, Pairs) :-
            % - для алиментов (Процент от БПМ)
            Scope = wg_fee_alimony,
            Type = fit,
            % fine
            Pairs0 = [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc0],
            Pairs = [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc],
            Pairs1 = [pChildQtyCmp-ChildQtyCmp, pLivingWagePerc-LivingWagePerc1],
            %
            get_param_list(Scope, Type, Pairs1),
            catch( atomic_concat(ChildCount, ChildQtyCmp, Atom), _, fail ),
            catch( term_to_atom(Term, Atom), _, fail),
            catch( Term, _, fail),
            %
            ( LivingWagePerc0 > 0, LivingWagePerc = LivingWagePerc0
            ; LivingWagePerc = LivingWagePerc1
            ),
            !.
        fit_data(_, Pairs, Pairs) :-
            !.
        
        /* реализация - расширение для клиента */
        
        % загрузка входных данных по сотруднику
        fee_calc_in(Scope, EmplKey, DateBegin, TotalDocKey, FeeTypeKey, RoundType, RoundValue) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = in, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pEmplKey-EmplKey, pDateBegin-DateBegin,
                pTotalDocKey-TotalDocKey, pFeeTypeKey-FeeTypeKey,
                pRoundType-RoundType, pRoundValue-RoundValue
                ]),
            !.
        
        % подготовка данных выполнения
        fee_calc_prep(Scope) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = in, TypeNextStep = run,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % для каждого сотрудника
            get_param_list(Scope, Type, [pEmplKey-_, pDateBegin-DateBegin], Pairs),
            % собрать входные данные
            findall( Pairs0,
                     ( member(Template, [pCommon-1, pAlimony-1]),
                       get_param_list(Scope, Type, [Template], Pairs0)
                     ),
            PairsList ),
            append(PairsList, PairsNextStep0),
            % сформировать данные выполнения
            date_add(DateBegin, -1, month, DateBegin0),
            atom_date(DateBegin0, date(Y0, M0, _)),
            atom_date(DatePrevCalcFrom, date(Y0, M0, 1)),
            atom_date(DateBegin, date(Y, M, _)),
            atom_date(DateCalcFrom, date(Y, M, 1)),
            date_add(DateBegin, 1, month, DateBegin1),
            atom_date(DateBegin1, date(Y1, M1, _)),
            atom_date(DateCalcTo, date(Y1, M1, 1)),
            % записать данные выполнения
            append([ Pairs,
                     [
                       pDatePrevCalcFrom-DatePrevCalcFrom, pDatePrevCalcTo-DateCalcFrom,
                       pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo
                     ],
                     PairsNextStep0
                   ],
                       PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            % найти альтернативу
            fail.
        fee_calc_prep(_) :-
            % больше альтернатив нет
            !.
        
        % выгрузка данных выполнения по сотруднику
        fee_calc_run(Scope, EmplKey) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = run, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % взять данные выполнения
            get_param_list(Scope, Type, PK),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % формирование SQL-запросов по сотруднику
        fee_calc_sql(Scope, EmplKey, PredicateName, Arity, SQL) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = run, TypeNextStep = query,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, kb, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, kb, Query, SQL0, Params),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-запросу
            PairsNextStep = [pEmplKey-EmplKey, pQuery-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % формирование SQL-команд по сотруднику
        fee_calc_cmd(Scope, EmplKey, PredicateName, Arity, SQL) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = run, TypeNextStep = cmd,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, cmd, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, cmd, Query, SQL0, Params),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-команде
            PairsNextStep = [pEmplKey-EmplKey, pCmd-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % выгрузка выходных данных по сотруднику
        fee_calc_out(Scope, EmplKey, Result) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = out, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % спецификация параметров выходных данных
            append([[pCalcTotal-1], PK, [pAllChargeTotal-Result]], OutPairs),
            % взять выходные данные
            get_param_list(Scope, Type, OutPairs),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % выгрузка выходных данных по начислениям по сотруднику
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex) :-
            % - для алиментов и штрафов (начисление)
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, AccountKeyIndex = 0,
            fee_type_alias(Scope, "ftAlimony", Alias),
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeID, fAlias-Alias ]),
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey,
                        pAlimonyCharge-ChargeSum, pAlimonyKey-DocKey ],
            % взять данные по алиментам
            get_param_list(Scope, Type, AlimonyParams),
            ChargeSum > 0,
            true.
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex) :-
            % - для алиментов и штрафов (списание долгов)
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, AccountKeyIndex = 1,
            fee_type_alias(Scope, "ftAlimonyDebt", Alias),
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeID, fAlias-Alias ]),
            % спецификация параметров списания долгов
            DropDebtParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pDropDebtCharge-ChargeSum, pAlimonyDebtKey-DocKey ],
            % взять данные по списанию долгов
            get_param_list(Scope, Type, DropDebtParams),
            ChargeSum > 0,
            true.
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex) :-
            % - для алиментов и штрафов (пересылка)
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp, AccountKeyIndex = 2,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeID, fAlias-"ftTransferDed" ]),
            % спецификация параметров перевода
            TransfParams = [
                        pCalcTransf-_, pEmplKey-EmplKey,
                        pTransfCharge-ChargeSum, pAlimonyKey-DocKey ],
            % взять данные по переводу
            get_param_list(Scope, Type, TransfParams),
            ChargeSum > 0,
            true.
        
        % выгрузка выходных данных по долгам по сотруднику
        fee_calc_debt(Scope, EmplKey, AlimonyKey, DebtSum, DateDebt) :-
            % - для алиментов и штрафов (долги)
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Type = temp,
            % спецификация параметров долга
            DebtParams = [
                        pAddDebt-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebt-DebtSum ],
            % взять данные по списанию долгу
            get_param_list(Scope, Type, DebtParams),
            DebtSum > 0,
            % дата долга
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            date_add(DateCalcTo, -1, day, DateDebt),
            true.
        
        % протокол по начислению
        fee_calc_prot(Scope, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            findall( Sections, fee_prot(Scope, _, Sections), SectionsList),
            fee_calc_prot(Scope, SectionsList, EmplKey, "", ProtText),
            !.
        %
        fee_calc_prot(_, [], _, ProtText, ProtText) :-
            !.
        fee_calc_prot(Scope, [Sections|SectionsList], EmplKey, ProtText0, ProtText) :-
            fee_prot(Scope, Types, Sections),
            fee_prot(Scope, Types, Sections, EmplKey, ProtText1),
            string_concat(ProtText0, ProtText1, ProtText2),
            !,
            fee_calc_prot(Scope, SectionsList, EmplKey, ProtText2, ProtText).
        
        /* реализация - протокол */
        
        % Протокол удержания алиментов (общая информация)
        fee_prot(wg_fee_alimony, [in], [pEmplInfo-1]).
        fee_prot(wg_fee_alimony, [temp], [pCalcTab-1]).
        % Исполнительные листы (пропорция по отработанному времени)
        fee_prot(wg_fee_alimony, [temp], [pCalcTab-2]).
        % Суммы для расчета
        fee_prot(wg_fee_alimony, [temp], [pCalcAmount-3]).
        % Исполнительные листы (расчетная сумма алиментов)
        fee_prot(wg_fee_alimony, [temp, temp], [pCalcFormula-1, pCheckRest-1]).
        % Контрольная сумма
        fee_prot(wg_fee_alimony, [temp], [pCheckRest-1]).
        % Удержания и долги
        fee_prot(wg_fee_alimony, [temp, temp, out], [pCalcFormula-1, pAddDebt-1, pCalcTotal-1]).
        % Исполнительные листы (расчетная сумма списания долгов)
        fee_prot(wg_fee_alimony, [temp, temp], [pDropDebt-2, pDropDebt-3]).
        % Исполнительные листы (частичная сумма списания долга)
        fee_prot(wg_fee_alimony, [temp, temp, out], [pDropDebt-3, pDropDebt-5, pCalcTotal-1]).
        % расходы по Переводу
        fee_prot(wg_fee_alimony, [temp, out], [pCalcTransf-_, pCalcTotal-1]).
        % Итого удержано
        fee_prot(wg_fee_alimony, [out], [pCalcTotal-1]).
        % Штрафы
        fee_prot(wg_fee_fine, Types, Sections) :-
            fee_prot(wg_fee_alimony, Types, Sections).
        
        % подстановка псевдонима в протоколе
        prot_alias(wg_fee_alimony, "Алименты", "Алименты").
        prot_alias(wg_fee_alimony, "алиментов", "алиментов").
        prot_alias(wg_fee_alimony, "алиментам", "алиментам").
        prot_alias(wg_fee_fine, "Алименты", "Штрафы").
        prot_alias(wg_fee_fine, "алиментов", "штрафов").
        prot_alias(wg_fee_fine, "алиментам", "штрафам").
        
        % Протокол удержания алиментов (общая информация)
        fee_prot(Scope, _, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pEmplInfo-1],
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для даты последнего приема на работу
            get_last_hire(Scope, PK, DateBegin),
            % взять дополнительные данные из первого движения
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey,
                        fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fMovementType-1,
                        fListNumber-ListNumber ]),
            % взять наименование сотрудника из контактов
            get_data(Scope, kb, gd_contact, [
                        fID-EmplKey, fName-Name ]),
            prot_alias(Scope, "алиментов", Alias1),
            format( string(ProtText),
                    "~w~w~n~` t~w~9+ ~w~` t~w~32+ ~w~n",
                    [ "Протокол удержания ", Alias1,
                      "Таб. №:", ListNumber, "Сотрудник:", Name ] ),
                !.
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Types = [Type],
            Sections = [pCalcTab-1],
            Sections = [Section],
            % fine
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey,
                            pYM-Y-M, pTDays-TDays, pTHoures-THoures ]),
            month_name(M, MonthName),
            format( string(ProtText),
                    "~` t~w~9+ ~w ~w ~w~` t~w~32+ ~1f ~w~1f ~w~n",
                    [ "Период:", MonthName, Y, "г.",
                      "Отработано:", THoures, "ч. (", TDays, "дн.)" ] ),
            !.
        % Исполнительные листы (пропорция по отработанному времени)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcTab-2],
            %Types = [Type],
            %Sections = [Section],
            format( string(ProtText0),
                    "~n~2|~w~n~4|~w~15|~w~27|~w~39|~w~60|~w~n",
                    [ "Исполнительные листы (пропорция по отработанному времени):",
                      "Ключ", "Начало", "Окончание", "Отработано", "Пропорция"  ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText),
            !.
        % Суммы для расчета
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcAmount-3],
            Types = [Type],
            Sections = [Section],
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey, pForAlimony-ForAlimony,
                            pAmountAll-AmountAll, pIncomeTax-IncomeTax,
                            pAmountExcl-AmountExcl, pIncomeTaxExcl-IncomeTaxExcl ]),
            prot_alias(Scope, "алиментов", Alias1),
            ( AmountExcl > 0 ->
              Format1 = "~n~2|~w~n~4|~0f~w~0f~w~0f~n",
              Args1 = [ "Заработок = Начисленная сумма - ПН",
                      AmountAll, " = ", AmountAll - IncomeTax, " - ", -IncomeTax
                      ]
            ; Format1 = "~n~2|~w~w~w~n~4|~0f~w~0f~w~0f~n",
              Args1 = [ "Для ", Alias1, " = Начисленная сумма - ПН",
                      AmountAll, " = ", AmountAll - IncomeTax, " - ", -IncomeTax
                      ]
            ),
            ( AmountExcl > 0 ->
              Format2 = "~2|~w~n~4|~0f~w~0f~w~0f~n",
              Args2 = [ "Исключаемый заработок = Исключаемая сумма - Исключаемый ПН",
                        AmountExcl + IncomeTaxExcl, " = ", AmountExcl," - ", -IncomeTaxExcl
                      ]
            ; Format2 = "", Args2 = []
            ),
            ( AmountExcl > 0 ->
              Format3 = "~2|~w~w~w~n~4|~0f~w~0f~w~0f~n",
              Args3 = [ "Для ", Alias1, " = Заработок - Исключаемый заработок",
                        ForAlimony, " = ", AmountAll, " - ",  AmountExcl + IncomeTaxExcl
                      ]
            ; Format3 = "", Args3 = []
            ),
            atomic_list_to_string([Format1, Format2, Format3], Format),
            append([Args1, Args2, Args3], Args),
            format(string(ProtText), Format, Args),
            !.
        % Исполнительные листы (расчетная сумма)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcFormula-1, pCheckRest-1],
            Types = [_, Type2],
            Sections = [_, Section2],
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            % сумма БВ
            get_min_wage(Scope, DateCalcTo, BV),
            % БПМ
            get_budget(Scope, DateCalcTo, BudgetConst),
            prot_alias(Scope, "алиментов", Alias1),
            ( Scope = wg_fee_alimony
             ->
              format( string(ProtText1),
                      "~n~2|~w~0f~n~2|~w~0f~n~n~2|~w~w~w~n~4|~w~15|~w~27|~w~55|~w~61|~w~n",
                      [ "Базовая величина (БВ) = ", BV,
                        "Бюджет прожиточного минимума (БПМ) = ", BudgetConst,
                        "Исполнительные листы (расчетная сумма ", Alias1, "):",
                        "Ключ", "Сумма", "Формула", "Дети", "Примечание"  ] )
            ;
              format( string(ProtText1),
                      "~n~2|~w~0f~n~n~2|~w~w~w~n~4|~w~15|~w~27|~w~55|~w~n",
                      [ "Базовая величина (БВ) = ", BV,
                        "Исполнительные листы (расчетная сумма ", Alias1, "):",
                        "Ключ", "Сумма", "Формула", "Примечание"  ] )
            ),
            findall( ProtDetText2,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText2),
            ProtDetTextList2),
            atomic_list_to_string(ProtDetTextList2, ProtText2),
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pAlimonyAmount-AlimonyAmount ]),
            format( string(ProtText3),
                    "~` t~w~14+ ~0f~n",
                    ["Итого:", AlimonyAmount] ),
            atomic_list_to_string([ProtText1, ProtText2, ProtText3], ProtText),
            !.
        % Контрольная сумма
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCheckRest-1],
            Types = [Type],
            Sections = [Section],
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey,
                            pCheckAmount-CheckAmount,
                            pAmountAll-AmountAll, pRestPercent-RestPercent,
                            pFeeAmount-FeeAmount ]),
            ( FeeAmount > 0
             ->
              format( string(ProtText),
                      "~n~2|~w~n~4|~0f~w~0f~w~0f~w~0f~w~w~0f~n",
                      [ "Контрольная сумма = Заработок - Заработок * Процент остатка - Удержаний",
                        CheckAmount, " = ", AmountAll, " - ",
                        AmountAll, " * ", RestPercent * 100, "%",
                        " - ", FeeAmount ] )
            ; format( string(ProtText),
                      "~n~2|~w~n~4|~0f~w~0f~w~0f~w~0f~w~n",
                      [ "Контрольная сумма = Заработок - Заработок * Процент остатка",
                        CheckAmount, " = ", AmountAll, " - ",
                        AmountAll, " * ", RestPercent * 100, "%" ] )
            ),
            !.
        % Удержания и долги
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcFormula-1, pAddDebt-1, pCalcTotal-1],
            Types = [Type1, Type2, Type3],
            Sections = [Section1, Section2, Section3],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum ]),
            ( \+ AlimonyCharge =:= AlimonySum -> true ; AlimonyCharge =:= 0 ),
            prot_alias(Scope, "Алименты", Alias1),
            prot_alias(Scope, "алиментов", Alias2),
            format( string(ProtText0),
                    "~n~2|~w~w~n~n~2|~w~w~w~n~4|~w~15|~w~27|~w~n",
                    [ Alias1, " к удержанию по частичной сумме",
                      "Исполнительные листы (частичная сумма ", Alias2, "):",
                      "Ключ", "Сумма", "Долг"  ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type3, [
                            Section3, pEmplKey-EmplKey,
                            pAlimonyChargeTotal-AlimonyChargeTotal ]),
            findall( AlimonyDebt,
                     get_param_list(Scope, Type2, [
                                     Section2, pEmplKey-EmplKey,
                                     pAlimonyDebt-AlimonyDebt ]),
            AlimonyDebtList ),
            sum_list(AlimonyDebtList, AlimonyDebtTotal),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~26| ~0f~n",
                    ["Итого:", AlimonyChargeTotal, AlimonyDebtTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        fee_prot(Scope, Types, Sections, _, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcFormula-1, pAddDebt-1, pCalcTotal-1],
            Types = [_, _, _],
            Sections = [_, _, _],
            prot_alias(Scope, "Алименты", Alias1),
            format( string(ProtText),
                    "~n~2|~w~w~n",
                    [ Alias1, " к удержанию по расчетной сумме" ] ),
            !.
        
        % Исполнительные листы (расчетная сумма списания долга)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pDropDebt-2, pDropDebt-3],
            Types = [Type1, Type2],
            Sections = [Section1, Section2],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pDropDebtAmount-DropDebtAmount ]),
            DropDebtAmount > 0,
            format( string(ProtText0),
                    "~n~2|~w~n~4|~w~15|~w~27|~w~39|~w~51|~w~63|~w~n",
                    [ "Исполнительные листы (расчетная сумма списания долга):",
                      "Ключ", "Сумма", "Долг", "Оплачено", "Остаток", "Процент списания долга" ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pDropDebtTotal-DropDebtTotal, pRestDebtTotal-RestDebtTotal,
                            pDebtTotal-DebtTotal, pPaidDebtTotal-PaidDebtTotal]),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~26| ~0f~38| ~0f~50| ~0f~n",
                    ["Итого:", DropDebtTotal, DebtTotal, PaidDebtTotal, RestDebtTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % Исполнительные листы (частичная сумма списания долга)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pDropDebt-3, pDropDebt-5, pCalcTotal-1],
            Types = [Type1, Type2, _],
            Sections = [Section1, Section2, _],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pChargeStep-0 ]),
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pByDropDebtCoef-0 ]),
            prot_alias(Scope, "алиментам", Alias1),
            format( string(ProtText),
                    "~n~2|~w~w~w~n",
                    [ "Долг по ", Alias1, " к удержанию по расчетной сумме" ] ),
            !.
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pDropDebt-3, pDropDebt-5, pCalcTotal-1],
            Types = [Type1, _, Type3],
            Sections = [Section1, _, Section3],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey ]),
            prot_alias(Scope, "алиментам", Alias1),
            format( string(ProtText0),
                    "~n~2|~w~w~w~n~n~2|~w~n~4|~w~15|~w~n",
                    [ "Долг по ", Alias1, " к удержанию по частичной сумме",
                      "Исполнительные листы (частичная сумма списания долга):",
                      "Ключ", "Сумма" ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type3, [
                            Section3, pEmplKey-EmplKey,
                            pDropDebtChargeTotal-DropDebtChargeTotal ]),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~n",
                    ["Итого:", DropDebtChargeTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % расходы по Переводу
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcTransf-_, pCalcTotal-1],
            Types = [_, Type2],
            Sections = [_, Section2],
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pTransfChargeTotal-TransfChargeTotal ]),
            TransfChargeTotal > 0,
            format( string(ProtText0),
                    "~n~2|~w~n~4|~w~11|~w~23|~w~35|~w~47|~w~n",
                    [ "Расходы по переводу:",
                      "", "Сумма", "Перевод", "Расценка", "Получатель" ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            format( string(ProtText2),
                    "~` t~w~10+ ~0f~n",
                    ["Итого:", TransfChargeTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % Итого удержано
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcTotal-1],
            Types = [Type],
            Sections = [Section],
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey,
                            pAllChargeTotal-AllChargeTotal,
                            pAlimonyChargeTotal-AlimonyChargeTotal,
                            pDropDebtChargeTotal-DropDebtChargeTotal,
                            pTransfChargeTotal-TransfChargeTotal ]),
            prot_alias(Scope, "Алименты", Alias1),
            format( string(ProtText),
                    "~n~2|~w~w~w~n~4|~0f~w~0f~w~0f~w~0f~n",
                    [ "Итого удержано = ", Alias1, " + Списание долгов + Расходы по переводу",
                      AllChargeTotal, " = ",
                      AlimonyChargeTotal, " + ", DropDebtChargeTotal, " + ", TransfChargeTotal] ),
                !.
        % возврат пустой строки при неудаче
        fee_prot(_, _, _, _, "") :-
            !.
        
        % Исполнительные листы (пропорция по отработанному времени) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcTab-2],
            Types = [Type],
            Sections = [Section],
            get_param(Scope, in, pNullDate-NullDate),
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pDateBegin-ADateBegin, pDateEnd-ADateEnd0,
                            pTCoef-TCoef, pADays-ADays,
                            pAHoures-AHoures, pTHoures-THoures ]),
            ( ADateEnd0 = NullDate
             -> ADateEnd = ''
            ; ADateEnd = ADateEnd0
            ),
            date_format(ADateBegin, ADateBegin1),
            date_format(ADateEnd, ADateEnd1),
            ( TCoef < 1
             -> TCoef1 = AHoures / THoures
            ; TCoef1 = TCoef ),
            format( string(ProtDetText),
                    "~4|~w~14| ~w~26| ~w~38| ~1f ~w~1f ~w~59| ~w~n",
                    [ AlimonyKey, ADateBegin1, ADateEnd1,
                      AHoures, "ч. (", ADays, "дн.)", TCoef1 ] ),
            true.
        % Исполнительные листы (расчетная сумма) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcFormula-1, pCheckRest-1],
            Types = [Type1, _],
            Sections = [Section1, _],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pAlimonySum-AlimonySum, pByBudget-ByBudget,
                            pWithPrev-WithPrev, pForAlimonyPrev-ForAlimonyPrev,
                            pFormula-Formula, pTCoef-TCoef,
                            pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc ]),
            ( TCoef < 1
             ->
              Desc1 = ["пропорционально"]
            ; Desc1 = []
            ),
            ( ByBudget =:= 1
             ->
              format( string(DescByBudget),
                      "~w ~w",
                      [ LivingWagePerc, "от БПМ" ]),
              Desc2 = [DescByBudget]
            ; Desc2 = []
            ),
            ( WithPrev =:= 1
             ->
              ForAlimonyPrev1 is round(ForAlimonyPrev),
              Desc3 = ["с учетом ПС (", ForAlimonyPrev1, ")"],
              atomic_list_to_string(Desc3, Desc31),
              Desc32 = [Desc31]
            ; Desc32 = []
            ),
            append([Desc1, Desc2, Desc32], DescList),
            atomic_list_to_string(DescList, "; ", Desc),
            ( Scope = wg_fee_alimony
             ->
              format( string(ProtText),
                      "~4|~w~14| ~0f~26| ~w~54| ~0f~60| ~w~n",
                      [ AlimonyKey, AlimonySum, Formula, ChildCount, Desc ] )
            ;
              format( string(ProtText),
                      "~4|~w~14| ~0f~26| ~w~54| ~w~n",
                      [ AlimonyKey, AlimonySum, Formula, Desc ] )
            ),
            true.
        % Удержания и долги - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcFormula-1, pAddDebt-1, pCalcTotal-1],
            Types = [Type1, Type2, _],
            Sections = [Section1, Section2, _],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pAlimonyCharge-AlimonyCharge ]),
            ( get_param_list(Scope, Type2, [
                                Section2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                                pAlimonyDebt-AlimonyDebt ]) -> true
            ; AlimonyDebt = 0
            ),
            format( string(ProtText),
                    "~4|~w~14| ~0f~26| ~0f~n",
                    [ AlimonyKey, AlimonyCharge, AlimonyDebt ] ),
            true.
        % Исполнительные листы (расчетная сумма списания долга) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pDropDebt-2, pDropDebt-3],
            Types = [Type1, _],
            Sections = [Section1, _],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pDropDebtAmount-DropDebtAmount, pRestDebtAmount-RestDebtAmount,
                            pDebtAmount-DebtAmount, pPaidDebtAmount-PaidDebtAmount,
                            pDebtPercent-DebtPercent
                             ]),
            format( string(ProtText),
                    "~4|~w~14| ~0f~26| ~0f~38| ~0f~50| ~0f~62| ~0f~w~n",
                    [ AlimonyKey,
                      DropDebtAmount, DebtAmount, PaidDebtAmount, RestDebtAmount,
                      DebtPercent * 100, "%" ] ),
            true.
        % Исполнительные листы (частичная сумма списания долга) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pDropDebt-3, pDropDebt-5, pCalcTotal-1],
            Types = [_, Type2, _],
            Sections = [_, Section2, _],
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey ]),
            findall( DropDebtCharge,
                     get_param_list(Scope, Type2, [
                                    Section2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                                    pDropDebtCharge-DropDebtCharge ]),
            DropDebtChargeList ),
            sum_list(DropDebtChargeList, DropDebtAmount),
            format( string(ProtText),
                    "~4|~w~14| ~0f~n",
                    [ AlimonyKey, DropDebtAmount ] ),
            true.
        % расходы по Переводу - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            % - для алиментов и штрафов
            memberchk(Scope, [wg_fee_alimony, wg_fee_fine]),
            Sections = [pCalcTransf-_, pCalcTotal-1],
            Types = [Type1, _],
            Sections = [Section1, _],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pTransfCharge-TransfCharge, pRecipient-Recipient,
                            pForTransfAmount-ForTransfAmount, pTransfPercent-TransfPercent ]),
            ( get_data(Scope, kb, gd_contact, [
                        fID-Recipient, fName-Name ]) -> true
            ; Name = ""
            ),
            format( string(ProtText),
                    "~4|~w~10| ~0f~22| ~0f~34| ~2f~w~46| ~w~n",
                    [ "", TransfCharge, ForTransfAmount, TransfPercent, "%", Name ] ),
            true.
        
        /**/
        
        % отладка
        p(Scope):-
            fee_calc_prot(Scope, _, ProtText),
            string_length(ProtText, Len),
            writeln(ProtText),
            writeln(Len),
            !.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-02-09T15:59:53+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "151042959_187967073 wg_data_mix"
          - 
            ADDFUNCTIONKEY: "195362817_166214404 twg_fee_sql"
          - 
            ADDFUNCTIONKEY: "195362816_166214404 twg_fee_in_params"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 204564431_332711886
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_pu_in_params"
      COMMENT: ~
      SCRIPT: | 
        %% twg_pu_in_params
        %  входные параметры для twg_pu
        %
        
        %:- ['../gd_pl_state/date', '../common/lib', '../common/params'].
        
        twg_pu_in_params:-
            Type = in, Section = pCommon,
            member(Scope, [
                wg_pu_3
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать общие входные параметры
            new_param_list(Scope, Type, [
                Section,
                pStartDate-'2012-01-01', pNullDate-'2100-01-01',
                pAvgSalaryRB_ruid-'147105585,1224850260',
                pAvgSalaryRB_Coef-4,
                pKindOfWork_Basic_ruid-'147017405,119619099',       % Основное место работы
                pKindOfWork_ByWork_ruid-'147017406,119619099',      % Внутр. совмещение
                pKindOfWork_ByWorkOuter_ruid-'147041907,453357870', % Внешн. совмещение
                pFeeGroupKey_ruid-'147021001,274788016',          % Начисляются СВ
                pFeeParentSick_ruid-'147025974,403876601',        % Пособия
                pFeeType_SocInsurance_ruid-'147653395,119619099', % Пенсионный
                pTblCal_DocType_Fact_ruid-'187613422,1596169984',     % Табель мастера
                pHourType_Sick_ruid-'147650801,119619099',      % Больничные (Б)
                pHourType_CareOf_ruid-'147650788,119619099',    % Отпуск по уходу за ребенком (ОЖ)
                pHourType_Pregnancy_ruid-'147650787,119619099', % Отпуска по беременности и родам (Р)
                pHourType_MotherDay_ruid-'147650798,119619099'  % День матери (ДМ)
                ]),
            fail.
        twg_pu_in_params:-
            Type = dict, Section = pEDoc,
            member(Scope, [
                wg_pu_3
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % Тип формы
            member([EDocType, EDocCode, EDocName],
                [ [0, "И", "Исходная"],
                  [1, "К", "Корректирующая"],
                  [2, "О", "Отменяющая"],
                  [3, "П", "Назначение пенсии"]
                ]),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section,
                pEDocType-EDocType, pEDocCode-EDocCode, pEDocName-EDocName
                ]),
            fail.
        twg_pu_in_params:-
            Type = dict, Section = pCategory,
            member(Scope, [
                wg_pu_3
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % Код категории
            member([CatType, CatAlias, CatCode],
                [ [1, catRate, "01"],
                  [3, catContract, "03"]
                ]),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section,
                pCatType-CatType, pCatAlias-CatAlias, pCatCode-CatCode
                ]),
            fail.
        twg_pu_in_params:-
            Type = dict, Section = pExperience,
            member(Scope, [
                wg_pu_3
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % Вид деятельности
            member([ExpType, ExpAlias, ExpCode],
                [ [-1, expNone, "-"],
                  [0, expSkip, " "],
                  [1, expPayTemp, "ВЗНОСЫВРЕМ"],
                  [2, expAllowance, "ПОСОБИЕ"],
                  [3, expChildren, "ДЕТИ"],
                  [4, expBonus, "ПРЕМИЯ"],
                  [5, expContract, "ДОГОВОР"],
                  [6, expPension, "ПЕНСИЯ"]
                ]),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section,
                pExpType-ExpType, pExpAlias-ExpAlias, pExpCode-ExpCode
                ]),
            fail.
        twg_pu_in_params.
        
        :- twg_pu_in_params.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-03-11T10:28:42+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 204564432_332711886
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_pu_sql"
      COMMENT: ~
      SCRIPT: | 
        %% twg_pu_sql
        %  спецификации и sql-шаблоны для базы знаний twg_pu
        %
        
        :-  style_check(-atom),
            GetSQL = [gd_pl_ds/5, get_sql/5],
            %dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql([
                    usr_wg_MovementLine/10,
                    usr_wg_KindOfWork/4,
                    usr_wg_PersonalCard/7,
                    gd_people/7,
                    usr_wg_Contract/6,
                    usr_wg_TblCharge/11,
                    usr_wg_FeeType/2,
                    usr_wg_FeeTypeSick/1,
                    usr_wg_FeeType_Dict/3,
                    usr_wg_TblCalLine/7,
                    usr_wg_TblCal_FlexLine/68,
                    usr_wg_HourType/8,
                    usr_wg_ExclDays/8,
                    gd_const_AvgSalaryRB/2,
                    -
                    ]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            memberchk(Functor/Arity, ValidSQL),
            !.
        
        gd_pl_ds(Scope, kb, usr_wg_MovementLine, 10, [
            fEmplKey-integer, fDocumentKey-integer, fFirstMoveKey-integer,
            fMoveYear-integer, fMoveMonth-integer, fDateBegin-date,
            fMovementType-integer, fKindOfWorkKey-integer,
            fIsContract-boolean, fIsPractice-boolean
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_MovementLine(
        %     EmplKey, DocumentKey, FirstMoveKey, MoveYear, MoveMonth, DateBegin,
        %     MovementType, KindOfWorkKey, IsContract, IsPractice)
        get_sql(Scope, kb, usr_wg_MovementLine/10,
        "
        SELECT
          ml.USR$EMPLKEY,
          ml.DOCUMENTKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          EXTRACT(YEAR FROM ml.USR$DATEBEGIN) AS MoveYear,
          EXTRACT(MONTH FROM ml.USR$DATEBEGIN) AS MoveMonth,
          ml.USR$DATEBEGIN,
          ml.USR$MOVEMENTTYPE,
          ml.USR$KINDOFWORKKEY,
          ml.USR$ISCONTRACT,
          m.USR$ISPRACTICE
        FROM
          USR$WG_MOVEMENTLINE ml
        JOIN
          USR$WG_MOVEMENT m
          ON m.DOCUMENTKEY = ml.MASTERKEY
        WHERE
          ml.USR$EMPLKEY = pEmplKey
        ORDER BY
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE,
          ml.USR$DATEBEGIN
        ",
            [
            pEmplKey-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_KindOfWork, 4, [
            fID-integer, fAlias-string,
            fCode-string, fName-string
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_KindOfWork(ID, Alias, Code, Name)
        get_sql(Scope, kb, usr_wg_KindOfWork/4,
        "
        SELECT
          kw.ID,
          CASE kw.ID
            WHEN
              (SELECT id FROM GD_P_GETID(pKindOfWork_Basic_ruid))
                THEN 'kwBasic'
            WHEN
              (SELECT id FROM GD_P_GETID(pKindOfWork_ByWork_ruid))
                THEN 'kwByWork'
            WHEN
              (SELECT id FROM GD_P_GETID(pKindOfWork_ByWorkOuter_ruid))
                THEN 'kwByWorkOuter'
            ELSE
                'unknown'
          END
            AS Alias,
          kw.USR$CODE,
          kw.USR$NAME
        FROM
          USR$WG_KINDOFWORK kw
        ",
            [
            pKindOfWork_Basic_ruid-_,
            pKindOfWork_ByWork_ruid-_,
            pKindOfWork_ByWorkOuter_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_PersonalCard, 7, [
            fEmplKey-integer, fF-string, fI-string, fO-string, fSex-string,
            fPersonalNumber-string, fPensionerDate-date
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_PersonalCard(EmplKey, F, I, O, Sex, PersonalNumber, PensionerDate)
        get_sql(Scope, kb, usr_wg_PersonalCard/7,
        "
        SELECT FIRST(1)
          pc.USR$EMPLKEY,
          REPLACE( UPPER(pc.USR$SURNAME), 'Ё', 'Е' ) AS F,
          UPPER( LEFT(pc.USR$FIRSTNAME, 1) ) AS I,
          UPPER( LEFT(pc.USR$MIDDLENAME, 1) ) AS O,
          pc.USR$SEX,
          pc.USR$INSURANCENUMBER AS PersonalNumber,
          COALESCE(pc.USR$PENSIONERDATE, CAST('pNullDate' AS DATE)) AS PensionerDate
        FROM
          USR$WG_PERSONALCARD pc
        WHERE
          pc.USR$EMPLKEY = pEmplKey
        ORDER BY
          pc.USR$FILLDATE DESC
        ",
            [
            pEmplKey-_, pNullDate-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, gd_people, 7, [
            fEmplKey-integer, fF-string, fI-string, fO-string, fSex-string,
            fPersonalNumber-string, fBirthDay-date
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % gd_people(EmplKey, F, I, O, Sex, PersonalNumber, BirthDay)
        get_sql(Scope, kb, gd_people/7,
        "
        SELECT
          p.CONTACTKEY AS EmplKey,
          REPLACE( UPPER(p.SURNAME), 'Ё', 'Е' ) AS F,
          UPPER( LEFT(p.FIRSTNAME, 1) ) AS I,
          UPPER( LEFT(p.MIDDLENAME, 1) ) AS O,
          p.SEX,
          p.PERSONALNUMBER,
          p.BIRTHDAY
        FROM
          GD_PEOPLE p
        WHERE
          p.CONTACTKEY = pEmplKey
        ",
            [
            pEmplKey-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_Contract, 6, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fDateBegin-date, fDateEnd-date,
            fDocumentDate-date, fNumber-string
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_Contract(EmplKey, FirstMoveKey, DateBegin, DateEnd, DocumentDate, Number)
        get_sql(Scope, kb, usr_wg_Contract/6,
        "
        SELECT
          c.USR$EMPLKEY,
          c.USR$FIRSTMOVEKEY,
          c.USR$DATEBEGIN,
          c.USR$DATEEND,
          d.DOCUMENTDATE,
          d.NUMBER
        FROM
          USR$WG_CONTRACT c
        JOIN
          GD_DOCUMENT d
            ON d.ID = c.DOCUMENTKEY
        WHERE
          c.USR$EMPLKEY = pEmplKey
        ",
            [
            pEmplKey-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge, 11, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fDOW-float, fHOW-float, fPayPeriod-integer
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_TblCharge(EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, DOW, HOW, PayPeriod)
        get_sql(Scope, kb, usr_wg_TblCharge/11,
        "
        SELECT
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY,
          tch.USR$DOW,
          tch.USR$HOW,
          COALESCE(ft.USR$PAYPERIOD, 0) AS PayPeriod
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_FEETYPE ft
            ON ft.ID = tch.USR$FEETYPEKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          tch.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          tch.USR$DATEBEGIN < 'pDateCalcTo'
          AND
          COALESCE(ft.USR$PAYPERIOD, 0) >= 0
        ORDER BY
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          tch.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType, 2, [
            fFeeGroupKey-integer, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_FeeType(FeeGroupKey, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_FeeType/2,
        "
        SELECT
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY IN
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_ruid))
        ",
            [
            pFeeGroupKey_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeTypeSick, 1, [
            fID-integer
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_FeeTypeSick(ID)
        get_sql(Scope, kb, usr_wg_FeeTypeSick/1,
        "
        SELECT
          ft.ID
        FROM
          USR$WG_FEETYPE ft
        WHERE
          ft.PARENT =
            (SELECT id FROM GD_P_GETID(pFeeParentSick_ruid))
        ",
            [
            pFeeParentSick_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Dict, 3, [
            fID-integer, fAlias-string, fName-string
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_FeeType_Dict(ID, Alias, Name)
        get_sql(Scope, kb, usr_wg_FeeType_Dict/3,
        "
        SELECT
          ft.ID,
          CASE ft.ID
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_SocInsurance_ruid))
                THEN 'ftSocInsurance'
            ELSE
                'unknown'
          END
            AS Alias,
          USR$NAME
        FROM
          USR$WG_FEETYPE ft
        ",
            [
            pFeeType_SocInsurance_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCalLine, 7, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDate-date,
            fDuration-float, fHoureType-integer
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_TblCalLine(EmplKey, FirstMoveKey, CalYear, CalMonth, Date, Duration, HoureType)
        get_sql(Scope, kb, usr_wg_TblCalLine/7,
        "
        SELECT
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tcl.USR$DATE) AS CalYear,
          EXTRACT(MONTH FROM tcl.USR$DATE) AS CalMonth,
          tcl.USR$DATE,
          tcl.USR$DURATION,
          tcl.USR$HOURTYPE
        FROM
          USR$WG_TBLCAL tc
        JOIN
          USR$WG_TBLCALLINE tcl
            ON tcl.MASTERKEY = tc.DOCUMENTKEY
        WHERE
          tc.USR$EMPLKEY = pEmplKey
          AND
          tcl.USR$DATE >= 'pDateCalcFrom'
          AND
          tcl.USR$DATE < 'pDateCalcTo'
        ORDER BY
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          tcl.USR$DATE
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, [
            fFlexType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fS1-variant, fH1-variant, fS2-variant, fH2-variant,
            fS3-variant, fH3-variant, fS4-variant, fH4-variant,
            fS5-variant, fH5-variant, fS6-variant, fH6-variant,
            fS7-variant, fH7-variant, fS8-variant, fH8-variant,
            fS9-variant, fH9-variant, fS10-variant, fH10-variant,
            fS11-variant, fH11-variant, fS12-variant, fH12-variant,
            fS13-variant, fH13-variant, fS14-variant, fH14-variant,
            fS15-variant, fH15-variant, fS16-variant, fH16-variant,
            fS17-variant, fH17-variant, fS18-variant, fH18-variant,
            fS19-variant, fH19-variant, fS20-variant, fH20-variant,
            fS21-variant, fH21-variant, fS22-variant, fH22-variant,
            fS23-variant, fH23-variant, fS24-variant, fH24-variant,
            fS25-variant, fH25-variant, fS26-variant, fH26-variant,
            fS27-variant, fH27-variant, fS28-variant, fH28-variant,
            fS29-variant, fH29-variant, fS30-variant, fH30-variant,
            fS31-variant, fH31-variant
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_TblCal_FlexLine(FlexType, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, S1, H1, ..., S31, H31)
        get_sql(Scope, kb, usr_wg_TblCal_FlexLine/68,
        "
        SELECT
          CASE gd.DOCUMENTTYPEKEY
            WHEN
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Fact_ruid))
                THEN 'fact'
            ELSE
                'unknown'
          END
            AS FlexType,
          tcfl.USR$EMPLKEY,
          tcfl.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth,
          t.USR$DATEBEGIN,
          tcfl.USR$S1, tcfl.USR$H1, tcfl.USR$S2, tcfl.USR$H2,
          tcfl.USR$S3, tcfl.USR$H3, tcfl.USR$S4, tcfl.USR$H4,
          tcfl.USR$S5, tcfl.USR$H5, tcfl.USR$S6, tcfl.USR$H6,
          tcfl.USR$S7, tcfl.USR$H7, tcfl.USR$S8, tcfl.USR$H8,
          tcfl.USR$S9, tcfl.USR$H9, tcfl.USR$S10, tcfl.USR$H10,
          tcfl.USR$S11, tcfl.USR$H11, tcfl.USR$S12, tcfl.USR$H12,
          tcfl.USR$S13, tcfl.USR$H13, tcfl.USR$S14, tcfl.USR$H14,
          tcfl.USR$S15, tcfl.USR$H15, tcfl.USR$S16, tcfl.USR$H16,
          tcfl.USR$S17, tcfl.USR$H17, tcfl.USR$S18, tcfl.USR$H18,
          tcfl.USR$S19, tcfl.USR$H19, tcfl.USR$S20, tcfl.USR$H20,
          tcfl.USR$S21, tcfl.USR$H21, tcfl.USR$S22, tcfl.USR$H22,
          tcfl.USR$S23, tcfl.USR$H23, tcfl.USR$S24, tcfl.USR$H24,
          tcfl.USR$S25, tcfl.USR$H25, tcfl.USR$S26, tcfl.USR$H26,
          tcfl.USR$S27, tcfl.USR$H27, tcfl.USR$S28, tcfl.USR$H28,
          tcfl.USR$S29, tcfl.USR$H29, tcfl.USR$S30, tcfl.USR$H30,
          tcfl.USR$S31, tcfl.USR$H31
        FROM
          GD_DOCUMENT gd
        JOIN
          USR$WG_TBLCAL_FLEXLINE tcfl
            ON gd.ID = tcfl.DOCUMENTKEY
        JOIN
          USR$WG_TBLCAL_FLEX tcf
            ON tcf.DOCUMENTKEY = tcfl.MASTERKEY
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tcf.USR$TOTALDOCKEY
        WHERE
          tcfl.USR$EMPLKEY = pEmplKey
          AND
          t.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDateCalcTo'
         ORDER BY
           tcfl.USR$EMPLKEY,
           tcfl.USR$FIRSTMOVEKEY,
           t.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pTblCal_DocType_Fact_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_HourType, 8, [
            fID-integer, fCode-string, fDigitCode-string,
            fDiscription-string, fIsWorked-integer, fShortName-string,
            fAlias-string, fForPU3-boolean
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_HourType(ID, Code, DigitCode, Description, IsWorked, ShortName, Alias, ForPU3)
        get_sql(Scope, kb, usr_wg_HourType/8,
        "
        SELECT
          ht.ID,
          ht.USR$CODE,
          ht.USR$DIGITCODE,
          ht.USR$DISCRIPTION,
          ht.USR$ISWORKED,
          ht.USR$SHORTNAME,
          CASE ht.ID
            WHEN
              (SELECT id FROM GD_P_GETID(pHourType_Sick_ruid))
                THEN 'htSick'
            WHEN
              (SELECT id FROM GD_P_GETID(pHourType_CareOf_ruid))
                THEN 'htCareOf'
            WHEN
              (SELECT id FROM GD_P_GETID(pHourType_Pregnancy_ruid))
                THEN 'htPregnancy'
            WHEN
              (SELECT id FROM GD_P_GETID(pHourType_MotherDay_ruid))
                THEN 'htMotherDay'
            ELSE
                'unknown'
          END
            AS Alias,
          ht.USR$FORPU3
        FROM
          USR$WG_HOURTYPE ht
        ",
            [
            pHourType_Sick_ruid-_,
            pHourType_CareOf_ruid-_,
            pHourType_Pregnancy_ruid-_,
            pHourType_MotherDay_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_ExclDays, 8, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fExclType-string, fOrderType-integer, fHourType-integer,
            fExclWeekDay-integer,
            fFromDate-date, fToDate-date
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % usr_wg_ExclDays(EmplKey, FirstMoveKey, ExclType, OrderType, HourType, ExclWeekDay, FromDate, ToDate)
        get_sql(Scope, kb, usr_wg_ExclDays/8,
        "
        SELECT
          EmplKey, FirstMoveKey, ExclType, OrderType, HourType, ExclWeekDay, FromDate, ToDate
        FROM (
        SELECT
          ld.USR$EMPLKEY AS EmplKey,
          ld.USR$FIRSTMOVEKEY AS FirstMoveKey,
          'LEAVEDOCLINE' AS ExclType,
          t.USR$TYPE AS OrderType,
          t.USR$HOURTYPE AS HourType,
          0 AS ExclWeekDay,
          CAST( IIF(ld.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', ld.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(ld.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(ld.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', ld.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_LEAVEDOCLINE ld
        JOIN USR$WG_VACATIONTYPE t ON t.ID = ld.USR$VACATIONTYPEKEY
        WHERE ld.USR$EMPLKEY = pEmplKey
          AND ld.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(ld.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        UNION ALL
        SELECT
          s.USR$EMPLKEY AS EmplKey,
          0 AS FirstMoveKey,
          'SICKLIST' AS ExclType,
          t.USR$CALCTYPE AS OrderType,
          (SELECT id FROM GD_P_GETID(pHourType_Sick_ruid)) AS HourType,
          0 AS ExclWeekDay,
          CAST( IIF(s.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', s.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(s.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(s.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', s.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_SICKLISTJOURNAL s
        JOIN USR$WG_ILLTYPE t ON t.ID = s.USR$ILLTYPEKEY
        WHERE s.USR$EMPLKEY = pEmplKey
          AND s.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(s.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        UNION ALL
        SELECT
          kdl.USR$EMPLKEY AS EmplKey,
          0 AS FirstMoveKey,
          'KINDDAYLINE' AS ExclType,
          0 AS OrderType,
          (SELECT id FROM GD_P_GETID(pHourType_MotherDay_ruid)) AS HourType,
          kdl.USR$DAY AS ExclWeekDay,
          CAST( IIF(kdl.USR$DATEBEGIN < 'pDateCalcFrom', 'pDateCalcFrom', kdl.USR$DATEBEGIN) AS DATE) AS FromDate,
          CAST( IIF(kdl.USR$DATEEND IS NULL, 'pDateCalcTo', IIF(kdl.USR$DATEEND > 'pDateCalcTo', 'pDateCalcTo', kdl.USR$DATEEND)) AS DATE) AS ToDate
        FROM USR$WG_KINDDAYLINE kdl
        WHERE kdl.USR$EMPLKEY = pEmplKey
          AND kdl.USR$DATEBEGIN <= 'pDateCalcTo'
          AND COALESCE(kdl.USR$DATEEND, 'pDateCalcTo') >= 'pDateCalcFrom'
        )
        ORDER BY
          ExclWeekDay,
          FromDate
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pHourType_Sick_ruid-_, pHourType_MotherDay_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
        gd_pl_ds(Scope, kb, gd_const_AvgSalaryRB, 2, [
            fConstDate-date, fAvgSalaryRB-float
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        % gd_const_AvgSalaryRB(ConstDate, AvgSalaryRB)
        get_sql(Scope, kb, gd_const_AvgSalaryRB/2,
        "
        SELECT
          cv.CONSTDATE,
          CAST(cv.CONSTVALUE AS DECIMAL(15,4)) AS AvgSalaryRB
        FROM
          GD_CONSTVALUE cv
        JOIN
          GD_CONST c
            ON c.ID  =  cv.CONSTKEY
        WHERE
          cv.CONSTKEY = (SELECT id FROM GD_P_GETID(pAvgSalaryRB_ruid))
        ORDER BY
          cv.CONSTDATE
        ",
            [
            pAvgSalaryRB_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_pu_3
                ]).
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-03-11T10:28:52+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 204564430_332711886
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_pu"
      COMMENT: ~
      SCRIPT: | 
        %% twg_pu
        % Зарплата и Отдел кадров -> Зарплата -> 06. Персонифицированный учёт
        %   ПУ-3
        %
        
        :- style_check([-atom]).
        
        :- dynamic(debug_mode/0).
        % ! при использовании в ТП Гедымин
        % ! комментировать следующую строку
        %:- assertz(debug_mode).
        
        %%% begin debug mode section
        :- if(debug_mode).
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        %#INCLUDE params
        %#INCLUDE wg_data_mix
        :- ['../common/lib', '../common/params', '../common/wg_data_mix'].
        %#INCLUDE twg_pu_sql
        :- [twg_pu_sql].
        %#INCLUDE twg_pu_in_params
        %:- [twg_pu_in_params].
        %%
        
        %% facts
        :-  init_data,
            working_directory(_, 'kb'),
            [
            usr_wg_MovementLine,
            usr_wg_KindOfWork,
            usr_wg_PersonalCard,
            gd_people,
            usr_wg_Contract,
            usr_wg_TblCharge,
            usr_wg_FeeType,
            usr_wg_FeeTypeSick,
            usr_wg_FeeType_Dict,
            usr_wg_TblCalLine,
            usr_wg_TblCal_FlexLine,
            usr_wg_HourType,
            usr_wg_ExclDays,
            gd_const_AvgSalaryRB
            ],
            working_directory(_, '..').
        %%
        
        %% dynamic state
        :- ['kb/param_list'].
        %%
        
        :- else.
        
        :- ps32k_lgt(64, 128, 64).
        
        :- endif.
        %%% end debug mode section
        
        /* реализация - расчет */
        
        % расчет итогового начисления
        pu_calc(Scope, EmplKey) :-
            % - для ПУ
            memberchk(Scope, [wg_pu_3]),
            % для каждого сотрудника
            get_param(Scope, in, pEmplKey-EmplKey),
            % удалить временные данные по расчету
            forall( get_param_list(Scope, temp, [pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, temp, Pairs)
            ),
            % выполнить расчет
            make_rep_periods(Scope, EmplKey),
            make_pu_tab(Scope, EmplKey),
            forall( member(CatType/IsContract-IsPractice, [1/0-0, 3/1-0]),
                    ( make_work_periods(Scope, EmplKey, CatType/IsContract-IsPractice),
                      add_rep_amount(Scope, EmplKey, CatType),
                      add_sick_amount(Scope, EmplKey, CatType),
                      %add_soc_amount(Scope, EmplKey, CatType),
                      make_exp_periods(Scope, EmplKey, CatType)
                    )
            ),
            % найти альтернативу
            fail.
        pu_calc(_, _) :-
            % больше альтернатив нет
            !.
        
        %
        make_rep_periods(Scope, EmplKey) :-
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey,
                            pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo ]),
            make_rep_periods(Scope, EmplKey, DateCalcFrom, DateCalcTo),
            !.
        %
        
        make_rep_periods(_, _, DateCalcTo, DateCalcTo) :-
            !.
        make_rep_periods(Scope, EmplKey, DateCalcFrom, DateCalcTo) :-
            atom_date(DateCalcFrom, date(Y, M, _)),
            new_param_list(Scope, temp, [
                            pEmplKey-EmplKey, pRepYM-Y-M ]),
            date_add(DateCalcFrom, 1, day, DateCalcFrom1),
            !,
            make_rep_periods(Scope, EmplKey, DateCalcFrom1, DateCalcTo).
        
        make_pu_tab(Scope, EmplKey) :-
            get_param_list(Scope, in, [
                            pEmplKey-EmplKey,
                            pTabOption-1 ]),
            abolish(wg_pu_tab/5),
            dynamic(wg_pu_tab/5),
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            member(TabelOption, [tbl_cal_flex, tbl_cal]),
            usr_wg_TblCalLine_mix(Scope, PK, _, Day, _, _, HourType, TabelOption),
            get_data(Scope, kb, usr_wg_HourType, [
                        fID-HourType, fAlias-Alias, fForPU3-ForPU3 ]),
            assertz( wg_pu_tab(Scope, PK, Day, Alias, ForPU3) ),
            fail.
        make_pu_tab(_, _).
        
        %
        make_work_periods(Scope, EmplKey, CatType/IsContract-IsPractice) :-
            findall( FirstMoveKey/Date-MovementType,
                     ( get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                 fDateBegin-Date,
                                 fMovementType-MovementType, fKindOfWorkKey-KindOfWorkKey,
                                 fIsContract-IsContract, fIsPractice-IsPractice ]),
                       memberchk(MovementType, [1, 3]),
                       ( CatType = 1
                        -> \+ get_data(Scope, kb, usr_wg_KindOfWork, [
                                          fID-KindOfWorkKey, fAlias-"kwByWork" ])
                       ; get_data(Scope, kb, usr_wg_KindOfWork, [
                                     fID-KindOfWorkKey, fAlias-"kwByWorkOuter" ])
                       )
                     ),
            MoveList ),
            \+ MoveList = [],
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey,
                            pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo ]),
            move_to_work_periods(MoveList, DateCalcFrom, DateCalcTo, WorkPeriods),
            new_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            !.
        make_work_periods(_, _, _).
        
        %
        move_to_work_periods([], _, _, []).
        move_to_work_periods([DocKey/DateBegin-1], DateCalcFrom, DateCalcTo, [DocKey/WorkBegin-WorkEnd]) :-
            ( DateBegin @< DateCalcFrom
             -> WorkBegin = DateCalcFrom
            ; WorkBegin = DateBegin
            ),
            date_add(DateCalcTo, -1, day, WorkEnd).
        move_to_work_periods([_/_-3, DocKey/DateBegin-3 | MoveTeil], DateCalcFrom, DateCalcTo, MoveRest) :-
            !,
            move_to_work_periods([DocKey/DateBegin-3 | MoveTeil], DateCalcFrom, DateCalcTo, MoveRest).
        move_to_work_periods([_/_-3, DocKey/DateBegin-1 | MoveTeil], DateCalcFrom, DateCalcTo, MoveRest) :-
            !,
            move_to_work_periods([DocKey/DateBegin-1 | MoveTeil], DateCalcFrom, DateCalcTo, MoveRest).
        move_to_work_periods([DocKey/DateBegin-1, DocKeyNext/DateBeginNext-1 | MoveTeil], DateCalcFrom, DateCalcTo, [DocKey/DateBegin-DateEnd | MoveRest]) :-
            date_add(DateBegin, -1, day, DateEnd),
            !,
            move_to_work_periods([DocKeyNext/DateBeginNext-1 | MoveTeil], DateCalcFrom, DateCalcTo, MoveRest).
        
        move_to_work_periods([DocKey/DateBegin-1, DocKey/DateEnd-3 | MoveTeil], DateCalcFrom, DateCalcTo, [DocKey/WorkBegin-WorkEnd | MoveRest]) :-
            ( DateBegin @< DateCalcFrom
             -> WorkBegin = DateCalcFrom
            ; WorkBegin = DateBegin
            ),
            ( DateEnd @< DateCalcTo
             -> \+ DateEnd @< DateCalcFrom,
               WorkEnd = DateEnd
            ; date_add(DateCalcTo, -1, day, WorkEnd)
            ),
            !,
            move_to_work_periods(MoveTeil, DateCalcFrom, DateCalcTo, MoveRest).
        move_to_work_periods([_/_-1, _/_-3 | MoveTeil], DateCalcFrom, DateCalcTo, MoveRest) :-
            !,
            move_to_work_periods(MoveTeil, DateCalcFrom, DateCalcTo, MoveRest).
        
        %
        add_rep_amount(Scope, EmplKey, CatType) :-
            CatType = 1,
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            % взять суммы СВ
            findall( Y-M/ChargeSum,
                      % по начислениям
                    ( get_data(Scope, kb, usr_wg_TblCharge, [
                                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                fCalYear-Y, fCalMonth-M,
                                fDebit-Debit, fCredit-Credit,
                                fFeeTypeKey-FeeTypeKey ]),
                      ChargeSum is Debit - Credit,
                      % для группы СВ
                      get_data(Scope, kb, usr_wg_FeeType, [
                                 fFeeTypeKey-FeeTypeKey ]),
                      % и документов
                      memberchk(FirstMoveKey/_-_, WorkPeriods)
                    ),
            % в список СВ
            ChargeSumList ),
            forall( get_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pRepYM-Y-M ]),
                    ( findall( ChargeSumYM,
                               member(Y-M/ChargeSumYM, ChargeSumList),
                      ChargeSumYMList),
                      sum_list(ChargeSumYMList, FeeAmount0),
                      get_avg_salary_rb(Scope, Y-M, MonthAvgSalary),
                      ( get_param_list(Scope, in, [pCommon, pAvgSalaryRB_Coef-Coef])
                       -> FeeAmountCheck is round(MonthAvgSalary * Coef)
                      ; FeeAmountCheck = FeeAmount0
                      ),
                      ( FeeAmount0 > FeeAmountCheck
                       -> FeeAmount = FeeAmountCheck
                      ; FeeAmount = FeeAmount0
                      ),
                      new_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                      pCatType-CatType,
                                      pYM-Y-M, pFeeAmount-FeeAmount ])
                    )
            ),
            !.
        add_rep_amount(Scope, EmplKey, CatType) :-
            CatType = 3,
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            % по документу
            member(FirstMoveKey/_-_, WorkPeriods),
            % взять суммы
            findall( Y-M/ChargeSum,
                      % по начислениям
                    ( get_data(Scope, kb, usr_wg_TblCharge, [
                                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                fCalYear-Y, fCalMonth-M,
                                fDebit-Debit, fCredit-Credit,
                                fFeeTypeKey-FeeTypeKey ]),
                      ChargeSum is Debit - Credit,
                      % для группы СВ
                      get_data(Scope, kb, usr_wg_FeeType, [
                                 fFeeTypeKey-FeeTypeKey ])
                    ),
            % в список
            ChargeSumList ),
            forall( get_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pRepYM-Y-M ]),
                    ( findall( ChargeSumYM,
                               member(Y-M/ChargeSumYM, ChargeSumList),
                      ChargeSumYMList),
                      sum_list(ChargeSumYMList, FeeAmount),
                      new_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                      pCatType-CatType,
                                      pYM-Y-M, pFeeAmount-FeeAmount ])
                    )
            ),
            fail.
        add_rep_amount(_, _, _).
        
        %
        add_sick_amount(Scope, EmplKey, CatType) :-
            CatType = 1,
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            % взять суммы СВ
            findall( Y-M/ChargeSum,
                      % по начислениям
                    ( get_data(Scope, kb, usr_wg_TblCharge, [
                                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                fCalYear-Y, fCalMonth-M,
                                fDebit-Debit, fCredit-Credit,
                                fFeeTypeKey-FeeTypeKey ]),
                      ChargeSum is Debit - Credit,
                      % для пособий
                      get_data(Scope, kb, usr_wg_FeeTypeSick, [
                                 fID-FeeTypeKey ]),
                      % и документов
                      memberchk(FirstMoveKey/_-_, WorkPeriods)
                    ),
            % в список СВ
            ChargeSumList ),
            forall( get_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pRepYM-Y-M ]),
                    ( findall( ChargeSumYM,
                               member(Y-M/ChargeSumYM, ChargeSumList),
                      ChargeSumYMList),
                      sum_list(ChargeSumYMList, SickAmount),
                      new_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                      pCatType-CatType,
                                      pYM-Y-M, pSickAmount-SickAmount ])
                    )
            ),
            !.
        add_sick_amount(Scope, EmplKey, CatType) :-
            CatType = 3,
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            % по документу
            member(FirstMoveKey/_-_, WorkPeriods),
            % взять суммы
            findall( Y-M/ChargeSum,
                      % по начислениям
                    ( get_data(Scope, kb, usr_wg_TblCharge, [
                                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                fCalYear-Y, fCalMonth-M,
                                fDebit-Debit, fCredit-Credit,
                                fFeeTypeKey-FeeTypeKey ]),
                      ChargeSum is Debit - Credit,
                      % для пособий
                      get_data(Scope, kb, usr_wg_FeeTypeSick, [
                                 fID-FeeTypeKey ])
                    ),
            % в список
            ChargeSumList ),
            forall( get_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pRepYM-Y-M ]),
                    ( findall( ChargeSumYM,
                               member(Y-M/ChargeSumYM, ChargeSumList),
                      ChargeSumYMList),
                      sum_list(ChargeSumYMList, SickAmount),
                      new_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                      pCatType-CatType,
                                      pYM-Y-M, pSickAmount-SickAmount ])
                    )
            ),
            fail.
        add_sick_amount(_, _, _).
        
        %
        make_exp_periods(Scope, EmplKey, CatType) :-
            CatType = 1,
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey,
                            pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo,
                            pTabOption-TabOption ]),
            make_rep_days(DateCalcFrom, DateCalcTo, RepDays),
            form_work_days(RepDays, Scope-EmplKey-CatType, _, WorkPeriods, RepDays1),
            form_skip_days(RepDays1, Scope-EmplKey-_-CatType-TabOption/WorkPeriods, RepDays2),
            RepDays2 = [DayBegin|_],
            form_exp_periods(RepDays2, DayBegin, RepDays3),
            forall( member(ExpPeriod, RepDays3),
                    new_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pFirstMoveKey-_,
                                    pCatType-CatType, pExpPeriod/ExpPeriod ])
            ),
            % найти месяцы с начислением без ВЗНОСЫВРЕМ
            findall( Y-M,
                     ( get_param_list(Scope, temp, [pEmplKey-EmplKey, pRepYM-Y-M]),
                       get_param_list(Scope, temp, [
                                       pEmplKey-EmplKey, pCatType-CatType,
                                       pYM-Y-M, pFeeAmount-FeeAmount ]),
                       FeeAmount > 0,
                       \+ ( get_param_list(Scope, temp, [
                                               pEmplKey-EmplKey,
                                               pCatType-CatType, pExpPeriod/ExpPeriod ]),
                            ExpPeriod = ExpBegin-ExpEnd/ExpType,
                            ExpType = 1,
                            ( atom_date(ExpBegin, date(Y, M, _))
                            ; atom_date(ExpEnd, date(Y, M, _))
                            )
                          )
                     ),
            YMList),
            % для месяцев с начислением без ВЗНОСЫВРЕМ
            forall( ( member(Y-M, YMList),
                      atom_date(ExpBegin, date(Y, M, 1))
                    ),
                      % если есть период ВЗНОСЫВРЕМ
                    ( get_param_list(Scope, temp, [
                                      pEmplKey-EmplKey,
                                      pCatType-CatType, pExpPeriod/ExpPeriod1 ]),
                      ExpPeriod1 = ExpBegin1-ExpEnd1/ExpType1,
                      ExpType1 = 1,
                      ExpBegin @>= ExpBegin1,
                      ExpBegin @=< ExpEnd1
                      % то ничего не делать
                       -> true
                      % если есть период ДЕТИ или пропуск или ПОСОБИЕ
                    ; member(ExpType1, [3, 0, 2]),
                      get_param_list(Scope, temp, [
                                      pEmplKey-EmplKey,
                                      pCatType-CatType, pExpPeriod/ExpPeriod1 ]),
                      ExpPeriod1 = ExpBegin1-ExpEnd1/ExpType1,
                      between(1, 31, TheDay),
                      atom_date(ExpMid, date(Y, M, TheDay)),
                      ExpMid @>= ExpBegin1,
                      ExpMid @=< ExpEnd1
                      % то ПРЕМИЯ
                     ->
                      month_days(Y, M, Days),
                      atom_date(ExpEnd, date(Y, M, Days)),
                      ExpBegin4 = ExpBegin,
                      ( ExpEnd1 @< ExpEnd
                       -> ExpEnd4 = ExpEnd1
                      ; ExpEnd4 = ExpEnd
                      ),
                      ExpType4 = 4,
                      ExpPeriod4 = ExpBegin4-ExpEnd4/ExpType4,
                      new_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-_,
                                      pCatType-CatType, pExpPeriod/ExpPeriod4 ])
                      % иначе далее
                    ; true
                      % иначе исключить начисление
                      /*
                      get_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                      pCatType-CatType,
                                      pYM-Y-M, pFeeAmount-_ ], Pairs),
                      dispose_param_list(Scope, temp, Pairs),
                      new_param_list(Scope, temp, [
                                      pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                      pCatType-CatType,
                                      pYM-Y-M, pFeeAmount-0 ])
                    */
                    )
            ),
            !.
        make_exp_periods(Scope, EmplKey, CatType) :-
            CatType = 3,
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey,
                            pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo,
                            pTabOption-TabOption ]),
            %
            member(FirstMoveKey/_-_, WorkPeriods),
            %
            make_rep_days(DateCalcFrom, DateCalcTo, RepDays),
            form_work_days(RepDays, Scope-EmplKey-CatType, FirstMoveKey, WorkPeriods, RepDays1),
            form_skip_days(RepDays1, Scope-EmplKey-FirstMoveKey-CatType-TabOption/WorkPeriods, RepDays2),
            RepDays2 = [DayBegin|_],
            form_exp_periods(RepDays2, DayBegin, RepDays3),
            forall( member(ExpPeriod, RepDays3),
                    new_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                    pCatType-CatType, pExpPeriod/ExpPeriod ])
            ),
            !.
        make_exp_periods(_, _, _).
        
        % сформировать отчетные дни
        make_rep_days(DateCalcTo, DateCalcTo, []) :-
            !.
        make_rep_days(DateCalcFrom, DateCalcTo, [DateCalcFrom/(-1)|Rest]) :-
            date_add(DateCalcFrom, 1, day, DateCalcFrom1),
            make_rep_days(DateCalcFrom1, DateCalcTo, Rest).
        
        % сформировать статус рабочих дней
        form_work_days([], _, _, _, []).
        % ВЗНОСЫВРЕМ
        form_work_days([Day/_|Teil], Params, FirstMoveKey, WorkPeriods, [Day/State|Rest]) :-
            Params = _-_-CatType,
            %( Day = '2014-08-11', check_point(Day) ; true),
            ( CatType = 1
              -> true
            ; FirstMoveKey1 = FirstMoveKey
            ),
            member(FirstMoveKey1/DateBegin-DateEnd, WorkPeriods),
            Day @>= DateBegin, Day @=< DateEnd,
            ( is_work_amount(Day, Params)
             -> State = 1
            ; State = 0
            ),
            !,
            form_work_days(Teil, Params, FirstMoveKey, WorkPeriods, Rest).
        % не изменять статус
        form_work_days([DayState|Teil], Params, FirstMoveKey, WorkPeriods, [DayState|Rest]) :-
            form_work_days(Teil, Params, FirstMoveKey, WorkPeriods, Rest).
        
        % есть начисление группы СВ
        is_work_amount(Day, Scope-EmplKey-CatType) :-
            atom_date(Day, date(Y, M, _)),
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey, pCatType-CatType,
                            pYM-Y-M, pFeeAmount-FeeAmount ]),
            FeeAmount > 0,
            !.
        
        % сформировать статус пропущенных дней
        form_skip_days([], _, []).
        form_skip_days([Day/State|Teil], Params, [Day/State1|Rest]) :-
            switch_day_state(Day/State, Params, State1),
            !,
            form_skip_days(Teil, Params, Rest).
        form_skip_days([Day/State|Teil], Params, [Day/State|Rest]) :-
            form_skip_days(Teil, Params, Rest).
        
        % переключение статуса дня
        switch_day_state(Day/State, Scope-EmplKey-FirstMoveKey-CatType-TabOption/WorkPeriods, State1) :-
            TabOption = 1,
            ( CatType = 1
             -> true
            ; FirstMoveKey1 = FirstMoveKey
            ),
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey1],
            wg_pu_tab(Scope, PK, Day, Alias, 1),
            memberchk(FirstMoveKey1/_-_, WorkPeriods),
            case_day_state(Day/State, Scope-EmplKey-CatType, Alias, State1),
            !.
        switch_day_state(Day/State, Scope-EmplKey-FirstMoveKey-CatType-TabOption/WorkPeriods, State1) :-
            %( Day = '2014-03-18' -> check_point(Day/State) ; true),
            TabOption = 0,
            ( CatType = 1
             -> true
            ; FirstMoveKey1 = FirstMoveKey
            ),
            get_data(Scope, kb, usr_wg_ExclDays, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey1,
                        fExclType-ExclType, fHourType-HourType,
                        fExclWeekDay-ExclWeekDay,
                        fFromDate-FromDate, fToDate-ToDate ]),
            Day @>= FromDate, Day @=< ToDate,
            get_data(Scope, kb, usr_wg_HourType, [
                        fID-HourType, fAlias-Alias, fForPU3-1 ]),
            ( ExclType = "SICKLIST"
            ; ExclType = "KINDDAYLINE", weekday(Day, ExclWeekDay)
            ; memberchk(FirstMoveKey1/_-_, WorkPeriods)
            ),
            case_day_state(Day/State, Scope-EmplKey-CatType, Alias, State1),
            !.
        switch_day_state(_/State, _, State).
        
        % контрольная точка
        check_point(X) :-
            writeq(check_point(X)), nl,
            true.
        
        % выбор нового статуса дня
        case_day_state(Day/State, Scope-EmplKey-CatType, Alias, State1) :-
           memberchk(Alias, ["htSick", "htPregnancy"]),
           ( \+ State = 2,
             is_skip_amount(Day, Scope-EmplKey-CatType),
             % ПОСОБИЕ
             State1 = 2
           ; State1 = State
           ),
           !.
        % ДЕТИ
        case_day_state(_, _, "htCareOf", 3) :-
           !.
        % пропуск
        case_day_state(_, _, _, 0).
        
        %
        is_skip_amount(Day, Scope-EmplKey-CatType) :-
            atom_date(Day, date(Y, M, _)),
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey, pCatType-CatType,
                            pYM-Y-M, pSickAmount-SickAmount ]),
            SickAmount > 0,
            !.
        
        %
        form_exp_periods([DayEnd/State], DayBegin/State, [DayBegin-DayEnd/State]).
        form_exp_periods([DayEnd/State, DayNext/StateNext | Teil], DayBegin/State, [DayBegin-DayEnd/State | Rest]) :-
            \+ State = StateNext,
            form_exp_periods([DayNext/StateNext | Teil], DayNext/StateNext, Rest).
        form_exp_periods([_ | Teil], DayBegin/State, Rest) :-
            form_exp_periods(Teil, DayBegin/State, Rest).
        
        /* реализация - расширение для клиента */
        
        % загрузка входных данных по сотруднику
        pu_calc_in(Scope, EmplKey, DateBegin, DateEnd, EDocType, TabOption, UNPF, PhoneNum) :-
            % - для ПУ
            memberchk(Scope, [wg_pu_3]),
            Type = in, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pEmplKey-EmplKey,
                pDateBegin-DateBegin, pDateEnd-DateEnd,
                pEDocType-EDocType, pTabOption-TabOption,
                pUNPF-UNPF, pPhoneNum-PhoneNum
                ]),
            !.
        
        % подготовка данных выполнения
        pu_calc_prep(Scope) :-
            % - для ПУ
            memberchk(Scope, [wg_pu_3]),
            Type = in, TypeNextStep = run,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % для каждого сотрудника
            get_param_list(Scope, Type, [
                pEmplKey-_,
                pDateBegin-DateBegin, pDateEnd-DateEnd ],
            Pairs),
            % собрать входные данные
            findall( Pairs0,
                     ( member(Template, [pCommon]),
                       get_param_list(Scope, Type, [Template], Pairs0)
                     ),
            PairsList ),
            append(PairsList, PairsNextStep0),
            % сформировать данные выполнения
            date_add(DateEnd, 1, day, DateCalcTo),
            % записать данные выполнения
            append([ Pairs,
                     [
                       pDateCalcFrom-DateBegin, pDateCalcTo-DateCalcTo
                     ],
                     PairsNextStep0
                   ],
            PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            % найти альтернативу
            fail.
        pu_calc_prep(_) :-
            % больше альтернатив нет
            !.
        
        % выгрузка данных выполнения по сотруднику
        pu_calc_run(Scope, EmplKey) :-
            % - для ПУ
            memberchk(Scope, [wg_pu_3]),
            Type = run, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % взять данные выполнения
            get_param_list(Scope, Type, PK),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % формирование SQL-запросов по сотруднику
        pu_calc_sql(Scope, EmplKey, PredicateName, Arity, SQL) :-
            % - для ПУ
            memberchk(Scope, [wg_pu_3]),
            Type = run, TypeNextStep = query,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, kb, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, kb, Query, SQL0, Params),
              % если данные по сотруднику
            ( memberchk(pEmplKey-_, Params)
             -> true
              % или нет данных
            ; \+ current_predicate(Query)
            ),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-запросу
            PairsNextStep = [pEmplKey-EmplKey, pQuery-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % выгрузка выходных данных по сотруднику
        pu_calc_out(Scope, EmplKey, Result) :-
            % - для ПУ
            memberchk(Scope, [wg_pu_3]),
            Type = run, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % взять данные выполнения
            get_param_list(Scope, Type, PK),
            % оформить ЭД
            once( ( get_data(Scope, kb, usr_wg_PersonalCard, [
                                fEmplKey-EmplKey, fF-F, fI-I, fO-O,
                                fPersonalNumber-PersonalNumber, fPensionerDate-PensionerDate ])
                  ; get_data(Scope, kb, gd_people, [
                                fEmplKey-EmplKey, fF-F, fI-I, fO-O,
                                fPersonalNumber-PersonalNumber ]),
                    PensionerDate = '2100-01-01'
            ) ),
            get_param_list(Scope, in, [
                            pEmplKey-EmplKey, pEDocType-EDocType,
                            pDateBegin-DateBegin, pDateEnd-DateEnd,
                            pUNPF-UNPF, pPhoneNum-PhoneNum ]),
            ( EDocType = 0,
              PensionerDate @>= DateBegin,
              PensionerDate @=< DateEnd
             -> get_param_list(Scope, dict, [pEDocType-1, pEDocCode-EDocCode])
            ; get_param_list(Scope, dict, [pEDocType-EDocType, pEDocCode-EDocCode])
            ),
            get_local_date_time(CurrentDate, _),
            cast_date(CurrentDate, EDocDate),
            once( get_param_list(Scope, temp, [
                                    pEmplKey-EmplKey, pRepYM-EDocYear-_ ])
            ),
            %
            get_param_list(Scope, temp, [
                            pEmplKey-EmplKey,
                            pCatType-CatType, pWorkPeriods-WorkPeriods ]),
            ( CatType = 1
            ; CatType = 3,
              member(FirstMoveKey/_-_, WorkPeriods)
            ),
            ( CatType = 3,
              get_data(Scope, kb, usr_wg_Contract, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDocumentDate-DocumentDate, fNumber-Number
                        ])
             ->
              cast_date(DocumentDate, Date)
            ; Date = " ", Number = " "
            ),
            %
            get_param_list(Scope, dict, [
                            pCategory,
                            pCatType-CatType, pCatCode-CatCode ]),
            %
            findall( FeeAmount,
                     get_param_list(Scope, temp, [
                                     pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                     pCatType-CatType,
                                     pYM-Y-M, pFeeAmount-FeeAmount ]),
            FeeAmountList ),
            sum_list(FeeAmountList, EDocFeeAmount),
            %
            findall( SickAmount,
                     get_param_list(Scope, temp, [
                                     pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                     pCatType-CatType,
                                     pYM-Y-M, pSickAmount-SickAmount ]),
            SickAmountList ),
            sum_list(SickAmountList, EDocSickAmount),
            findall( 1,
                     get_param_list(Scope, temp, [
                                     pEmplKey-EmplKey, pRepYM-Y-M ]),
            RepCountList ),
            sum_list(RepCountList, EDocRepCount),
            %
            findall( 1,
                     ( get_param_list(Scope, temp, [
                                        pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                        pCatType-CatType, pExpPeriod/ExpPeriod ]),
                       ExpPeriod = _-_/ExpType,
                       ExpType >= 0
                     ),
            ExpCountList ),
            sum_list(ExpCountList, EDocExpCount),
            %
            %(EDocFeeAmount + EDocSickAmount) > 0,
            %
            format( string(EDocHeader),
                    "~w~w~w~w~w~w~w~w~w~w~w~w~w~w~w~w~w~w~w~0f~w~0f~w~0f~w~0f~w~w~w~w~w~w~w~n",
                    [ "<ПУ-3=", EDocCode, "=", UNPF, "=", PersonalNumber, "=",
                      F, "=", I, "=", O, "=", CatCode, "=", Number, "=", Date, "= = =",
                      EDocFeeAmount, "=", EDocSickAmount, "=0=0=",
                      EDocRepCount, "=", EDocExpCount, "=",
                      EDocDate, "= =", EDocYear, "=", PhoneNum, "="
                    ] ),
            %
            findall( FeeStr,
                     ( get_param_list(Scope, temp, [pEmplKey-EmplKey, pRepYM-Y-M]),
                       get_param_list(Scope, temp, [
                                       pEmplKey-EmplKey, pCatType-CatType,
                                       pYM-Y-M, pFeeAmount-FeeAmount ]),
                       get_param_list(Scope, temp, [
                                       pEmplKey-EmplKey, pCatType-CatType,
                                       pYM-Y-M, pSickAmount-SickAmount ]),
                       ( get_param_list(Scope, temp, [
                                          pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                          pCatType-CatType, pExpPeriod/ExpPeriod ]),
                         ExpPeriod = ExpBegin-ExpEnd/ExpType,
                         ExpType >= 0,
                         between(1, 31, TheDay),
                         atom_date(ExpBegin1, date(Y, M, TheDay)),
                         ExpBegin1 @>= ExpBegin,
                         ExpBegin1 @=< ExpEnd
                        -> true
                       ),
                       %check_point(Y-M-ExpPeriod),
                       ( CatType = 3
                        -> FeeAmount + SickAmount > 0
                       ; true
                       ),
                       format( string(FeeStr),
                               "~w~0f~w~0f~w~0f~w~n",
                               [ "НЧСЛ=", M, "=",
                                 FeeAmount, "=", SickAmount, "=0=0=0="
                               ] )
                     ),
            FeeStrList ),
            %
            findall( ExpStr,
                     ( get_param_list(Scope, temp, [
                                        pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                                        pCatType-CatType, pExpPeriod/ExpPeriod ]),
                       ExpPeriod = ExpBegin-ExpEnd/ExpType,
                       ExpType > 0,
                       get_param_list(Scope, dict, [pExpType-ExpType, pExpCode-ExpCode]),
                       cast_date(ExpBegin, EDocExpBegin),
                       cast_date(ExpEnd, EDocExpEnd),
                       format( string(ExpStr1),
                               "~w~w~w~w~w~w~w~n",
                               [ "СТАЖ=", EDocExpBegin, "=", EDocExpEnd, "= =",
                                 ExpCode, "= = ="
                             ] ),
                       ( CatType = 3, ExpType = 1
                        ->
                         get_param_list(Scope, dict, [pExpType-5, pExpCode-ExpCode5]),
                         format( string(ExpStr2),
                                 "~w~w~w~w~w~w~w~n",
                                 [ "СТАЖ=", EDocExpBegin, "=", EDocExpEnd, "= =",
                                   ExpCode5, "= = ="
                               ] )
                       ; ExpStr2 = ""
                       ),
                       atomic_list_to_string([ExpStr1, ExpStr2], ExpStr)
                     ),
            ExpStrList ),
            %
            append([[EDocHeader], FeeStrList, ExpStrList, [">\n"]], ResultList),
            atomic_list_to_string(ResultList, Result),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        cast_date(CurrentDate, EDocDate) :-
            atom_chars(CurrentDate, [Y1, Y2, Y3, Y4, '-', M1, M2, '-', D1, D2]),
            atom_chars(EDocDate, [D1, D2, '/', M1, M2, '/', Y1, Y2, Y3, Y4]),
            !.
        
        % удаление данных по сотруднику
        pu_clean(Scope, EmplKey) :-
            gd_pl_ds(Scope, Type, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            get_sql(Scope, Type, Query, _, Params),
            memberchk(pEmplKey-_, Params),
            del_data(Scope, Type, PredicateName, [fEmplKey-EmplKey]),
            fail.
        pu_clean(Scope, EmplKey) :-
            get_scope_type(Scope-Type),
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            dispose_param_list(Scope, Type, Pairs),
            fail.
        pu_clean(_, _) :-
            !.
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2015-03-11T10:28:21+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "151042959_187967073 wg_data_mix"
          - 
            ADDFUNCTIONKEY: "204564432_332711886 twg_pu_sql"
          - 
            ADDFUNCTIONKEY: "204564431_332711886 twg_pu_in_params"