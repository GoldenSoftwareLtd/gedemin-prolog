%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 195379689_166214404
  Name: "GS.Зарплата.Пролог.Алименты и штрафы"
  Caption: "Алименты и штрафы"
  Version: "1.0.0.72"
  Optional: False
  Internal: True
  MD5: 76EC447D44D614BD31ADB9978B9B1186
Uses: 
  - "151049506_187967073 GS.Зарплата.Пролог.Общие"
Objects: 
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362816_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 195362815_166214404
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee_in_params"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee_in_params
        %  входные параметры для twg_fee
        %
        
        %:- ['../common/lib', '../common/params'].
        
        twg_fee_in_params:-
            Type = in, Section = pCommon,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать общие входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pStartDate-'2012-01-01', pNullDate-'2100-01-01',
                pKindOfWork_Basic_ruid-'147017405,119619099',
                pPayFormSalary_ruid-'147009181,119619099',
                pFeeGroupKey_IncomeTax_ruid-'147021000,274788016',  % Облагается ПН
                pDocType_Total_ruid-'147567052,119619099',
                pTblCal_DocType_Plan_ruid-'147567935,1514418708',
                pTblCal_DocType_Fact_ruid-'187613422,1596169984'
                ]),
            fail.
        twg_fee_in_params:-
            Type = in, Section = pAlimony,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pFeeGroupKey_ruid-'147732349,375143752',           % Для алиментов
                pDocType_Alimony_ruid-'147067079,453357870',       % 04. Алименты
                pVar_BV_ruid-'147021364,256548741',           % БВ
                pVar_ForAlimony_ruid-'147068435,453357870',   % ДЛЯАЛИМЕНТОВ
                pBudget_ruid-'147073065,1224850260', % БПМ
                pFeeType_Alimony_ruid-'147567138,119619099',     % Алименты
                pFeeType_HolidayComp_ruid-'147076028,274788016', % Компенсация отпуска
                pFeeType_IncomeTax_ruid-'147567139,119619099',   % Подоходный
                pFeeType_TransferDed_ruid-'147069035,453357870', % Расходы по переводу
                pFeeType_AlimonyDebt_ruid-'147067786,453357870'  % Долг по алиментам
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 1,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pRestPercent-0.3, % Процент остатка
                pPercent-0.2,     % Процент списания долга
                pCalcDelta-100    % Дельта для расчета при нехватке средств
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 2,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % Процент от БПМ (не менее) от количества детей
            member([ChildQtyCmp, LivingWagePerc],
                [ ['=:=0', 0.0], ['=1', 0.5], ['=2', 0.75], ['>=3', 1.0] ]),
            % записать входные параметры
            new_param_list(Scope, Type,
                [pChildQtyCmp-ChildQtyCmp, pLivingWagePerc-LivingWagePerc]),
            fail.
        twg_fee_in_params.
        
        :- twg_fee_in_params.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-08-15T10:51:33+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362817_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 195362815_166214404
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee_sql"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee_sql
        %  спецификации и sql-шаблоны для базы знаний twg_fee
        %
        
        :-  style_check(-atom),
            GetSQL = [gd_pl_ds/5, get_sql/5],
            %dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql(
                    [
                    usr_wg_MovementLine/15,
                    gd_contact/2,
                    usr_wg_TblCharge/14,
                    usr_wg_TblCharge_Prev/12,
                    usr_wg_TblCharge_AlimonyDebt/9,
                    usr_wg_FeeType/4,
                    usr_wg_FeeType_Taxable/3,
                    usr_wg_FeeType_Dict/6,
                    usr_wg_TblCalLine/7,
                    usr_wg_TblCal_FlexLine/68,
                    usr_wg_FCRate/2,
                    gd_const_budget/2,
                    usr_wg_Variables/2,
                    usr_wg_Alimony/12,
                    usr_wg_TransferType/4,
                    usr_wg_TransferScale/3,
                    usr_wg_AlimonyDebt/8,
                    usr_wg_AlimonyDebt_delete/0,
                    -
                    ]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            member(Functor/Arity, ValidSQL),
            !.
        
        /* база знаний */
        
        gd_pl_ds(Scope, kb, usr_wg_MovementLine, 15, [
            fEmplKey-integer, fDocumentKey-integer, fFirstMoveKey-integer,
            fMoveYear-integer, fMoveMonth-integer, fDateBegin-date,
            fScheduleKey-integer, fMovementType-integer,
            fRate-float, fListNumber-string, fMSalary-float,
            fPayFormKey-integer, fSalaryKey-integer, fTSalary-float, fAvgWageRate-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_MovementLine(EmplKey, DocumentKey, FirstMoveKey,
        %   MoveYear, MoveMonth, DateBegin,
        %   ScheduleKey, MovementType, Rate, ListNumber, MSalary,
        %   PayFormKey, SalaryKey, TSalary, AvgWageRate)
        get_sql(Scope, kb, usr_wg_MovementLine/15,
        "
        SELECT
          ml.USR$EMPLKEY,
          ml.DOCUMENTKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          EXTRACT(YEAR FROM ml.USR$DATEBEGIN) AS MoveYear,
          EXTRACT(MONTH FROM ml.USR$DATEBEGIN) AS MoveMonth,
          ml.USR$DATEBEGIN,
          ml.USR$SCHEDULEKEY,
          ml.USR$MOVEMENTTYPE,
          COALESCE(ml.USR$RATE, 0) AS Rate,
          ml.USR$LISTNUMBER,
          COALESCE(ml.USR$MSALARY, 0) AS MSalary,
          COALESCE(ml.USR$PAYFORMKEY, 0) AS PayFormKey,
          (SELECT id FROM GD_P_GETID(pPayFormSalary_ruid)) AS SalaryKey,
          COALESCE(ml.USR$TSALARY, 0) AS TSalary,
          8 * COALESCE(USR$THOURRATE, 0) AS AvgWageRate
        FROM
          USR$WG_MOVEMENTLINE ml
        JOIN
          USR$WG_KINDOFWORK kw
            ON kw.ID = ml.USR$KINDOFWORKKEY
        WHERE
          ml.USR$EMPLKEY = pEmplKey
          AND
          ml.USR$KINDOFWORKKEY =
            (SELECT id FROM GD_P_GETID(pKindOfWork_Basic_ruid))
        ORDER BY
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE,
          ml.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pPayFormSalary_ruid-_, pKindOfWork_Basic_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, gd_contact, 2, [
            fID-integer, fName-string
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % gd_contact(ID, Name)
        get_sql(Scope, kb, gd_contact/2,
        "
        SELECT
          c.ID, c.NAME
        FROM
          GD_CONTACT c
        WHERE
          c.ID = pEmplKey
        UNION ALL
        SELECT
          c.ID, c.NAME
        FROM
          GD_CONTACT c
        JOIN
          USR$WG_ALIMONY al
            ON al.USR$RECIPIENT = c.ID
        WHERE
          al.USR$EMPLKEY = pEmplKey
        ",
            [
            pEmplKey-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge, 14, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fDOW-float, fHOW-float,
            fTotalYear-integer, fTotalMonth-integer, fTotalDateBegin-date
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCharge(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, DOW, HOW, TotalYear, TotalMonth, TotalDateBegin)
        get_sql(Scope, kb, usr_wg_TblCharge/14,
        "
        SELECT
          tch.USR$DOCUMENTKEY,
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY,
          tch.USR$DOW,
          tch.USR$HOW,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS TotalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS TotalMonth,
          t.USR$DATEBEGIN AS TotalDateBegin
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tch.USR$TOTALDOCKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          tch.USR$TOTALDOCKEY = pTotalDocKey
        ",
            [
            pEmplKey-_, pTotalDocKey-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge_Prev, 12, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fTotalYear-integer, fTotalMonth-integer, fTotalDateBegin-date
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCharge_Prev(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, TotalYear, TotalMonth, TotalDateBegin)
        get_sql(Scope, kb, usr_wg_TblCharge_Prev/12,
        "
        SELECT
          tch.USR$DOCUMENTKEY,
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS TotalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS TotalMonth,
          t.USR$DATEBEGIN AS TotalDateBegin
        FROM
          USR$WG_TBLCHARGE tch
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tch.USR$TOTALDOCKEY
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          t.USR$DATEBEGIN >= 'pDatePrevCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDatePrevCalcTo'
        ",
            [
            pEmplKey-_,
            pDatePrevCalcFrom-_, pDatePrevCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge_AlimonyDebt, 9, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCharge_AlimonyDebt(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_TblCharge_AlimonyDebt/9,
        "
        SELECT
          tch.USR$DOCUMENTKEY,
          tch.USR$EMPLKEY,
          tch.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth,
          tch.USR$DATEBEGIN,
          tch.USR$DEBIT,
          tch.USR$CREDIT,
          tch.USR$FEETYPEKEY
        FROM
          USR$WG_TBLCHARGE tch
        WHERE
          tch.USR$EMPLKEY = pEmplKey
          AND
          tch.USR$DATEBEGIN < 'pDateCalcFrom'
          AND
          tch.USR$FEETYPEKEY =
            (SELECT id FROM GD_P_GETID(pFeeType_AlimonyDebt_ruid))
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pFeeType_AlimonyDebt_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType, 4, [
            fEmplKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer, fAvgDayHOW-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_FeeType(EmplKey, FeeGroupKey, FeeTypeKey, AvgDayHOW)
        get_sql(Scope, kb, usr_wg_FeeType/4,
        "
        SELECT
          pEmplKey AS EmplKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY,
          ft_avg.USR$AVGDAYHOW
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY =
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_ruid))
        ",
            [
            pEmplKey-_, pFeeGroupKey_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Taxable, 3, [
            fEmplKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_FeeType_Taxable(EmplKey, FeeGroupKey, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_FeeType_Taxable/3,
        "
        SELECT
          pEmplKey AS EmplKey,
          ft.USR$WG_FEEGROUPKEY,
          ft.USR$WG_FEETYPEKEY
        FROM
          USR$CROSS179_256548741 ft
        JOIN
          USR$WG_FEETYPE ft_avg
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY
        WHERE
          ft.USR$WG_FEEGROUPKEY =
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_IncomeTax_ruid))
        ",
            [
            pEmplKey-_, pFeeGroupKey_IncomeTax_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Dict, 6, [
            fID-integer, fAlias-string, fName-string,
            fRoundByFeeType-integer, fRoundType-integer, fRoundValue-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_FeeType_Dict(ID, Alias, Name, RoundByFeeType, RoundType, RoundValue)
        get_sql(Scope, kb, usr_wg_FeeType_Dict/6,
        "
        SELECT
          ft.ID,
          CASE ft.ID
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_Alimony_ruid))
                THEN 'ftAlimony'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_HolidayComp_ruid))
                THEN 'ftHolidayComp'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_IncomeTax_ruid))
                THEN 'ftIncomeTax'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_TransferDed_ruid))
                THEN 'ftTransferDed'
            WHEN
              (SELECT id FROM GD_P_GETID(pFeeType_AlimonyDebt_ruid))
                THEN 'ftAlimonyDebt'
            ELSE
                'unknown'
          END
            AS Alias,
          USR$NAME,
          USR$ROUNDBYFEETYPE,
          USR$ROUNDTYPE,
          USR$ROUNDVALUE
        FROM
          USR$WG_FEETYPE ft
        ",
            [
            pFeeType_Alimony_ruid-_,
            pFeeType_HolidayComp_ruid-_,
            pFeeType_IncomeTax_ruid-_,
            pFeeType_TransferDed_ruid-_,
            pFeeType_AlimonyDebt_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCalLine, 7, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDate-date,
            fDuration-float, fHoureType-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCalLine(EmplKey, FirstMoveKey, CalYear, CalMonth, Date, Duration, HoureType)
        get_sql(Scope, kb, usr_wg_TblCalLine/7,
        "
        SELECT
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM tcl.USR$DATE) AS CalYear,
          EXTRACT(MONTH FROM tcl.USR$DATE) AS CalMonth,
          tcl.USR$DATE,
          tcl.USR$DURATION,
          tcl.USR$HOURTYPE
        FROM
          USR$WG_TBLCAL tc
        JOIN
          USR$WG_TBLCALLINE tcl
            ON tcl.MASTERKEY = tc.DOCUMENTKEY
        WHERE
          tc.USR$EMPLKEY = pEmplKey
          AND
          tcl.USR$DATE >= 'pDateCalcFrom'
          AND
          tcl.USR$DATE < 'pDateCalcTo'
        ORDER BY
          tc.USR$EMPLKEY,
          tc.USR$FIRSTMOVEKEY,
          tcl.USR$DATE
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, [
            fFlexType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fS1-variant, fH1-variant, fS2-variant, fH2-variant,
            fS3-variant, fH3-variant, fS4-variant, fH4-variant,
            fS5-variant, fH5-variant, fS6-variant, fH6-variant,
            fS7-variant, fH7-variant, fS8-variant, fH8-variant,
            fS9-variant, fH9-variant, fS10-variant, fH10-variant,
            fS11-variant, fH11-variant, fS12-variant, fH12-variant,
            fS13-variant, fH13-variant, fS14-variant, fH14-variant,
            fS15-variant, fH15-variant, fS16-variant, fH16-variant,
            fS17-variant, fH17-variant, fS18-variant, fH18-variant,
            fS19-variant, fH19-variant, fS20-variant, fH20-variant,
            fS21-variant, fH21-variant, fS22-variant, fH22-variant,
            fS23-variant, fH23-variant, fS24-variant, fH24-variant,
            fS25-variant, fH25-variant, fS26-variant, fH26-variant,
            fS27-variant, fH27-variant, fS28-variant, fH28-variant,
            fS29-variant, fH29-variant, fS30-variant, fH30-variant,
            fS31-variant, fH31-variant
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCal_FlexLine(FlexType, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, S1, H1, ..., S31, H31)
        get_sql(Scope, kb, usr_wg_TblCal_FlexLine/68,
        "
        SELECT
          CASE gd.DOCUMENTTYPEKEY
            WHEN
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Plan_ruid))
                THEN 'plan'
            WHEN
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Fact_ruid))
                THEN 'fact'
            ELSE
                'unknown'
          END
            AS FlexType,
          tcfl.USR$EMPLKEY,
          tcfl.USR$FIRSTMOVEKEY,
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear,
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth,
          t.USR$DATEBEGIN,
          tcfl.USR$S1, tcfl.USR$H1, tcfl.USR$S2, tcfl.USR$H2,
          tcfl.USR$S3, tcfl.USR$H3, tcfl.USR$S4, tcfl.USR$H4,
          tcfl.USR$S5, tcfl.USR$H5, tcfl.USR$S6, tcfl.USR$H6,
          tcfl.USR$S7, tcfl.USR$H7, tcfl.USR$S8, tcfl.USR$H8,
          tcfl.USR$S9, tcfl.USR$H9, tcfl.USR$S10, tcfl.USR$H10,
          tcfl.USR$S11, tcfl.USR$H11, tcfl.USR$S12, tcfl.USR$H12,
          tcfl.USR$S13, tcfl.USR$H13, tcfl.USR$S14, tcfl.USR$H14,
          tcfl.USR$S15, tcfl.USR$H15, tcfl.USR$S16, tcfl.USR$H16,
          tcfl.USR$S17, tcfl.USR$H17, tcfl.USR$S18, tcfl.USR$H18,
          tcfl.USR$S19, tcfl.USR$H19, tcfl.USR$S20, tcfl.USR$H20,
          tcfl.USR$S21, tcfl.USR$H21, tcfl.USR$S22, tcfl.USR$H22,
          tcfl.USR$S23, tcfl.USR$H23, tcfl.USR$S24, tcfl.USR$H24,
          tcfl.USR$S25, tcfl.USR$H25, tcfl.USR$S26, tcfl.USR$H26,
          tcfl.USR$S27, tcfl.USR$H27, tcfl.USR$S28, tcfl.USR$H28,
          tcfl.USR$S29, tcfl.USR$H29, tcfl.USR$S30, tcfl.USR$H30,
          tcfl.USR$S31, tcfl.USR$H31
        FROM
          GD_DOCUMENT gd
        JOIN
          USR$WG_TBLCAL_FLEXLINE tcfl
            ON gd.ID = tcfl.DOCUMENTKEY
        JOIN
          USR$WG_TBLCAL_FLEX tcf
            ON tcf.DOCUMENTKEY = tcfl.MASTERKEY
        JOIN
          USR$WG_TOTAL t
            ON t.DOCUMENTKEY = tcf.USR$TOTALDOCKEY
        WHERE
          tcfl.USR$EMPLKEY = pEmplKey
          AND
          t.USR$DATEBEGIN >= 'pDateCalcFrom'
          AND
          t.USR$DATEBEGIN < 'pDateCalcTo'
         ORDER BY
           tcfl.USR$EMPLKEY,
           tcfl.USR$FIRSTMOVEKEY,
           t.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pTblCal_DocType_Plan_ruid-_, pTblCal_DocType_Fact_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_FCRate, 2, [
            fDate-date, fMinWage-float
            ]).
        % usr_wg_FCRate(Date, MinWage)
        get_sql(wg_fee_alimony, kb, usr_wg_FCRate/2,
        "
        SELECT
          fc.USR$WG_DATE,
          fc.USR$WG_MINWAGE
        FROM
          USR$WG_FCRATE fc
        WHERE
          fc.USR$WG_DATE >= 'pStartDate'
        ORDER BY
          fc.USR$WG_DATE
        ",
            [
            pStartDate-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, gd_const_budget, 2, [
            fConstDate-date, fBudget-float
            ]).
        % gd_const_budget(ConstDate, Budget)
        get_sql(wg_fee_alimony, kb, gd_const_budget/2,
        "
        SELECT
          cv.CONSTDATE,
          CAST(cv.CONSTVALUE AS DECIMAL(15,4)) AS Budget
        FROM
          GD_CONSTVALUE cv
        JOIN
          GD_CONST c
            ON c.ID  =  cv.CONSTKEY
        WHERE
          cv.CONSTDATE >= 'pStartDate'
          AND
          cv.CONSTKEY =
            (SELECT id FROM GD_P_GETID(pBudget_ruid))
        ORDER BY
          cv.CONSTDATE
        ",
            [
            pStartDate-_, pBudget_ruid-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_Variables, 2, [
            fAlias-string, fName-string
            ]).
        % usr_wg_Varuables(Alias, Name)
        get_sql(wg_fee_alimony, kb, usr_wg_Variables/2,
        "
        SELECT
          'vBV' AS Alias,
          USR$NAME
        FROM
          USR$WG_VARIABLES
        WHERE
          ID = (SELECT id FROM GD_P_GETID(pVar_BV_ruid))
        UNION ALL
        SELECT
          'vForAlimony' AS Alias,
          USR$NAME
        FROM
          USR$WG_VARIABLES
        WHERE
          ID = (SELECT id FROM GD_P_GETID(pVar_ForAlimony_ruid))
        ",
            [
            pVar_BV_ruid-_, pVar_ForAlimony_ruid-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_Alimony, 12, [
            fDocKey-integer, fEmplKey-integer,
            fDateBegin-date, fDateEnd-date,
            fDebtSum-float, fFormula-string,
            fTransferTypeKey-integer, fRecipient-integer,
            fRestPercent-float, fChildCount-integer,
            fPercent-float, fLivingWagePerc-float
            ]).
        % usr_wg_Alimony(DocKey, EmplKey, DateBegin, DateEnd, DebtSum, Formula, TransferTypeKey, Recipient, RestPercent, ChildCount, Percent, LivingWagePerc)
        get_sql(wg_fee_alimony, kb, usr_wg_Alimony/12,
        "
        SELECT
          calc.DOCUMENTKEY,
          calc.USR$EMPLKEY,
          calc.USR$DATEBEGIN,
          COALESCE(calc.USR$DATEEND, CAST('pNullDate' AS DATE)) AS DateEnd,
          calc.USR$DEBTSUM,
          calc.USR$FORMULA,
          calc.USR$TRANSFERTYPEKEY,
          calc.USR$RECIPIENT,
          calc.USR$RESTPERCENT,
          calc.USR$CHILDCOUNT,
          calc.USR$PERCENT,
          calc.USR$LIVINGWAGEPERC
        FROM
          USR$WG_ALIMONY calc
        JOIN
          GD_DOCUMENT d
            ON calc.DOCUMENTKEY = d.ID
        WHERE
          d.COMPANYKEY = <COMPANYKEY/>
          AND
          d.DOCUMENTTYPEKEY = (SELECT id FROM GD_P_GETID(pDocType_Alimony_ruid))
          AND
          calc.USR$EMPLKEY = pEmplKey
          AND
          calc.USR$DATEBEGIN < 'pDateCalcTo'
          AND
          COALESCE(calc.USR$DATEEND, 'pNullDate') >= 'pDateCalcFrom'
        ORDER BY
          calc.USR$DATEBEGIN
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_, pDocType_Alimony_ruid-_,
            pNullDate-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_TransferType, 4, [
            fID-integer, fParent-integer,
            fDateBegin-date, fName-string
            ]).
        % usr_wg_TransferType(ID, Parent, DateBegin, Name)
        get_sql(wg_fee_alimony, kb, usr_wg_TransferType/4,
        "
        SELECT
          tt.ID,
          COALESCE(tt.PARENT, 0) AS Parent,
          COALESCE(tt.USR$DATE, current_date) AS DateBegin,
          tt.USR$NAME
        FROM
          USR$WG_TRANSFERTYPE tt
        ORDER BY
          Parent, DateBegin, tt.ID
        ",
            [
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_TransferScale, 3, [
            fTranferTypeKey-integer,
            fStartSum-float, fPercent-float
            ]).
        % usr_wg_TransferScale(TranferTypeKey, StartSum, Percent)
        get_sql(wg_fee_alimony, kb, usr_wg_TransferScale/3,
        "
        SELECT
          ts.USR$TRANSFERTYPEKEY,
          COALESCE(ts.USR$STARTSUM, 0) AS StartSum,
          COALESCE(ts.USR$PERCENT, 0) AS Percent
        FROM
          USR$WG_TRANSFERSCALE ts
        ORDER BY
          ts.USR$TRANSFERTYPEKEY, StartSum
        ",
            [
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_AlimonyDebt, 8, [
            fDocKey-integer, fEmplKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateDebt-date,
            fAlimonyKey-integer, fTotalDocKey-integer, fDebtSum-float
            ]).
        % usr_wg_AlimonyDebt(DocKey, EmplKey, CalYear, CalMonth, DateDebt, AlimonyKey, TotalDocKey, DebtSum)
        get_sql(wg_fee_alimony, kb, usr_wg_AlimonyDebt/8,
        "
        SELECT
          aldebt.DOCUMENTKEY,
          al.USR$EMPLKEY,
          EXTRACT(YEAR FROM aldebt.USR$DATEDEBT) AS CalYear,
          EXTRACT(MONTH FROM aldebt.USR$DATEDEBT) AS CalMonth,
          aldebt.USR$DATEDEBT,
          aldebt.USR$ALIMONYKEY,
          aldebt.USR$TOTALDOCKEY,
          aldebt.USR$DEBTSUM
        FROM
          USR$WG_ALIMONYDEBT aldebt
        JOIN
          USR$WG_ALIMONY al
            ON al.DOCUMENTKEY = aldebt.USR$ALIMONYKEY
        WHERE
          al.USR$EMPLKEY = pEmplKey
          AND
          aldebt.USR$DATEDEBT < 'pDateCalcTo'
          AND
          aldebt.USR$DATEDEBT >=
            (SELECT FIRST 1
               ml.USR$DATEBEGIN
             FROM
               USR$WG_MOVEMENTLINE ml
             WHERE
               ml.USR$EMPLKEY = pEmplKey
               AND
               ml.DOCUMENTKEY = ml.USR$FIRSTMOVE
               AND
               ml.USR$MOVEMENTTYPE = 1
             ORDER BY
               ml.USR$DATEBEGIN DESC
            )
        ORDER BY
          aldebt.USR$DATEDEBT
        ",
            [
            pEmplKey-_, pDateCalcTo-_
            ]).
        
        /* удаление данных */
        
        gd_pl_ds(wg_fee_alimony, cmd, usr_wg_AlimonyDebt_delete, 0, []).
        % usr_wg_AlimonyDebt_delete
        get_sql(wg_fee_alimony, cmd, usr_wg_AlimonyDebt_delete/0,
        "
        DELETE
        FROM
          USR$WG_ALIMONYDEBT aldebt
        WHERE
          COALESCE(aldebt.USR$MANUALDEBT, 0) = 0
          AND
          aldebt.USR$DATEDEBT >= 'pDateCalcFrom'
          AND
          aldebt.USR$DATEDEBT < 'pDateCalcTo'
          AND
          aldebt.USR$ALIMONYKEY IN
            (SELECT al.DOCUMENTKEY FROM USR$WG_ALIMONY al WHERE al.USR$EMPLKEY = pEmplKey)
          AND
          aldebt.USR$DATEDEBT >=
            (SELECT FIRST 1
               ml.USR$DATEBEGIN
             FROM
               USR$WG_MOVEMENTLINE ml
             WHERE
               ml.USR$EMPLKEY = pEmplKey
               AND
               ml.DOCUMENTKEY = ml.USR$FIRSTMOVE
               AND
               ml.USR$MOVEMENTTYPE = 1
             ORDER BY
               ml.USR$DATEBEGIN DESC
            )
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]).
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-10-27T15:47:47+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362815_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee
        % Зарплата и Отдел кадров -> Зарплата -> 02. Прочие доходы, расходы, льготы
        %    04. Алименты
        %    11. Штрафы
        %
        
        :- style_check([-atom]).
        
        :- dynamic(debug_mode/0).
        % ! при использовании в ТП Гедымин
        % ! комментировать следующую строку
        %:- assertz(debug_mode).
        
        %%% begin debug mode section
        :- if(debug_mode).
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        %#INCLUDE params
        %#INCLUDE wg_data_mix
        :- ['../common/lib', '../common/params', '../common/wg_data_mix'].
        %#INCLUDE twg_fee_sql
        :- [twg_fee_sql].
        %#INCLUDE twg_fee_in_params
        %:- [twg_fee_in_params].
        %%
        
        %% facts
        :-  init_data,
            working_directory(_, 'kb'),
            [
            usr_wg_MovementLine,
            gd_contact,
            usr_wg_TblCharge,
            usr_wg_TblCharge_Prev,
            usr_wg_TblCharge_AlimonyDebt,
            usr_wg_FeeType,
            usr_wg_FeeType_Taxable,
            usr_wg_FeeType_Dict,
            usr_wg_TblCalLine,
            usr_wg_TblCal_FlexLine,
            usr_wg_FCRate,
            gd_const_budget,
            usr_wg_Variables,
            usr_wg_Alimony,
            usr_wg_TransferType,
            usr_wg_TransferScale,
            usr_wg_AlimonyDebt
            ],
            working_directory(_, '..').
        %%
        
        %% dynamic state
        :- ['kb/param_list'].
        %%
        
        :- ps32k_lgt(64, 128, 64).
        
        :- endif.
        %%% end debug mode section
        
        /* реализация - расчет */
        
        % расчет итогового начисления
        fee_calc(Scope) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            % для каждого сотрудника
            get_param(Scope, in, pEmplKey-EmplKey),
            % выполнить расчет
            fee_calc(Scope, EmplKey),
            % найти альтернативу
            fail.
        fee_calc(_) :-
            % больше альтернатив нет
            !.
        
        % выполнить расчет
        fee_calc(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, begin-Section),
            % удалить временные данные по расчету
            forall( get_param(Scope, Type, pEmplKey-EmplKey, Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % расчет табеля
            calc_tab(Scope, EmplKey),
            % расчет суммы
            calc_amount(Scope, EmplKey),
            % расчет формулы
            calc_formula(Scope, EmplKey),
            % расчет расходов по переводу
            calc_transf(Scope, EmplKey, 1),
            % контроль остатка
            check_rest(Scope, EmplKey),
            % начисление долгов
            add_debt(Scope, EmplKey),
            % списание долгов
            drop_debt(Scope, EmplKey),
            % расчет итога
            calc_total(Scope, EmplKey),
            % записать отладочную информацию
            param_list_debug(Scope, end-Section),
            !.
        
        % расчет табеля
        calc_tab(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcTab,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % последний прием на работу
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_last_hire(Scope, PK, DateIn),
            % начало итогового месяца
            get_param_list(Scope, in, [pEmplKey-EmplKey, pDateBegin-DateBegin]),
            atom_date(DateBegin, date(YearBegin, MonthBegin, _)),
            month_days(YearBegin, MonthBegin, DaysBegin),
            % окончание итогового месяца
            atom_date(DateEnd, date(YearBegin, MonthBegin, DaysBegin)),
            % последний прием на работу до окончания итогового месяца
            DateIn @=< DateEnd,
            % Общий табель за итоговый месяц
            atom_date(DateBegin, date(Y, M, _)),
            calc_month_tab(Scope, PK, Y-M, TabDays),
            sum_days_houres(TabDays, TDays, THoures),
            % спецификация временных данных
            append([ [Section-1], PK,
                     [pYM-Y-M, pTDays-TDays, pTHoures-THoures] ],
                        TabPairs),
            % добавить временные данные
            new_param_list(Scope, Type, TabPairs),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fDateBegin-ADateBegin, fDateEnd-ADateEnd ],
            % спецификация временных данных
            append([ [Section-2], PK,
                     [pAlimonyKey-AlimonyKey, pDateBegin-ADateBegin, pDateEnd-ADateEnd],
                     [pYM-Y-M, pTCoef-TCoef,
                      pADays-ADays, pAHoures-AHoures,
                      pTDays-TDays, pTHoures-THoures] ],
                        AlimonyPairs),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % посчитать Дни и Часы для периода действия алиментов
                      sum_days_houres(TabDays, ADays, AHoures, ADateBegin, ADateEnd),
                      % вычислить Коеффициент от Общего табеля
                      catch( TCoef is AHoures / THoures, _, TCoef = 1.0),
                      % добавить временные данные
                      new_param_list(Scope, Type, AlimonyPairs)
                    )
                  ),
            !.
        
        % расчет суммы
        calc_amount(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcAmount,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация Начислений по Предыдущему периоду
            SpecTblChargePrev = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fDebit-Debit, fCredit-Credit,
                        fFeeTypeKey-FeeTypeKey ],
            % спецификация временных данных
            AmountPaidPairs = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyAmountPaid-AlimonyAmountPaid,
                        pAlimonyAmount-AlimonyAmount, pAlimonyCoef-AlimonyCoef ],
            SumPaidPairs = [
                        Section-5, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonySumPaid-AlimonySumPaid,
                        pAlimonySum-AlimonySum, pAlimonyCoef-AlimonyCoef ],
            % сумма по Предыдущему периоду
            calc_amount(Scope, EmplKey, 1),
            get_param_list(Scope, Type, [
                            Section-1, pEmplKey-EmplKey,
                            pForAlimony-ForAlimony1 ]),
            % сумма по Предыдущему периоду
            % где дата Зачисления соответствует Текущему периоду
            calc_amount(Scope, EmplKey, 2),
            get_param_list(Scope, Type, [
                            Section-2, pEmplKey-EmplKey,
                            pForAlimony-ForAlimony2 ]),
            % Коэффициент для Переходящего начисления
            catch( AlimonyCoef is ForAlimony1 / ForAlimony2, _, AlimonyCoef = 0.0 ),
            % начислено Алиментов по Предыдущему периоду
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-"ftAlimony" ]),
            findall( AlimonySum,
                     ( get_data(Scope, kb, usr_wg_TblCharge_Prev, SpecTblChargePrev),
                       AlimonySum is Credit - Debit
                     ),
            AlimonySumList),
            sum_list(AlimonySumList, AlimonyAmount),
            % Оплачено по Предыдущему периоду
            AlimonyAmountPaid is round(AlimonyAmount * AlimonyCoef) * 1.0,
            % сумма по Текущему периоду
            calc_amount(Scope, EmplKey, 3),
            % добавить временные данные
            new_param_list(Scope, Type, AmountPaidPairs),
            forall( get_data(Scope, kb, usr_wg_TblCharge_Prev, SpecTblChargePrev),
                    ( AlimonySum is Credit - Debit,
                      AlimonySumPaid is round(AlimonySum * AlimonyCoef) * 1.0,
                      % добавить временные данные
                      new_param_list(Scope, Type, SumPaidPairs)
                    )
                  ),
            !.
        %
        calc_amount(Scope, EmplKey, Shape) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcAmount,
            % собрать начисления по Группе начислений
            fee_group_charges(Scope, EmplKey, Charges, Shape),
            % Общая сумма
            charges_sum(Charges, AmountAll),
            % Исключаемые начисления
            charges_excl(Scope, EmplKey, Charges, ChargesExcl),
            % Исключаемая сумма
            charges_sum(ChargesExcl, [debit(1), credit(0)], AmountExcl),
            % Подоходный налог (ПН)
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-IncomeTaxFeeType, fAlias-"ftIncomeTax" ]),
            charges_sum(Charges, [debit(0), credit(1)], [IncomeTaxFeeType], IncomeTax),
            % собрать виды начислений, облагаемые ПН
            findall( TaxableFeeType,
                     get_data(Scope, kb, usr_wg_FeeType_Taxable, [
                                 fEmplKey-EmplKey, fFeeTypeKey-TaxableFeeType ]),
            TaxableFeeTypeList),
            % Облагаемая ПН сумма
            charges_sum(Charges, [debit(1), credit(0)], TaxableFeeTypeList, AmountTaxable),
            % Коеффициент ПН
            ( AmountTaxable =:= 0, IncomeTaxCoef = 0
            ; IncomeTaxCoef is IncomeTax / AmountTaxable
            ),
            % Облагаемая ПН Исключаемая сумма
            charges_sum(ChargesExcl, [debit(1), credit(0)], TaxableFeeTypeList, AmountTaxableExcl),
            % Исключаемый ПН
            IncomeTaxExcl is round(AmountTaxableExcl * IncomeTaxCoef) * 1.0,
            % Расчетная сумма = Общая сумма - Исключаемая сумма - Исключаемый ПН
            ForAlimony is round(AmountAll - AmountExcl - IncomeTaxExcl) * 1.0,
            % спецификация временных данных
            AmountPairs = [
                        Section-Shape, pEmplKey-EmplKey, pForAlimony-ForAlimony,
                        pAmountAll-AmountAll, pAmountExcl-AmountExcl, pIncomeTaxExcl-IncomeTaxExcl,
                        pAmountTaxableExcl-AmountTaxableExcl, pIncomeTaxCoef-IncomeTaxCoef,
                        pIncomeTax-IncomeTax, pAmountTaxable-AmountTaxable ],
            % добавить временные данные
            new_param_list(Scope, Type, AmountPairs),
            !.
        
        % расчет формулы
        calc_formula(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcFormula,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fFormula-Formula,
                        fChildCount-_, fLivingWagePerc-_ ],
            % спецификации временных данных
            FormulaPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-_,
                        pAlimonySum-_,  pByBudget-_,
                        pFormula-Formula, pForAlimony-_, pBV-BV,
                        pResult-_, pEval-_, pTCoef-_,
                        pChildCount-_, pLivingWagePerc-_,
                        pBudgetConst-BudgetConst, pBudgetPart-_ ],
            % сумма БВ
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            get_min_wage(Scope, DateCalcTo, BV),
            % БПМ
            get_budget(Scope, DateCalcTo, BudgetConst),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % получить сумму по формуле
                      calc_formula(Scope, EmplKey, SpecAlimony, FormulaPairs),
                      % добавить временные данные
                      new_param_list(Scope, Type, FormulaPairs)
                    )
                  ),
            !.
        
        % расчет формулы по спецификациям
        calc_formula(Scope, EmplKey, SpecAlimony, FormulaPairs) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcFormula,
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fFormula-Formula,
                        fChildCount-ChildCount0, fLivingWagePerc-LivingWagePerc0 ],
            % сопоставить с данными по умолчанию
            LivingWagePerc1 is LivingWagePerc0 / 100,
            fit_data(Scope,
                        [pChildCount-ChildCount0, pLivingWagePerc-LivingWagePerc1],
                        [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc]),
            % спецификация временных данных
            FormulaPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-AlimonySum,
                        pAlimonySum-AlimonySum, pByBudget-ByBudget,
                        pFormula-Formula, pForAlimony-ForAlimony, pBV-BV,
                        pResult-Result, pEval-Eval, pTCoef-TCoef,
                        pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc,
                        pBudgetConst-BudgetConst, pBudgetPart-BudgetPart ],
            % сумма Для алиментов
            get_data(Scope, kb, usr_wg_Variables, [fAlias-"vBV", fName-Var_BV]),
            replace_all(Formula, Var_BV, BV, Formula1),
            get_data(Scope, kb, usr_wg_Variables, [fAlias-"vForAlimony", fName-Var_ForAlimony]),
            get_param_list(Scope, Type, [
                            pCalcAmount-3, pEmplKey-EmplKey, pForAlimony-ForAlimony ]),
            replace_all(Formula1, Var_ForAlimony, ForAlimony, Formula2),
            % Результат
            replace_all(Formula2, ",", ".", Formula3),
            ( catch( term_to_atom(Expr, Formula3), _, fail ),
              catch( Eval is round(Expr) * 1.0, _, fail), FormulaError = 0
            ; Eval = 0.0, FormulaError = 1
            ),
            get_param_list(Scope, Type, [
                            pCalcTab-2, pAlimonyKey-AlimonyKey, pTCoef-TCoef ]),
            Result is round(Eval * TCoef) * 1.0,
            % Часть БПМ
            ( ChildCount > 0 ->
              BudgetPart is round(BudgetConst * LivingWagePerc * TCoef) * 1.0
            ; BudgetPart = 0.0
            ),
            % Оплачено по Предыдущему периоду
            once( ( get_param_list(Scope, Type, [
                                    pCalcAmount-5, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                                    pAlimonySumPaid-AlimonySumPaid ])
                  ; AlimonySumPaid = 0.0
                  )
                ),
            % сумма Удержания c Контролем от БПМ
            ( FormulaError = 0, Result + AlimonySumPaid < BudgetPart ->
              AlimonySum0 is BudgetPart - AlimonySumPaid,
              ByBudget = 1
            ; AlimonySum0 = Result,
              ByBudget = 0
            ),
            get_round_data(Scope, EmplKey, "ftAlimony", RoundType, RoundValue),
            round_sum(AlimonySum0, AlimonySum, RoundType, RoundValue),
            !.
        
        % расчет расходов по переводу
        calc_transf(Scope, EmplKey, Stage) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcTransf,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fEmplKey-EmplKey, fDocKey-AlimonyKey,
                        fTransferTypeKey-TransferTypeKey0, fRecipient-Recipient0 ],
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyCharge-AlimonyCharge ],
            % спецификация параметров списания долгов алиментов
            DropDebtParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCharge-DropDebtCharge ],
            % спецификация временных данных
            TransfPairs = [
                        Section-Stage, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey1,
                        pTransfCharge-TransfCharge, pTransfByGroup-TransfByGroup,
                        pTransferTypeKey-TransferTypeKey, pRecipient-Recipient,
                        pForTransfAmount-ForTransfAmount, pTransfPercent-TransfPercent ],
            % спецификации данных для расходов по переводу
            AlimonyData = [
                        AlimonyKey, TransferTypeKey0, Recipient1, AlimonyCharge ],
            DropDebtData = [
                        AlimonyKey, TransferTypeKey0, Recipient1, DropDebtCharge ],
            AggrTransfData = [
                        AlimonyKey1, TransfByGroup, TransferTypeKey, Recipient,
                        ForTransfAmount, TransfPercent, TransfCharge ],
            % собрать данные для расходов по переводу
            findall( AlimonyData,
                     ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                       TransferTypeKey0 > 0,
                       %( Recipient0 > 0 ->
                       ( Recipient0 > -1 -> % проверка пока отключена
                         Recipient1 = Recipient0
                       ; Recipient1 is -AlimonyKey
                       ),
                       get_param_list(Scope, Type, AlimonyParams)
                     ),
            AlimonyDataList ),
            findall( DropDebtData,
                     ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                       TransferTypeKey0 > 0,
                       %( Recipient0 > 0 ->
                       ( Recipient0 > -1 -> % проверка пока отключена
                         Recipient1 = Recipient0
                       ; Recipient1 is -AlimonyKey
                       ),
                       get_param_list(Scope, Type, DropDebtParams)
                     ),
            DropDebtDataList ),
            append(AlimonyDataList, DropDebtDataList, TransfDataList),
            % агрегировать суммы расходов по переводам
            aggr_fransf(Scope, EmplKey, TransfDataList, AggrTransfDataList),
            % удалить временные данные по переводам
            forall( get_param_list(Scope, Type, [Section-_, pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % для всех расходов по переводам
            forall( ( member(AggrTransfData, AggrTransfDataList),
                      TransfCharge > 0
                    ),
                    % добавить временные данные
                    new_param_list(Scope, Type, TransfPairs)
                  ),
            !.
        
        % агрегировать суммы расходов по переводам
        aggr_fransf(_, _, [], []) :-
            !.
        aggr_fransf(Scope, EmplKey, [TransfData|TransfDataList], [TransfAggrData|TransfAggrDataList]) :-
            aggr_fransf(Scope, EmplKey, TransfData, [TransfData|TransfDataList], TransfDataList1, TransfAggrData),
            !,
            aggr_fransf(Scope, EmplKey, TransfDataList1, TransfAggrDataList).
        %
        aggr_fransf(Scope, EmplKey, TransfData, TransfDataList, TransfDataList1, TransfAggrData) :-
            % спецификации данных для расходов по переводу
            TransfData = [AlimonyKey, TransferTypeKey, Recipient, _],
            TransfAggrData = [
                        AlimonyKey, TransfByGroup, TransferTypeKey, Recipient,
                        ForTransfAmount, TransfPercent, TransfCharge ],
            % собрать суммы по Группе [Документ, Вид перевода, Получатель]
            findall( AlimonyCharge,
                     member([_, TransferTypeKey, Recipient, AlimonyCharge],
                             TransfDataList),
            AlimonyChargeList),
            % Итог по группе
            sum_list(AlimonyChargeList, ForTransfAmount),
            % Признак группы
            ( length(AlimonyChargeList, 1),
              TransfByGroup = 0
            ;
              TransfByGroup = 1
            ),
            % Процент для расхода на перевод
            get_transf_percent(Scope, EmplKey, TransferTypeKey, ForTransfAmount, TransfPercent),
            % Сумма расхода по переводу
            TransfCharge0 is ForTransfAmount * TransfPercent / 100,
            get_round_data(Scope, EmplKey, "ftTransferDed", RoundType, RoundValue),
            round_sum(TransfCharge0, TransfCharge, RoundType, RoundValue),
            % если есть Группа
            ( TransfByGroup = 1,
              % исключить Группу из списка данных
              findall( [AlimonyKey1, TransferTypeKey1, Recipient1, AlimonySum1],
                       ( member([AlimonyKey1, TransferTypeKey1, Recipient1, AlimonySum1], TransfDataList),
                         \+ [TransferTypeKey, Recipient] = [TransferTypeKey1, Recipient1]
                       ),
              TransfDataList1)
            ; % иначе исключить Текущие данные
              selectchk(TransfData, TransfDataList, TransfDataList1)
            ),
            !.
        
        % контроль остатка
        check_rest(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCheckRest,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fRestPercent-RestPercent0 ],
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonySum-AlimonySum ],
            % спецификация параметров контроля
            CheckParams = [
                        pCalcAmount-3, pEmplKey-EmplKey,
                        pAmountAll-AmountAll ],
            % спецификация временных данных
            CheckPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyAmount-AlimonyAmount, pCheckAmount-CheckAmount,
                        pAmountAll-AmountAll, pRestPercent-RestPercent, pRestAmount-RestAmount
                         ],
            AlimonyPairs = [
                        Section-2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCoef-AlimonyCoef,
                        pAlimonySum-AlimonySum, pAlimonyAmount-AlimonyAmount ],
            % Итог по алиментам
            findall( AlimonySum,
                     get_param_list(Scope, Type, AlimonyParams),
            AlimonySumList),
            sum_list(AlimonySumList, AlimonyAmount),
            % Процент остатка
            findall( RestPercent0,
                     get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
            RestPercentList),
            min_list(RestPercentList, RestPercent0),
            RestPercent1 is RestPercent0 / 100,
            fit_data(Scope, [pRestPercent-RestPercent1], [pRestPercent-RestPercent]),
            % сумма Контроля
            get_param_list(Scope, Type, CheckParams),
            RestAmount is round(AmountAll * RestPercent) * 1.0,
            CheckAmount is round(AmountAll - RestAmount) * 1.0,
            % добавить временные данные
            new_param_list(Scope, Type, CheckPairs),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( get_param_list(Scope, Type, AlimonyParams),
                      % вычислить коеффициент от Итога
                      catch( AlimonyCoef is AlimonySum / AlimonyAmount, _, AlimonyCoef = 1.0),
                      % добавить временные данные
                      new_param_list(Scope, Type, AlimonyPairs)
                    )
                  ),
            % Дельта для расчета при нехватке средств
            get_param(Scope, fit, pCalcDelta-CalcDelta), CalcDelta > 0,
            % контроль остатка по сумме Контроля
            check_rest(Scope, EmplKey, CheckAmount, 0, CalcDelta, 0),
            !.
        check_rest(_, _) :-
            !.
        
        % контроль остатка по сумме Контроля
        check_rest(Scope, EmplKey, CheckAmount, CalcDelta0, CalcDelta, CalcSwitch) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCheckRest,
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyCharge-AlimonyCharge ],
            % спецификация параметров переводов
            TransfParams = [
                        pCalcTransf-_, pEmplKey-EmplKey, pTransfCharge-TransfCharge ],
            % спецификация временных данных
            CheckPairs = [
                        Section-3, pEmplKey-EmplKey,
                        pBalance-Balance, pChargeAmount-ChargeAmount,
                        pAlimonyChargeAmount-AlimonyChargeAmount, pTransfAmount-TransfAmount,
                        pReserveAmount-ReserveAmount, pCheckAmount-CheckAmount,
                        pCalcDelta-CalcDelta, pChargeStep-ChargeStep ],
            % сумма к Удержанию
            findall( AlimonyCharge,
                     get_param_list(Scope, Type, AlimonyParams),
            AlimonyChargeList),
            sum_list(AlimonyChargeList, AlimonyChargeAmount),
            findall( TransfCharge,
                     get_param_list(Scope, Type, TransfParams),
            TransfChargeList),
            sum_list(TransfChargeList, TransfAmount),
            ChargeAmount is AlimonyChargeAmount + TransfAmount,
            % сумма Контроля не меньше суммы к Удержанию
            \+ CheckAmount < ChargeAmount,
            % сумма Баланса
            Balance is CheckAmount - ChargeAmount,
            % сумма Резерва
            ReserveAmount is CheckAmount - CalcDelta0 * CalcSwitch,
            % количество Итераций
            ChargeStep is CalcDelta0 / CalcDelta,
            % добавить временные данные
            new_param_list(Scope, Type, CheckPairs),
            !.
        check_rest(Scope, EmplKey, CheckAmount, CalcDelta0, CalcDelta, CalcSwitch) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            % увеличить Дельту
            CalcDelta1 is CalcDelta0 + CalcDelta * CalcSwitch,
            % сумма Резерва
            ReserveAmount0 is CheckAmount - CalcDelta1,
            ( ReserveAmount0 > 0, ReserveAmount = ReserveAmount0
            ; ReserveAmount = 0.0
            ),
            % распределить суммы по Коэффициентам от суммы Резерва
            charge_by_coef(Scope, EmplKey, ReserveAmount),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 2),
            !,
            check_rest(Scope, EmplKey, CheckAmount, CalcDelta1, CalcDelta, 1).
        
        % распределить суммы по Коэффициентам от суммы Резерва
        charge_by_coef(Scope, EmplKey, ReserveAmount) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp,
            % спецификации параметров алиментов
            CalcFormulaParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-_ ],
            CheckRestParams = [
                        pCheckRest-2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCoef-AlimonyCoef ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimony", RoundType, RoundValue),
            % для всех Алиментов
            forall( get_param_list(Scope, Type, CalcFormulaParams, Pairs),
                    ( % вычислить Пропорцию
                      get_param_list(Scope, Type, CheckRestParams),
                      AlimonyCharge0 is ReserveAmount * AlimonyCoef,
                      round_sum(AlimonyCharge0, AlimonyCharge, RoundType, RoundValue),
                      % заменить сумму Удержания
                      replace_list(Pairs,
                                      [pAlimonyCharge-_],
                                      [pAlimonyCharge-AlimonyCharge],
                                          Pairs1),
                      dispose_param_list(Scope, Type, Pairs),
                      new_param_list(Scope, Type, Pairs1)
                    )
                  ),
            !.
        
        % начисление долгов
        add_debt(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pAddDebt,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификации параметров алиментов
            CalcFormulaParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum,
                        pChildCount-ChildCount ],
            % спецификация временных данных
            AddDebtPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyDebt-AlimonyDebt,
                        pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % для всех Алиментов с заполненным Количеством детей
            forall( ( get_param_list(Scope, Type, CalcFormulaParams), ChildCount > 0 ),
                    ( % рассчитать сумму Долга по алиментам
                      AlimonyDebt0 is AlimonySum - AlimonyCharge,
                              % при наличии Долга по алиментам
                      once( ( round_sum(AlimonyDebt0, AlimonyDebt, RoundType, RoundValue),
                              AlimonyDebt > 0,
                              % добавить временные данные
                              new_param_list(Scope, Type, AddDebtPairs)
                            ; % иначе продолжить
                              true
                            )
                          )
                     )
                  ),
            !.
        
        % списание долгов
        drop_debt(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % нет новых долгов
            \+ get_param_list(Scope, Type, [pAddDebt-1, pEmplKey-EmplKey]),
            % последний прием на работу
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_last_hire(Scope, PK, DateIn),
            % есть данные по долгам
            once( ( get_data(Scope, kb, usr_wg_AlimonyDebt, [
                                fEmplKey-EmplKey, fDateDebt-DateDebt ]),
                    DateDebt @>= DateIn
                  )
                ),
            % спецификация параметров Контроля
            CheckRestParams = [
                        pCheckRest-3, pEmplKey-EmplKey, pBalance-Balance ],
            % Контроль Баланса
            get_param_list(Scope, Type, CheckRestParams),
            Balance > 0,
            % Подготовка данных по Cписанию долгов
            drop_debt_prep_data(Scope, EmplKey, DateIn, Balance),
            % Списание долгов
            drop_debt_charge(Scope, EmplKey),
            % Контроль остатка после Списания долгов
            drop_debt_check_rest(Scope, EmplKey),
            !.
        drop_debt(Scope, _) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            !.
        
        % Подготовка данных по Cписанию долгов
        drop_debt_prep_data(Scope, EmplKey, DateIn, Balance) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            CutRoundType = 3,
            % спецификация Алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fPercent-Percent ],
            % спецификация Долгов по алиментам
            SpecAlimonyDebt = [
                        fDocKey-AlimonyDebtKey, fEmplKey-EmplKey,
                        fCalYear-Y, fCalMonth-M, fDateDebt-DateDebt,
                        fAlimonyKey-AlimonyKey, fDebtSum-DebtSum ],
            % спецификация Списания долгов по алиментам
            SpecAlimonyPaid = [
                        fDocKey-AlimonyDebtKey, fEmplKey-EmplKey,
                        fDebit-Debit, fCredit-Credit ],
            % спецификации временных данных
            RestDebtPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pRestSum-RestSum, pDebtSum-DebtSum, pPaidSum-PaidSum,
                        pYM-Y-M, pDateDebt-DateDebt ],
            DropDebtPairs = [
                        Section-2, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey,
                        pDropDebtAmount-DropDebtAmount, pRestDebtAmount-RestDebtAmount,
                        pDebtAmount-DebtAmount, pPaidDebtAmount-PaidDebtAmount,
                        pEvalDebtAmount-EvalDebtAmount,
                        pForAlimony-ForAlimony, pDebtPercent-DebtPercent ],
            TotalDebtPairs = [
                        Section-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance,
                        pDropDebtTotal-DropDebtTotal, pRestDebtTotal-RestDebtTotal,
                        pDebtTotal-DebtTotal, pPaidDebtTotal-PaidDebtTotal,
                        pCalcDelta-CalcDelta, pChargeStep-0 ],
            CoefDebtPairs = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCoef-DropDebtCoef ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % сумма Баланса для Cписания долгов по алиментам
            round_sum(Balance, DropDeptBalance, CutRoundType, RoundValue),
            DropDeptBalance > 0,
            % для всех Долгов по алиментам
            forall( ( get_data(Scope, kb, usr_wg_AlimonyDebt, SpecAlimonyDebt),
                      DateDebt @>= DateIn
                    ),
                    ( % суммировать Cписание долгов
                      findall( PaidSum0,
                               ( get_data(Scope, kb, usr_wg_TblCharge_AlimonyDebt, SpecAlimonyPaid),
                                 PaidSum0 is Credit - Debit
                               ),
                      PaidSumList ),
                      sum_list(PaidSumList, PaidSum),
                      % вычислить Остаток
                      RestSum0 is DebtSum - PaidSum,
                      round_sum(RestSum0, RestSum, CutRoundType, RoundValue),
                      % добавить временные данные
                      once( ( RestSum > 0,
                              new_param_list(Scope, Type, RestDebtPairs)
                            ; true
                            )
                          )
                    )
                  ),
            % для всех Алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % суммировать Долги
                      findall( DebtSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      DebtList ),
                      sum_list(DebtList, DebtAmount),
                      % суммировать Оплату по долгам
                      findall( PaidSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      PaidList ),
                      sum_list(PaidList, PaidDebtAmount),
                      % суммировать Остатки по долгам
                      findall( RestSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      RestList ),
                      sum_list(RestList, RestDebtAmount),
                      % сумма Для алиментов
                      get_param_list(Scope, Type, [
                            pCalcAmount-3, pEmplKey-EmplKey, pForAlimony-ForAlimony ]),
                      % Процент Списания долга
                      Percent1 is Percent / 100,
                      fit_data(Scope, [pPercent-Percent1], [pPercent-DebtPercent]),
                      % расчет Списания долга
                      EvalDebtAmount0 is ForAlimony * DebtPercent,
                      round_sum(EvalDebtAmount0, EvalDebtAmount, RoundType, RoundValue),
                      % сумма Списания долга
                      ( EvalDebtAmount < RestDebtAmount ->
                        DropDebtAmount = EvalDebtAmount
                      ; DropDebtAmount = RestDebtAmount
                      ),
                      % добавить временные данные
                      once( ( DropDebtAmount > 0,
                              new_param_list(Scope, Type, DropDebtPairs)
                            ; true
                            )
                          )
                    )
                  ),
            % Общая сумма Остатков по долгам
            findall( RestDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            RestDebtAmountList ),
            sum_list(RestDebtAmountList, RestDebtTotal),
            RestDebtTotal > 0,
            % Общая сумма Долгов
            findall( DebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            DebtAmountList ),
            sum_list(DebtAmountList, DebtTotal),
            % Общая сумма Оплаты по долгам
            findall( PaidDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            PaidDebtAmountList ),
            sum_list(PaidDebtAmountList, PaidDebtTotal),
            % Общая сумма Списания долга
            findall( DropDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            DropDebtAmountList ),
            sum_list(DropDebtAmountList, DropDebtTotal),
            DropDebtTotal > 0,
            % Дельта для расчета при нехватке средств
            get_param(Scope, fit, pCalcDelta-CalcDelta),
            % добавить временные данные
            new_param_list(Scope, Type, TotalDebtPairs),
            % для всех Списаний долгов по Алиментам
            forall( get_param_list(Scope, Type, DropDebtPairs),
                    ( % рассчитать Пропорцию
                      DropDebtCoef is DropDebtAmount / DropDebtTotal,
                      % добавить временные данные
                      new_param_list(Scope, Type, CoefDebtPairs)
                    )
                  ),
            !.
        
        % Списание долгов
        drop_debt_charge(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            % Итоги для Списания долгов
            TotalDebtParams = [
                        Section-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance, pDropDebtTotal-DropDebtTotal ],
            get_param_list(Scope, Type, TotalDebtParams),
            ( DropDeptBalance < DropDebtTotal,
              ByDropDebtCoef = 1
            ; ByDropDebtCoef = 0
            ),
            % Списание долгов по Балансу
            drop_debt_charge(Scope, EmplKey, DropDeptBalance, ByDropDebtCoef),
            !.
        % Списание долгов по Балансу
        drop_debt_charge(Scope, EmplKey, DropDeptBalance, ByDropDebtCoef) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            % спецификации параметров Долгов по алиментам
            RestDebtParams = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pRestSum-RestSum, pDateDebt-DateDebt ],
            DropDebtParams = [
                        Section-2, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtAmount-DropDebtAmount ],
            CoefDebtParams = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCoef-DropDebtCoef ],
            % спецификация временных данных по Списанию долгов
            DropDebtChargePairs = [
                        Section-5, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pDropDebtCharge-_, pByDropDebtCoef-ByDropDebtCoef ],
            % удалить временные данные по Списанию долгов
            forall( get_param_list(Scope, Type, [Section-5, pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % для всех Долгов по алиментам
            forall( get_param_list(Scope, Type, DropDebtParams),
                    ( % собрать Остатки долгов
                      findall( DateDebt-AlimonyDebtKey-RestSum,
                               get_param_list(Scope, Type, RestDebtParams),
                      RestDebtDataList0 ),
                      % в порядке их образования
                      msort(RestDebtDataList0, RestDebtDataList),
                      % определить Баланс для Списания долгов
                      ( ByDropDebtCoef = 0 ->
                        DropDeptBalance1 is DropDeptBalance
                      ; get_param_list(Scope, Type, CoefDebtParams),
                        DropDeptBalance1 is DropDeptBalance * DropDebtCoef
                      ),
                      round_sum(DropDeptBalance1, DropDeptBalance2, RoundType, RoundValue),
                      % списать Остатки долгов
                      drop_debt_charge(Scope, RestDebtDataList, DropDebtChargePairs, DropDebtAmount, DropDeptBalance2, RoundType, RoundValue)
                    )
                  ),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 3),
            !.
        
        % списать Остатки долгов
        drop_debt_charge(Scope, RestDebtDataList, _, DropDebtAmount, DropDeptBalance, _, _) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            ( RestDebtDataList = [] ; DropDebtAmount =< 0 ; DropDeptBalance =< 0 ),
            !.
        drop_debt_charge(Scope, [_-AlimonyDebtKey-RestSum|RestDebtDataList], DropDebtChargePairs, DropDebtAmount, DropDeptBalance, RoundType, RoundValue) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp,
            % определить сумму Списания
            ( RestSum < DropDebtAmount  ->
              DropDebtCharge0 is RestSum
            ; DropDebtCharge0 is DropDebtAmount
            ),
            ( DropDebtCharge0 < DropDeptBalance  ->
              DropDebtCharge1 is DropDebtCharge0
            ; DropDebtCharge1 is DropDeptBalance
            ),
            round_sum(DropDebtCharge1, DropDebtCharge, RoundType, RoundValue),
            member_list([pAlimonyDebtKey-AlimonyDebtKey, pDropDebtCharge-DropDebtCharge],
                            DropDebtChargePairs),
            % добавить временные данные
            new_param_list(Scope, Type, DropDebtChargePairs),
            % новая спецификация временных данных
            replace_list(DropDebtChargePairs,
                            [pAlimonyDebtKey-AlimonyDebtKey, pDropDebtCharge-DropDebtCharge],
                            [pAlimonyDebtKey-_, pDropDebtCharge-_],
                                DropDebtChargePairs1),
            % новый Баланс для Списания долгов
            DropDebtAmount1 is DropDebtAmount - DropDebtCharge,
            DropDeptBalance1 is DropDeptBalance - DropDebtCharge,
            !,
            drop_debt_charge(Scope, RestDebtDataList, DropDebtChargePairs1, DropDebtAmount1, DropDeptBalance1, RoundType, RoundValue).
        
        % Контроль остатка после Списания долгов
        drop_debt_check_rest(Scope, EmplKey) :-
            Type = temp, NextType = out,
            % спецификация параметров Контроля остатка
            CheckParams = [
                        pCheckRest-1, pEmplKey-EmplKey,
                        pCheckAmount-CheckAmount ],
            % спецификация параметров Общего итога
            TotalParams = [
                        pCalcTotal-1, pEmplKey-EmplKey,
                        pAllChargeTotal-AllChargeTotal ],
            % спецификация параметров Итога Списания долгов
            TotalDebtParams = [
                        pDropDebt-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance,
                        pCalcDelta-CalcDelta, pChargeStep-ChargeStep ],
            % сумма Контроля остатка
            get_param_list(Scope, Type, CheckParams),
            % сумма Итога
            calc_total(Scope, EmplKey),
            get_param_list(Scope, NextType, TotalParams),
            % Контроль остатка
            AllChargeTotal > CheckAmount,
            % уменьшение Баланса для Списания долгов
            get_param_list(Scope, Type, TotalDebtParams, TotalDebtPairs),
            DropDeptBalance1 is DropDeptBalance - CalcDelta,
            DropDeptBalance1 > 0,
            % Списание долгов по Балансу
            drop_debt_charge(Scope, EmplKey, DropDeptBalance1, 1),
            % изменение Итога Списания долгов
            ChargeStep1 is ChargeStep + 1,
            replace_list(TotalDebtPairs,
                            [pDropDeptBalance-DropDeptBalance],
                            [pDropDeptBalance-DropDeptBalance1],
                                TotalDebtPairs1),
            replace_list(TotalDebtPairs1,
                            [pChargeStep-ChargeStep],
                            [pChargeStep-ChargeStep1],
                                TotalDebtPairs2),
            dispose_param_list(Scope, Type, TotalDebtPairs),
            new_param_list(Scope, Type, TotalDebtPairs2),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 3),
            !,
            drop_debt_check_rest(Scope, EmplKey).
        drop_debt_check_rest(_, _) :-
            !.
        
        % расчет итога
        calc_total(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, NextType = out, Section = pCalcTotal,
            % записать отладочную информацию
            param_list_debug(Scope, NextType-Section),
            % спецификации параметров
            AlimonyChargeParams = [
                        pCheckRest-3, pEmplKey-EmplKey,
                        pAlimonyChargeAmount-AlimonyChargeAmount ],
            DropDebtChargeParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pDropDebtCharge-DropDebtCharge ],
            TransfChargeParams = [
                        pCalcTransf-_, pEmplKey-EmplKey,
                        pTransfCharge-TransfCharge ],
            % спецификация временных данных
            TotalPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAllChargeTotal-AllChargeTotal,
                        pAlimonyChargeTotal-AlimonyChargeAmount,
                        pDropDebtChargeTotal-DropDebtChargeTotal,
                        pTransfChargeTotal-TransfChargeTotal ],
            % Итог по Алиментам
            once( ( get_param_list(Scope, Type, AlimonyChargeParams)
                  ; AlimonyChargeAmount = 0
                  )
                ),
            % Итог по Списанию Долгов
            findall( DropDebtCharge,
                     get_param_list(Scope, Type, DropDebtChargeParams),
            DropDebtChargeList),
            sum_list(DropDebtChargeList, DropDebtChargeTotal),
            % Итог по Расходам на переводы
            findall( TransfCharge,
                     get_param_list(Scope, Type, TransfChargeParams),
            TransfChargeList),
            sum_list(TransfChargeList, TransfChargeTotal),
            % Общий итог
            AllChargeTotal is AlimonyChargeAmount + DropDebtChargeTotal + TransfChargeTotal,
            % удалить выходные данные по расчету
            forall( get_param(Scope, NextType, pEmplKey-EmplKey, Pairs),
                    dispose_param_list(Scope, NextType, Pairs) ),
            % добавить выходные данные
            new_param_list(Scope, NextType, TotalPairs),
            !.
        
        /* реализация - сервис */
        
        % взять параметры Округления
        get_round_data(Scope, _, Alias, RoundType, RoundValue) :-
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fAlias-Alias, fRoundByFeeType-1,
                        fRoundType-RoundType, fRoundValue-RoundValue ]),
            !.
        get_round_data(Scope, EmplKey, _, RoundType, RoundValue) :-
            get_param_list(Scope, in, [
                        pEmplKey-EmplKey,
                        pRoundType-RoundType, pRoundValue-RoundValue ]),
            !.
        
        % Процент для расхода на перевод
        get_transf_percent(Scope, EmplKey, TransferTypeKey, Sum, Percent) :-
            get_param_list(Scope, run, [pEmplKey-EmplKey, pDateCalcTo-DateCalcTo]),
            findall( TransferData,
                     get_transf_type(Scope, DateCalcTo, TransferTypeKey, TransferData),
            TransferDataList),
            msort(TransferDataList, TransferDataList1),
            last(TransferDataList1, _-TransferTypeKey1),
            get_transf_scale(Scope, TransferTypeKey1, Sum, Percent),
            !.
        get_transf_percent(_, _, _, _, 0.0) :-
            !.
        
        % Расценки на перевод
        get_transf_type(Scope, DateCalcTo, TransferTypeKey0, DateBegin-TransferTypeKey) :-
            get_data(Scope, kb, usr_wg_TransferType, [
                        fID-TransferTypeKey, fParent-TransferTypeKey0,
                        fDateBegin-DateBegin ]),
            \+ get_data(Scope, kb, usr_wg_TransferType, [
                            fParent-TransferTypeKey]),
            DateBegin @< DateCalcTo.
        get_transf_type(Scope, DateCalcTo, TransferTypeKey0, TransferData) :-
            get_data(Scope, kb, usr_wg_TransferType, [
                        fID-TransferTypeKey1, fParent-TransferTypeKey0 ]),
            get_transf_type(Scope, DateCalcTo, TransferTypeKey1, TransferData).
        
        % Шкала расценок
        get_transf_scale(Scope, TransferTypeKey, Sum, Percent) :-
            findall( StartSum-Percent0,
                     ( get_data(Scope, kb, usr_wg_TransferScale, [
                                 fTranferTypeKey-TransferTypeKey,
                                 fStartSum-StartSum, fPercent-Percent0 ]),
                       Sum >= StartSum ),
            ScaleDataList),
            msort(ScaleDataList, ScaleDataList1),
            last(ScaleDataList1, _-Percent),
            !.
        get_transf_scale(_, _, _, 0.0) :-
            !.
        
        % собрать начисления по Группе начислений
        fee_group_charges(Scope, EmplKey, Charges, Shape) :-
            % спецификация для начислений
            SpecTblCharge =  [
                fEmplKey-EmplKey,
                fCalYear-Y, fCalMonth-M, fDateBegin-DateBegin,
                fDebit-Debit, fCredit-Credit,
                fFeeTypeKey-FeeTypeKey ],
            % спецификация для группы начислений
            SpecFeeType =  [
                fEmplKey-EmplKey, fFeeTypeKey-FeeTypeKey ],
            % спецификация данных начисления
            ChargeData = [
                Y-M, DateBegin, Debit, Credit, FeeTypeKey ],
            % текущее Итоговое начисление
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateBegin-DateBegin0 ]),
            atom_date(DateBegin0, date(Y0, M0, _)),
            % выбор набора данных по виду расчета
            memberchk(Shape-DatasetName, [
                            1-usr_wg_TblCharge_Prev,
                            2-usr_wg_TblCharge_Prev,
                            3-usr_wg_TblCharge ]),
            % взять данные
            findall( ChargeData,
                      % по начислениям
                    ( get_data(Scope, kb, DatasetName, SpecTblCharge),
                      % соответствующего типа
                      get_data(Scope, kb, usr_wg_FeeType, SpecFeeType),
                      % с фильтром для вида расчета
                      ( Shape = 1, Y-M = Y0-M0 ; \+ Shape = 1 ),
                      % и контролем суммы
                      ( \+ Debit =:= 0 ; \+ Credit =:= 0 )
                    ),
            % в список
            Charges ),
            !.
        
        % исключаемые начисления
        charges_excl(Scope, EmplKey, Charges, ChargesExcl) :-
            % спецификация данных начисления
            ChargeData = [
                _-_, DateBegin, _, _, FeeTypeKey ],
            % собрать исключаемые начисления
            findall( ChargeData,
                     ( member(ChargeData, Charges),
                       is_fee_type_excl(Scope, EmplKey, DateBegin, FeeTypeKey)
                     ),
            ChargesExcl ),
            !.
        
        % сумма начислений
        charges_sum(Charges, Amount) :-
            charges_sum(Charges, [], [], 0, Amount),
            !.
        %
        charges_sum(Charges, Options, Amount) :-
            charges_sum(Charges, Options, [], 0, Amount),
            !.
        %
        charges_sum(Charges, Options, ValidFeeTypes, Amount) :-
            charges_sum(Charges, Options, ValidFeeTypes, 0, Amount),
            !.
        %
        charges_sum([], _, _, Amount, Amount) :-
            !.
        charges_sum([Charge|Charges], Options, ValidFeeTypes, Amount0, Amount) :-
            charge_acc(Charge, Options, ValidFeeTypes, Amount0, Amount1),
            !,
            charges_sum(Charges, Options, ValidFeeTypes, Amount1, Amount).
        
        % накопление суммы начислений
        charge_acc(ChargeData, Options, ValidFeeTypes, Amount0, Amount1) :-
            % спецификация данных
            ChargeData = [
                _-_, _, Debit, Credit, FeeTypeKey ],
            % если тип начисления дейсвителен
            ( ValidFeeTypes = [] ; memberchk(FeeTypeKey, ValidFeeTypes) ),
            % установить опции
            ( memberchk(debit(InclDebit), Options) ; InclDebit = 1 ),
            ( memberchk(credit(InclCredit), Options) ; InclCredit = 1 ),
            % и произвести накопление
            Amount1 is Amount0 + Debit * InclDebit - Credit * InclCredit,
            !.
        charge_acc(_, _, _, Amount, Amount) :-
            !.
        
        % тип начисления исключается из расчета
        is_fee_type_excl(Scope, EmplKey, DateBegin, FeeTypeKey) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            % если вид начисления "Компенсация отпуска"
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-Alias ]),
            memberchk(Alias, ["ftHolidayComp"]),
            % и сотрудник уволен в месяце текущей даты
            is_fired(Scope, EmplKey, DateBegin),
            !.
        
        % сотрудник уволен в месяце текущей даты
        is_fired(Scope, EmplKey, DateBegin) :-
            atom_date(DateBegin, date(Y, M, _)),
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey,
                        fMoveYear-Y, fMoveMonth-M,
                        fMovementType-3 ]),
            !.
        
        % сопоставить с данными по умолчанию
        fit_data(Scope, [Name-Value0], [Name-Value]) :-
            % - для алиментов (Процент остатка)
            Scope = wg_fee_alimony, Type = fit,
            Name = pRestPercent,
            get_param(Scope, Type, Name-Value1),
            ( Value0 < Value1, Value = Value1
            ; Value = Value0
            ),
            !.
        % сопоставить с данными по умолчанию
        fit_data(Scope, [Name-Value0], [Name-Value]) :-
            % - для алиментов ( Процент списания долга)
            Scope = wg_fee_alimony, Type = fit,
            Name = pPercent,
            ( Value0 > 0, Value = Value0
            ; get_param(Scope, Type, Name-Value)
            ),
            !.
        fit_data(Scope, Pairs0, Pairs) :-
            % - для алиментов (Процент от БПМ)
            Scope = wg_fee_alimony, Type = fit,
            Pairs0 = [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc0],
            Pairs = [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc],
            Pairs1 = [pChildQtyCmp-ChildQtyCmp, pLivingWagePerc-LivingWagePerc1],
            %
            get_param_list(Scope, Type, Pairs1),
            catch( atomic_concat(ChildCount, ChildQtyCmp, Atom), _, fail ),
            catch( term_to_atom(Term, Atom), _, fail),
            catch( Term, _, fail),
            %
            ( LivingWagePerc0 < LivingWagePerc1, LivingWagePerc = LivingWagePerc1
            ; LivingWagePerc = LivingWagePerc0
            ),
            !.
        fit_data(_, Pairs, Pairs) :-
            !.
        
        /* реализация - расширение для клиента */
        
        % загрузка входных данных по сотруднику
        fee_calc_in(Scope, EmplKey, DateBegin, TotalDocKey, FeeTypeKey, RoundType, RoundValue) :-
            Scope = wg_fee_alimony, Type = in, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pEmplKey-EmplKey, pDateBegin-DateBegin,
                pTotalDocKey-TotalDocKey, pFeeTypeKey-FeeTypeKey,
                pRoundType-RoundType, pRoundValue-RoundValue
                ]),
            !.
        
        % подготовка данных выполнения
        fee_calc_prep(Scope) :-
            Scope = wg_fee_alimony, Type = in, TypeNextStep = run,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % для каждого сотрудника
            get_param_list(Scope, Type, [pEmplKey-_, pDateBegin-DateBegin], Pairs),
            % собрать входные данные
            findall( Pairs0,
                     ( member(Template, [pCommon-1, pAlimony-1]),
                       get_param_list(Scope, Type, [Template], Pairs0)
                     ),
            PairsList ),
            append(PairsList, PairsNextStep0),
            % сформировать данные выполнения
            date_add(DateBegin, -1, month, DateBegin0),
            atom_date(DateBegin0, date(Y0, M0, _)),
            atom_date(DatePrevCalcFrom, date(Y0, M0, 1)),
            atom_date(DateBegin, date(Y, M, _)),
            atom_date(DateCalcFrom, date(Y, M, 1)),
            date_add(DateBegin, 1, month, DateBegin1),
            atom_date(DateBegin1, date(Y1, M1, _)),
            atom_date(DateCalcTo, date(Y1, M1, 1)),
            % записать данные выполнения
            append([ Pairs,
                     [
                       pDatePrevCalcFrom-DatePrevCalcFrom, pDatePrevCalcTo-DateCalcFrom,
                       pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo
                     ],
                     PairsNextStep0
                   ],
                       PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            % найти альтернативу
            fail.
        fee_calc_prep(_) :-
            % больше альтернатив нет
            !.
        
        % выгрузка данных выполнения по сотруднику
        fee_calc_run(Scope, EmplKey) :-
            Scope = wg_fee_alimony, Type = run, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % взять данные выполнения
            get_param_list(Scope, Type, PK),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % формирование SQL-запросов по сотруднику
        fee_calc_sql(Scope, EmplKey, PredicateName, Arity, SQL) :-
            Scope = wg_fee_alimony, Type = run, TypeNextStep = query,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, kb, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, kb, Query, SQL0, Params),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-запросу
            PairsNextStep = [pEmplKey-EmplKey, pQuery-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % формирование SQL-команд по сотруднику
        fee_calc_cmd(Scope, EmplKey, PredicateName, Arity, SQL) :-
            Scope = wg_fee_alimony, Type = run, TypeNextStep = cmd,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, cmd, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, cmd, Query, SQL0, Params),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-команде
            PairsNextStep = [pEmplKey-EmplKey, pCmd-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % выгрузка выходных данных по сотруднику
        fee_calc_out(Scope, EmplKey, Result) :-
            Scope = wg_fee_alimony, Type = out, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % спецификация параметров выходных данных
            append([[pCalcTotal-1], PK, [pAllChargeTotal-Result]], OutPairs),
            % взять выходные данные
            get_param_list(Scope, Type, OutPairs),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % выгрузка выходных данных по начислениям по сотруднику
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex) :-
            % - начисление алиментов
            Scope = wg_fee_alimony, Type = temp, AccountKeyIndex = 0,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeID, fAlias-"ftAlimony" ]),
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey,
                        pAlimonyCharge-ChargeSum, pAlimonyKey-DocKey ],
            % взять данные по алиментам
            get_param_list(Scope, Type, AlimonyParams),
            ChargeSum > 0,
            true.
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex) :-
            % - списание долгов по алиментам
            Scope = wg_fee_alimony, Type = temp, AccountKeyIndex = 1,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeID, fAlias-"ftAlimonyDebt" ]),
            % спецификация параметров списания долгов
            DropDebtParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pDropDebtCharge-ChargeSum, pAlimonyDebtKey-DocKey ],
            % взять данные по списанию долгов
            get_param_list(Scope, Type, DropDebtParams),
            ChargeSum > 0,
            true.
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex) :-
            % - пересылка алиментов
            Scope = wg_fee_alimony, Type = temp, AccountKeyIndex = 2,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeID, fAlias-"ftTransferDed" ]),
            % спецификация параметров перевода
            TransfParams = [
                        pCalcTransf-_, pEmplKey-EmplKey,
                        pTransfCharge-ChargeSum, pAlimonyKey-DocKey ],
            % взять данные по переводу
            get_param_list(Scope, Type, TransfParams),
            ChargeSum > 0,
            true.
        
        % выгрузка выходных данных по долгам по сотруднику
        fee_calc_debt(Scope, EmplKey, AlimonyKey, DebtSum, DateDebt) :-
            % - долги по алиментам
            Scope = wg_fee_alimony, Type = temp,
            % спецификация параметров долга
            DebtParams = [
                        pAddDebt-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebt-DebtSum ],
            % взять данные по списанию долгу
            get_param_list(Scope, Type, DebtParams),
            DebtSum > 0,
            % дата долга
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            date_add(DateCalcTo, -1, day, DateDebt),
            true.
        
        fee_calc_prot(Scope, EmplKey, ProtText) :-
            % - протокол по алиментам
            Scope = wg_fee_alimony,
            findall( Sections, fee_prot(Scope, _, Sections), SectionsList),
            fee_calc_prot(Scope, SectionsList, EmplKey, "", ProtText),
            !.
        %
        fee_calc_prot(_, [], _, ProtText, ProtText) :-
            !.
        fee_calc_prot(Scope, [Sections|SectionsList], EmplKey, ProtText0, ProtText) :-
            fee_prot(Scope, Types, Sections),
            fee_prot(Scope, Types, Sections, EmplKey, ProtText1),
            string_concat(ProtText0, ProtText1, ProtText2),
            !,
            fee_calc_prot(Scope, SectionsList, EmplKey, ProtText2, ProtText).
        
        /* реализация - протокол */
        
        % Протокол удержания алиментов (общая информация)
        fee_prot(wg_fee_alimony, in, pEmplInfo-1).
        fee_prot(wg_fee_alimony, temp, pCalcTab-1).
        % Исполнительные листы (пропорция по отработанному времени)
        fee_prot(wg_fee_alimony, temp, pCalcTab-2).
        % Суммы для расчета
        fee_prot(wg_fee_alimony, temp, pCalcAmount-3).
        % Исполнительные листы (расчетная сумма алиментов)
        fee_prot(wg_fee_alimony, [temp, temp], [pCalcFormula-1, pCheckRest-1]).
        % Контрольная сумма
        fee_prot(wg_fee_alimony, temp, pCheckRest-1).
        % Удержания и долги
        fee_prot(wg_fee_alimony, [temp, temp, temp, out], [pCheckRest-3, pCalcFormula-1, pAddDebt-1, pCalcTotal-1]).
        % Исполнительные листы (расчетная сумма списания долгов)
        fee_prot(wg_fee_alimony, [temp, temp], [pDropDebt-2, pDropDebt-3]).
        % Исполнительные листы (частичная сумма списания долга)
        fee_prot(wg_fee_alimony, [temp, temp, out], [pDropDebt-3, pDropDebt-5, pCalcTotal-1]).
        % расходы по Переводу
        fee_prot(wg_fee_alimony, [temp, out], [pCalcTransf-_, pCalcTotal-1]).
        % Итого удержано
        fee_prot(wg_fee_alimony, out, pCalcTotal-1).
        
        % Протокол удержания алиментов (общая информация)
        fee_prot(Scope, _, Section, EmplKey, ProtText) :-
            Scope = wg_fee_alimony, Section = pEmplInfo-1,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для даты последнего приема на работу
            get_last_hire(Scope, PK, DateBegin),
            % взять дополнительные данные из первого движения
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey,
                        fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fMovementType-1,
                        fListNumber-ListNumber ]),
            % взять наименование сотрудника из контактов
            get_data(Scope, kb, gd_contact, [
                        fID-EmplKey, fName-Name ]),
            format( string(ProtText),
                    "~w~n~` t~w~9+ ~w~` t~w~32+ ~w~n",
                    [ "Протокол удержания алиментов",
                      "Таб. №:", ListNumber, "Сотрудник:", Name ] ),
                !.
        fee_prot(Scope, Type, Section, EmplKey, ProtText) :-
            Scope = wg_fee_alimony, Section = pCalcTab-1,
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey,
                            pYM-Y-M, pTDays-TDays, pTHoures-THoures ]),
            month_name(M, MonthName),
            format( string(ProtText),
                    "~` t~w~9+ ~w ~w ~w~` t~w~32+ ~1f ~w~1f ~w~n",
                    [ "Период:", MonthName, Y, "г.",
                      "Отработано:", THoures, "ч. (", TDays, "дн.)" ] ),
            !.
        % Исполнительные листы (пропорция по отработанному времени)
        fee_prot(Scope, Type, Section, EmplKey, ProtText) :-
            Scope = wg_fee_alimony, Section = pCalcTab-2,
            format( string(ProtText0),
                    "~n~2|~w~n~4|~w~15|~w~27|~w~39|~w~60|~w~n",
                    [ "Исполнительные листы (пропорция по отработанному времени):",
                      "Ключ", "Начало", "Окончание", "Отработано", "Пропорция"  ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Type, Section, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText),
            !.
        % Суммы для расчета
        fee_prot(Scope, Type, Section, EmplKey, ProtText) :-
            Scope = wg_fee_alimony, Section = pCalcAmount-3,
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey, pForAlimony-ForAlimony,
                            pAmountAll-AmountAll, pIncomeTax-IncomeTax,
                            pAmountExcl-AmountExcl, pIncomeTaxExcl-IncomeTaxExcl ]),
            format( string(ProtText),
                    "~n~2|~w~n~4|~0f~w~0f~w~0f~n~2|~w~n~4|~0f~w~0f~w~0f~n~2|~w~n~4|~0f~w~0f~w~0f~n",
                    [ "Заработок = Начисленная сумма - ПН",
                      AmountAll, " = ", AmountAll - IncomeTax, " - ", -IncomeTax,
                      "Исключаемый заработок = Исключаемая сумма - Исключаемый ПН",
                      AmountExcl + IncomeTaxExcl, " = ", AmountExcl," - ", -IncomeTaxExcl,
                      "Для алиментов = Заработок - Исключаемый заработок",
                      ForAlimony, " = ", AmountAll, " - ",  AmountExcl + IncomeTaxExcl ] ),
                !.
        % Исполнительные листы (расчетная сумма алиментов)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [_, Type2],
            Sections = [_, Section2],
            Sections = [pCalcFormula-1, pCheckRest-1],
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            % сумма БВ
            get_min_wage(Scope, DateCalcTo, BV),
            % БПМ
            get_budget(Scope, DateCalcTo, BudgetConst),
            format( string(ProtText0),
                    "~n~2|~w~0f~n~2|~w~0f~n~n~2|~w~n~4|~w~15|~w~27|~w~55|~w~61|~w~n",
                    [ "Базовая величина (БВ) = ", BV,
                      "Бюджет прожиточного минимума (БПМ) = ", BudgetConst,
                      "Исполнительные листы (расчетная сумма алиментов):",
                      "Ключ", "Сумма", "Формула", "Дети", "Примечание"  ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pAlimonyAmount-AlimonyAmount ]),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~n",
                    ["Итого:", AlimonyAmount] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % Контрольная сумма
        fee_prot(Scope, Type, Section, EmplKey, ProtText) :-
            Scope = wg_fee_alimony, Section = pCheckRest-1,
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey,
                            pCheckAmount-CheckAmount,
                            pAmountAll-AmountAll, pRestPercent-RestPercent ]),
            format( string(ProtText),
                    "~n~2|~w~n~4|~0f~w~0f~w~0f~w~0f~w~n",
                    [ "Контрольная сумма = Заработок - Заработок * Процент остатка",
                      CheckAmount, " = ", AmountAll, " - ",
                      AmountAll, " * ", RestPercent * 100, "%" ] ),
            !.
        % Удержания и долги
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Sections = [pCheckRest-3, pCalcFormula-1, pAddDebt-1, pCalcTotal-1],
            Types = [Type1|_],
            Sections = [Section1|_],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pChargeStep-0 ]),
            format( string(ProtText),
                    "~n~2|~w~n",
                    [ "Алименты к удержанию по расчетной сумме" ] ),
            !.
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Sections = [pCheckRest-3, pCalcFormula-1, pAddDebt-1, pCalcTotal-1],
            Types = [_, _, Type3, Type4],
            Sections = [_, _, Section3, Section4],
            format( string(ProtText0),
                    "~n~2|~w~n~n~2|~w~n~4|~w~15|~w~27|~w~n",
                    [ "Алименты к удержанию по частичной сумме",
                      "Исполнительные листы (частичная сумма алиментов):",
                      "Ключ", "Сумма", "Долг"  ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type4, [
                            Section4, pEmplKey-EmplKey,
                            pAlimonyChargeTotal-AlimonyChargeTotal ]),
            findall( AlimonyDebt,
                     get_param_list(Scope, Type3, [
                                     Section3, pEmplKey-EmplKey,
                                     pAlimonyDebt-AlimonyDebt ]),
            AlimonyDebtList ),
            sum_list(AlimonyDebtList, AlimonyDebtTotal),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~26| ~0f~n",
                    ["Итого:", AlimonyChargeTotal, AlimonyDebtTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % Исполнительные листы (расчетная сумма списания долга)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [Type1, Type2],
            Sections = [Section1, Section2],
            Sections = [pDropDebt-2, pDropDebt-3],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pDropDebtAmount-DropDebtAmount ]),
            DropDebtAmount > 0,
            format( string(ProtText0),
                    "~n~2|~w~n~4|~w~15|~w~27|~w~39|~w~51|~w~63|~w~n",
                    [ "Исполнительные листы (расчетная сумма списания долга):",
                      "Ключ", "Сумма", "Долг", "Оплачено", "Остаток", "Процент списания долга" ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pDropDebtTotal-DropDebtTotal, pRestDebtTotal-RestDebtTotal,
                            pDebtTotal-DebtTotal, pPaidDebtTotal-PaidDebtTotal]),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~26| ~0f~38| ~0f~50| ~0f~n",
                    ["Итого:", DropDebtTotal, DebtTotal, PaidDebtTotal, RestDebtTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % Исполнительные листы (частичная сумма списания долга)
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [Type1, Type2, _],
            Sections = [Section1, Section2, _],
            Sections = [pDropDebt-3, pDropDebt-5, pCalcTotal-1],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pChargeStep-0 ]),
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pByDropDebtCoef-0 ]),
            format( string(ProtText),
                    "~n~2|~w~n",
                    [ "Долг по алиментам к удержанию по расчетной сумме" ] ),
            !.
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [Type1, _, Type3],
            Sections = [Section1, _, Section3],
            Sections = [pDropDebt-3, pDropDebt-5, pCalcTotal-1],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey ]),
            format( string(ProtText0),
                    "~n~2|~w~n~n~2|~w~n~4|~w~15|~w~n",
                    [ "Долг по алиментам к удержанию по частичной сумме",
                      "Исполнительные листы (частичная сумма списания долга):",
                      "Ключ", "Сумма" ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            get_param_list(Scope, Type3, [
                            Section3, pEmplKey-EmplKey,
                            pDropDebtChargeTotal-DropDebtChargeTotal ]),
            format( string(ProtText2),
                    "~` t~w~14+ ~0f~n",
                    ["Итого:", DropDebtChargeTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % расходы по Переводу
        fee_prot(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [_, Type2],
            Sections = [_, Section2],
            Sections = [pCalcTransf-_, pCalcTotal-1],
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey,
                            pTransfChargeTotal-TransfChargeTotal ]),
            TransfChargeTotal > 0,
            format( string(ProtText0),
                    "~n~2|~w~n~4|~w~11|~w~23|~w~35|~w~47|~w~n",
                    [ "Расходы по переводу:",
                      "", "Сумма", "Перевод", "Расценка", "Получатель" ] ),
            findall( ProtDetText,
                     fee_prot_det(Scope, Types, Sections, EmplKey, ProtDetText),
            ProtDetTextList),
            atomic_list_to_string([ProtText0|ProtDetTextList], ProtText1),
            format( string(ProtText2),
                    "~` t~w~10+ ~0f~n",
                    ["Итого:", TransfChargeTotal] ),
            string_concat(ProtText1, ProtText2, ProtText),
            !.
        % Итого удержано
        fee_prot(Scope, Type, Section, EmplKey, ProtText) :-
            Scope = wg_fee_alimony, Section = pCalcTotal-1,
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey,
                            pAllChargeTotal-AllChargeTotal,
                            pAlimonyChargeTotal-AlimonyChargeTotal,
                            pDropDebtChargeTotal-DropDebtChargeTotal,
                            pTransfChargeTotal-TransfChargeTotal ]),
            format( string(ProtText),
                    "~n~2|~w~n~4|~0f~w~0f~w~0f~w~0f~n",
                    [ "Итого удержано = Алименты + Списание долгов + Расходы по переводу",
                      AllChargeTotal, " = ",
                      AlimonyChargeTotal, " + ", DropDebtChargeTotal, " + ", TransfChargeTotal] ),
                !.
        % возврат пустой строки при неудаче
        fee_prot(_, _, _, _, "") :-
            !.
        
        % Исполнительные листы (пропорция по отработанному времени) - детали
        fee_prot_det(Scope, Type, Section, EmplKey, ProtDetText) :-
            Scope = wg_fee_alimony, Section = pCalcTab-2,
            get_param(Scope, in, pNullDate-NullDate),
            get_param_list(Scope, Type, [
                            Section, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pDateBegin-ADateBegin, pDateEnd-ADateEnd0,
                            pTCoef-TCoef, pADays-ADays,
                            pAHoures-AHoures, pTHoures-THoures ]),
            ( ADateEnd0 = NullDate -> ADateEnd = '' ; ADateEnd = ADateEnd0 ),
            date_format(ADateBegin, ADateBegin1),
            date_format(ADateEnd, ADateEnd1),
            ( TCoef < 1 -> TCoef1 = AHoures / THoures ; TCoef1 = TCoef ),
            format( string(ProtDetText),
                    "~4|~w~14| ~w~26| ~w~38| ~1f ~w~1f ~w~59| ~w~n",
                    [ AlimonyKey, ADateBegin1, ADateEnd1,
                      AHoures, "ч. (", ADays, "дн.)", TCoef1 ] ),
            true.
        % Исполнительные листы (расчетная сумма алиментов) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [Type1, _],
            Sections = [Section1, _],
            Sections = [pCalcFormula-1, pCheckRest-1],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pAlimonySum-AlimonySum, pByBudget-ByBudget,
                            pFormula-Formula, pTCoef-TCoef,
                            pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc ]),
            ( TCoef < 1 ->
              Desc1 = "пропоционально"
            ; Desc1 = ""
            ),
            ( ByBudget = 1 ->
              format( string(Desc2),
                      "~w ~w",
                      [ LivingWagePerc, "от БПМ" ]),
              ( \+ Desc1 = "" -> Delim1 = "; " ; Delim1 = "" )
            ; Desc2 = "", Delim1 = ""
            ),
            atomic_list_to_string([Desc1, Delim1, Desc2], Desc),
            format( string(ProtText),
                    "~4|~w~14| ~0f~26| ~w~54| ~0f~60| ~w~n",
                    [ AlimonyKey, AlimonySum, Formula, ChildCount, Desc ] ),
            true.
        % Удержания и долги - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Sections = [pCheckRest-3, pCalcFormula-1, pAddDebt-1, pCalcTotal-1],
            Types = [_, Type2, Type3, _],
            Sections = [_, Section2, Section3, _],
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pAlimonyCharge-AlimonyCharge ]),
            once( ( get_param_list(Scope, Type3, [
                            Section3, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pAlimonyDebt-AlimonyDebt ])
                  ; AlimonyDebt = 0
                  )
                ),
            format( string(ProtText),
                    "~4|~w~14| ~0f~26| ~0f~n",
                    [ AlimonyKey, AlimonyCharge, AlimonyDebt ] ),
            true.
        % Исполнительные листы (расчетная сумма списания долга) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [Type1, _],
            Sections = [Section1, _],
            Sections = [pDropDebt-2, pDropDebt-3],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                            pDropDebtAmount-DropDebtAmount, pRestDebtAmount-RestDebtAmount,
                            pDebtAmount-DebtAmount, pPaidDebtAmount-PaidDebtAmount,
                            pDebtPercent-DebtPercent
                             ]),
            format( string(ProtText),
                    "~4|~w~14| ~0f~26| ~0f~38| ~0f~50| ~0f~62| ~0f~w~n",
                    [ AlimonyKey,
                      DropDebtAmount, DebtAmount, PaidDebtAmount, RestDebtAmount,
                      DebtPercent * 100, "%" ] ),
            true.
        % Исполнительные листы (частичная сумма списания долга) - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [_, Type2, _],
            Sections = [_, Section2, _],
            Sections = [pDropDebt-3, pDropDebt-5, pCalcTotal-1],
            get_param_list(Scope, Type2, [
                            Section2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey ]),
            findall( DropDebtCharge,
                     get_param_list(Scope, Type2, [
                                    Section2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                                    pDropDebtCharge-DropDebtCharge ]),
            DropDebtChargeList ),
            sum_list(DropDebtChargeList, DropDebtAmount),
            format( string(ProtText),
                    "~4|~w~14| ~0f~n",
                    [ AlimonyKey, DropDebtAmount ] ),
            true.
        % расходы по Переводу - детали
        fee_prot_det(Scope, Types, Sections, EmplKey, ProtText) :-
            Scope = wg_fee_alimony,
            Types = [Type1, _],
            Sections = [Section1, _],
            Sections = [pCalcTransf-_, pCalcTotal-1],
            get_param_list(Scope, Type1, [
                            Section1, pEmplKey-EmplKey,
                            pTransfCharge-TransfCharge, pRecipient-Recipient,
                            pForTransfAmount-ForTransfAmount, pTransfPercent-TransfPercent ]),
            once( ( get_data(Scope, kb, gd_contact, [
                        fID-Recipient, fName-Name ])
                  ; Name = ""
                ) ),
            format( string(ProtText),
                    "~4|~w~10| ~0f~22| ~0f~34| ~2f~w~46| ~w~n",
                    [ "", TransfCharge, ForTransfAmount, TransfPercent, "%", Name ] ),
            true.
        
        /**/
        
        % отладка
        p:-
            fee_calc_prot(_, _, ProtText),
            string_length(ProtText, Len),
            writeln(ProtText),
            writeln(Len),
            !.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-10-14T14:29:53+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "151042959_187967073 wg_data_mix"
          - 
            ADDFUNCTIONKEY: "195362817_166214404 twg_fee_sql"
          - 
            ADDFUNCTIONKEY: "195362816_166214404 twg_fee_in_params"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195361376_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_FeeAlimonyCalc_pl"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        '#include wg_WageSettings
        '
        '#include pl_GetScriptIDByName
        
        Function wg_FeeAlimonyCalc_pl(ByRef wg_EmployeeCharge, ByVal TotalDocKey, ByVal FeeTypeKey, _
                                      ByVal AccountKeyArr)
        '
          Dim T, T1, T2
          '
          Dim Creator, IsDebug
          IsDebug = True
          '
          Dim PL, Ret, Pred, Tv, PredFile, Append
          Dim ScriptName, Scope
          'fee_calc_in, fee_calc_prep
          Dim P_in, Tv_in, Q_in, P_prep, Tv_prep, Q_prep
          Dim EmplKey, DateBegin, RoundType, RoundValue
          'fee_calc_run
          Dim P_run, Tv_run, Q_run
          'fee_calc_sql, fee_calc_cmd
          Dim P_sql, Tv_sql, Q_sql, P_cmd, Tv_cmd, Q_cmd
          Dim PredicateName, Arity, SQL
          Dim SQLUpdate
          'fee_calc
          Dim P_main, Tv_main, Q_main
          'fee_calc_out, fee_calc_charge
          Dim P_out, Tv_out, Q_out, P_charge, Tv_charge, Q_charge
          Dim Result, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex
          'fee_calc_debt
          Dim P_debt, Tv_debt, Q_debt
          Dim AlimonyKey, DebtSum, DateDebt
          Dim gdcAlimonyDebt
          'fee_calc_prot
          Dim P_prot, Tv_prot, Q_prot
          Dim ProtText
          Dim gdcTblChargeProt
        
          T1 = Timer
        
          Result = 0
          wg_FeeAlimonyCalc_pl = Result
            
          'init
          Set Creator = New TCreator
          Set PL = Creator.GetObject(nil, "TgsPLClient", "")
          Ret = PL.Initialise("")
          If Not Ret Then
            Exit Function
          End If
          'debug
          PL.Debug = (False And IsDebug And plGlobalDebug)
          'load
          ScriptName = "twg_fee"
          Ret = PL.LoadScript(pl_GetScriptIDByName(ScriptName))
          If Not Ret Then
            Exit Function
          End If
          Scope = "wg_fee_alimony"
          'debug
          PL.Debug = (True And IsDebug And plGlobalDebug)
        
          'params
          EmplKey = wg_EmployeeCharge.EmployeeKey
          DateBegin = wg_EmployeeCharge.BeginDate
          '
          RoundType = wg_WageSettings.Wage.RoundType
          RoundValue = wg_WageSettings.Wage.RoundValue
        
          'fee_calc_in(Scope, EmplKey, DateBegin, TotalDocKey, FeeTypeKey, RoundType, RoundValue)
          P_in = "fee_calc_in"
          Set Tv_in = Creator.GetObject(7, "TgsPLTermv", "")
          Set Q_in = Creator.GetObject(nil, "TgsPLQuery", "")
          '
          Tv_in.PutAtom 0, Scope
          Tv_in.PutInteger 1, EmplKey
          Tv_in.PutDate 2, DateBegin
          Tv_in.PutInteger 3, TotalDocKey
          Tv_in.PutInteger 4, FeeTypeKey
          Tv_in.PutInteger 5, RoundType
          Tv_in.PutFloat 6, RoundValue
          '
          Q_in.PredicateName = P_in
          Q_in.Termv = Tv_in
          '
          Q_in.OpenQuery
          If Q_in.EOF Then
            Exit Function
          End If
          Q_in.Close
        
          'fee_calc_prep(Scope)
          P_prep = "fee_calc_prep"
          Set Tv_prep = Creator.GetObject(1, "TgsPLTermv", "")
          Set Q_prep = Creator.GetObject(nil, "TgsPLQuery", "")
          '
          Tv_prep.PutAtom 0, Scope
          '
          Q_prep.PredicateName = P_prep
          Q_prep.Termv = Tv_prep
          '
          Q_prep.OpenQuery
          If Q_prep.EOF Then
            Exit Function
          End If
          Q_prep.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          'fee_calc_run(Scope, EmplKey)
          P_run = "fee_calc_run"
          Set Tv_run = Creator.GetObject(2, "TgsPLTermv", "")
          Set Q_run = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_run.PredicateName = P_run
          Q_run.Termv = Tv_run
          '
          Tv_run.PutAtom 0, Scope
          '
          Q_run.OpenQuery
          If Q_run.EOF Then
            Exit Function
          End If
        
          'fee_calc_sql(Scope, EmplKey, PredicateName, Arity, SQL)
          P_sql = "fee_calc_sql"
          Set Tv_sql = Creator.GetObject(5, "TgsPLTermv", "")
          Set Q_sql = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_sql.PredicateName = P_sql
          Q_sql.Termv = Tv_sql
          'fee_calc_cmd(Scope, EmplKey, PredicateName, Arity, SQL)
          P_cmd = "fee_calc_cmd"
          Set Tv_cmd = Creator.GetObject(5, "TgsPLTermv", "")
          Set Q_cmd = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_cmd.PredicateName = P_cmd
          Q_cmd.Termv = Tv_cmd
          '
          Set SQLUpdate = Creator.GetObject(nil, "TIBSQL", "")
          Set SQLUpdate.Transaction = wg_EmployeeCharge.Transaction
        
          Append = False
          '
          Do Until Q_run.EOF
            EmplKey = Tv_run.ReadInteger(1)
            '
            Tv_sql.Reset
            Tv_sql.PutAtom 0, Scope
            Tv_sql.PutInteger 1, EmplKey
            Q_sql.OpenQuery
            '
            Tv_cmd.Reset
            Tv_cmd.PutAtom 0, Scope
            Tv_cmd.PutInteger 1, EmplKey
            Q_cmd.OpenQuery
            '
            Do Until Q_cmd.EOF
              PredicateName = Tv_cmd.ReadAtom(2)
              Arity = Tv_cmd.ReadInteger(3)
              SQL = Tv_cmd.ReadString(4)
              '
              SQLUpdate.SQL.Text = SQL
              SQLUpdate.ExecQuery
              SQLUpdate.Close
              '
              Q_cmd.NextSolution
            Loop
            Q_cmd.Close
            '
            Do Until Q_sql.EOF
              PredicateName = Tv_sql.ReadAtom(2)
              Arity = Tv_sql.ReadInteger(3)
              SQL = Tv_sql.ReadString(4)
              '
              Ret =  PL.MakePredicatesOfSQLSelect _
                        (SQL, _
                        wg_EmployeeCharge.Transaction, _
                        PredicateName, PredicateName, Append)
              '
              Q_sql.NextSolution
            Loop
            Q_sql.Close
            '
            Append = True
            '
            Q_run.NextSolution
          Loop
          Q_run.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          'fee_calc(Scope)
          P_main = "fee_calc"
          Set Tv_main = Creator.GetObject(1, "TgsPLTermv", "")
          Set Q_main = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_main.PredicateName = P_main
          Q_main.Termv = Tv_main
          '
          Tv_main.PutAtom 0, Scope
          '
          Q_main.OpenQuery
          If Q_main.EOF Then
            Exit Function
          End If
          Q_main.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          'fee_calc_out(Scope, EmplKey, Result)
          P_out = "fee_calc_out"
          Set Tv_out = Creator.GetObject(3, "TgsPLTermv", "")
          Set Q_out = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_out.PredicateName = P_out
          Q_out.Termv = Tv_out
          '
          Tv_out.PutAtom 0, Scope
          '
          Q_out.OpenQuery
          If Q_out.EOF Then
            Exit Function
          End If
        
          'fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeID, DocKey, AccountKeyIndex)
          P_charge = "fee_calc_charge"
          Set Tv_charge = Creator.GetObject(6, "TgsPLTermv", "")
          Set Q_charge = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_charge.PredicateName = P_charge
          Q_charge.Termv = Tv_charge
        
          'fee_calc_debt(Scope, EmplKey, AlimonyKey, DebtSum, DateDebt)
          P_debt = "fee_calc_debt"
          Set Tv_debt = Creator.GetObject(5, "TgsPLTermv", "")
          Set Q_debt = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_debt.PredicateName = P_debt
          Q_debt.Termv = Tv_debt
          'Журнал долгов по алиментам
          Set gdcAlimonyDebt = Creator.GetObject(nil, "TgdcUserDocument", "")
          gdcAlimonyDebt.SubType = "147072391_453357870"
          gdcAlimonyDebt.SubSet = "ByID"
          gdcAlimonyDebt.Transaction = wg_EmployeeCharge.Transaction
        
          'fee_calc_prot(Scope, EmplKey, ProtText)
          P_prot = "fee_calc_prot"
          Set Tv_prot = Creator.GetObject(3, "TgsPLTermv", "")
          Set Q_prot = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_prot.PredicateName = P_prot
          Q_prot.Termv = Tv_prot
          'Протокол по начислениям
          Set gdcTblChargeProt = Creator.GetObject(nil, "TgdcAttrUserDefined", "")
          gdcTblChargeProt.SubType = "USR$WG_TBLCHARGE_PROT"
          gdcTblChargeProt.Transaction = wg_EmployeeCharge.Transaction
          gdcTblChargeProt.ExtraConditions.Add _
            ( _
                " Z.USR$EMPLKEY = " & EmplKey & _
            " AND Z.USR$TOTALDOCKEY = " & TotalDocKey & _
            " AND Z.USR$FEETYPEKEY = " & FeeTypeKey _
            )
        
          Do Until Q_out.EOF
            EmplKey = Tv_out.ReadInteger(1)
            Result = Tv_out.ReadFloat(2)
            '
            Tv_charge.Reset
            Tv_charge.PutAtom 0, Scope
            Tv_charge.PutInteger 1, EmplKey
            Q_charge.OpenQuery
            '
            Do Until Q_charge.EOF
              ChargeSum = Tv_charge.ReadFloat(2)
              FeeTypeID = Tv_charge.ReadInteger(3)
              DocKey = Tv_charge.ReadInteger(4)
              AccountKeyIndex = Tv_charge.ReadInteger(5)
              '
              Call wg_EmployeeCharge.AddCharge(0, ChargeSum, Null, TotalDocKey, FeeTypeID, _
                  DocKey, wg_EmployeeCharge.BeginDate, 0, 0)
              Call wg_EmployeeCharge.AddChargeRegNew(0, ChargeSum, TotalDocKey, FeeTypeID, _
                  AccountKeyArr(AccountKeyIndex), wg_EmployeeCharge.BeginDate, DocKey)
              '
              Q_charge.NextSolution
            Loop
            Q_charge.Close
            '
            Tv_debt.Reset
            Tv_debt.PutAtom 0, Scope
            Tv_debt.PutInteger 1, EmplKey
            Q_debt.OpenQuery
            '
            If Not Q_debt.EOF Then
              gdcAlimonyDebt.Open
            End If
            '
            Do Until Q_debt.EOF
              AlimonyKey = Tv_debt.ReadInteger(2)
              DebtSum = Tv_debt.ReadFloat(3)
              DateDebt = Tv_debt.ReadDate(4)
              '
              gdcAlimonyDebt.Insert
              gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
              gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = AlimonyKey
              gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = DebtSum
              gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 0
              gdcAlimonyDebt.FieldByName("usr$datedebt").AsDateTime = DateDebt
              gdcAlimonyDebt.Post
              '
              Q_debt.NextSolution
            Loop
            Q_debt.Close
            '
            Tv_prot.Reset
            Tv_prot.PutAtom 0, Scope
            Tv_prot.PutInteger 1, EmplKey
            Q_prot.OpenQuery
            '
            If Not Q_prot.EOF Then
              gdcTblChargeProt.Open
            End If
            '
            Do Until Q_prot.EOF
              ProtText = Tv_prot.ReadString(2)
              '
              gdcTblChargeProt.Edit
              gdcTblChargeProt.FieldByName("USR$EMPLKEY").AsInteger = EmplKey
              gdcTblChargeProt.FieldByName("USR$TOTALDOCKEY").AsInteger = TotalDocKey
              gdcTblChargeProt.FieldByName("USR$FEETYPEKEY").AsInteger = FeeTypeKey
              gdcTblChargeProt.FieldByName("USR$DESCRIPTION").AsString = ProtText
              gdcTblChargeProt.Post
              '
              Q_prot.NextSolution
            Loop
            Q_prot.Close
            '
            Q_out.NextSolution
          Loop
          Q_out.Close
        
          gdcAlimonyDebt.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          wg_FeeAlimonyCalc_pl = Result
        
          T2 = Timer
          T = T2 - T1
        '
        End Function
        
      DISPLAYSCRIPT: | 
        WG_FEEALIMONYCALC_PL
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QRAAAAV0dfRU1QTE9ZRUVDSEFSR0URAAAAV0dfRU1QTE9ZRUVDSEFSR0UAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QLAAAAVE9UQUxET0NLRVkLAAAAVE9UQUxET0NLRVkA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QKAAAARkVFVFlQRUtFWQoAAABGRUVUWVBF
        S0VZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RQUlNUDQAAAEFDQ09VTlRLRVlBUlINAAAA
        QUNDT1VOVEtFWUFSUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGTlNURkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-10-08T14:37:34+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147019760_119619099 wg_WageSettings"
          - 
            ADDFUNCTIONKEY: "151158419_5956463 pl_GetScriptIDByName"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 147656112_119619099
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "WAGE"
      LANGUAGE: "VBScript"
      NAME: "wg_FeeAlimonyCalc"
      COMMENT: ~
      SCRIPT: | 
        '#include wg_MonthHour
        '#include wg_GetAlimonySum
        '#include wg_CalcTransferSum
        '#include wg_RoundSum
        '#include wg_EmplMoveList
        '#include wg_TblCal
        '#include wg_WageSettings
        '#include wg_GetAccountKey
        '<pl>
        '#include wg_FeeAlimonyCalc_pl
        '</pl>
        function wg_FeeAlimonyCalc(ByRef wg_EmployeeCharge, ByVal TotalDocKey, ByVal FeeTypeKey, ByRef obj_FeeData)
        'Расчет алиментов, долга по алиментам и расходов на их пересылку
          wg_FeeAlimonyCalc = 0
        
          Dim wg_FeeType_TransferDed_ID, wg_FeeType_AlimonyDebt_ID
          Dim AccountKey, AccountKeyDebt, AccountKeyTransf
        
          wg_FeeType_TransferDed_ID = gdcBaseManager.GetIDByRUIDString(wg_FeeType_TransferDed_RUID)
          wg_FeeType_AlimonyDebt_ID = gdcBaseManager.GetIDByRUIDString(wg_FeeType_AlimonyDebt_RUID)
        
          AccountKey = wg_GetAccountKey(FeeTypeKey, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.EndDate)
          AccountKeyDebt = wg_GetAccountKey(wg_FeeType_AlimonyDebt_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.EndDate)
          AccountKeyTransf = wg_GetAccountKey(wg_FeeType_TransferDed_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.EndDate)
        
          '<pl>
          Dim AccountKeyArr
          '
          AccountKeyArr = Array(AccountKey, AccountKeyDebt, AccountKeyTransf)
        
          Dim frmAlimony, dlgAlimony
          Dim Prolog_Alimony
          '
          Set frmAlimony = _
            Application.FindComponent("gdc_frmUserComplexDocument147567052_119619099")
          '
          If Assigned(frmAlimony) Then
            Set dlgAlimony = _
              frmAlimony.FindComponent("gdc_dlgUserComplexDocument147567052_119619099")
          End If
          '
          If Assigned(dlgAlimony) Then
            Set Prolog_Alimony = dlgAlimony.FindComponent("usrg_Prolog_Alimony")
            If Assigned(Prolog_Alimony) Then
              If Prolog_Alimony.Checked = True Then
                'Расчет через Пролог-скрипт
                wg_FeeAlimonyCalc = _
                  wg_FeeAlimonyCalc_pl(wg_EmployeeCharge, TotalDocKey, FeeTypeKey, AccountKeyArr)
                Exit Function
              End If
            End If
          Else
            'Расчет через Пролог-скрипт
            wg_FeeAlimonyCalc = _
              wg_FeeAlimonyCalc_pl(wg_EmployeeCharge, TotalDocKey, FeeTypeKey, AccountKeyArr)
          End If
          '</pl>
        
        'Удаление результатов прошлого расчета
          set Creator = New TCreator
          set SQLUpdate = Creator.GetObject(nil, "TIBSQL", "")
          set SQLUpdate.Transaction = wg_EmployeeCharge.Transaction
          'Удаление результатов прошлого расчета из журнала долга
          SQLUpdate.SQL.Text = "DELETE " & _
            "FROM usr$wg_alimonydebt aldebt " & _
            "WHERE " & _
            "    usr$totaldockey = :totaldockey " & _
            "  AND aldebt.usr$alimonykey IN " & _
            " (SELECT al.documentkey " & _
            "  FROM usr$wg_alimony al " & _
            "  WHERE al.usr$emplkey = :emplkey) "
        
          SQLUpdate.ParamByName("totaldockey").AsInteger = TotalDocKey
          SQLUpdate.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.EmployeeKey
          SQLUpdate.ExecQuery
          SQLUpdate.Close
          'Удаление результатов прошлого расчета из журнала погашенных месяцев
          SQLUpdate.SQL.Text = "DELETE " & _
            "FROM usr$wg_alimonypayedmonth " & _
            "WHERE " & _
            "  usr$totaldockey = :totaldockey " & _
            "  AND usr$alimonydebtkey IN ( " & _
            "    SELECT aldebt.documentkey " & _
            "    FROM usr$wg_alimonydebt aldebt " & _
            "      JOIN usr$wg_alimony al ON aldebt.usr$alimonykey = al.documentkey AND al.usr$emplkey = :emplkey) "
        
          SQLUpdate.ParamByName("totaldockey").AsInteger = TotalDocKey
          SQLUpdate.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.EmployeeKey
          SQLUpdate.ExecQuery
          SQLUpdate.Close
        
          set MoveCard = wg_EmplMoveList.MoveCardList(wg_EmployeeCharge.EmployeeKey, null)._
            MoveCardByDate(wg_EmployeeCharge.EndDate)
          if Assigned(MoveCard) then
        
            'Журнал долгов по алиментам
            Set gdcAlimonyDebt = Creator.GetObject(nil, "TgdcUserDocument", "")
            gdcAlimonyDebt.SubType = "147072391_453357870"
            gdcAlimonyDebt.Transaction = wg_EmployeeCharge.Transaction
            gdcAlimonyDebt.Open
        
            'Определим кол-во отработанных часов (для определения текущего долга по алиментам в месяцах)
            if wg_WageSettings.Wage.Alimonymonthdebt then
        '      set Tbl = wg_TblCal.EmplTblCal(wg_EmployeeCharge.Employeekey, MoveCard.FirstMoveKey)
        '      AddDebtMontFlg = (Tbl.WorkDuration = 0)
              AddDebtMontFlg = False
            else
              AddDebtMontFlg = False
            end if
        
            'Класс для работы с алиментами
            set wg_Alimony = New Twg_Alimony
        
            wg_EmployeeCharge.FirstMoveKey = MoveCard.FirstMoveKey
            'Класс для расчета формул
            set wg_FoCal = New Twg_FoCal
            set wg_FoCal.ReadTransaction = wg_EmployeeCharge.ReadTransaction
            wg_FoCal.EmplKey   = wg_EmployeeCharge.Employeekey
            wg_FoCal.DateBegin = wg_EmployeeCharge.BeginDate
            wg_FoCal.DateEnd   = wg_EmployeeCharge.EndDate
            'Запрос для добавления погашенных месяцев в отдельный журнал
            SQLUpdate.SQL.Text = " INSERT INTO usr$wg_alimonypayedmonth " & _
              " (usr$totaldockey, usr$alimonydebtkey, usr$payedmonth) " & _
              " VALUES (:totaldockey, :alimonydebtkey, :payedmonth) "
        
            set IBSQL = Creator.GetObject(nil, "TIBSQL", "")
            IBSQL.Transaction = wg_EmployeeCharge.ReadTransaction
            'Выбираем документы о назначении алиментов
            IBSQL.SQL.Text = " SELECT calc.* " & _
              " FROM usr$wg_alimony calc " & _
              " LEFT JOIN GD_DOCUMENT d ON calc.DOCUMENTKEY = d.ID " & _
              " WHERE d.COMPANYKEY = <COMPANYKEY/> AND " & _
              "   calc.usr$emplkey = :emplkey AND " & _
              "   calc.usr$datebegin <= :dateend AND " & _
              "   (calc.usr$dateend >= :datebegin or calc.usr$dateend is NULL) " & _
              "   AND d.documenttypekey = :doctype " & _
              " ORDER BY calc.usr$datebegin "
            IBSQL.ParamByName("DateBegin").AsDateTime = wg_EmployeeCharge.BeginDate
            IBSQL.ParamByName("DateEnd").AsDateTime =  wg_EmployeeCharge.EndDate
            IBSQL.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.Employeekey
            IBSQL.ParamByName("doctype").AsInteger = gdcBaseManager.GetIdByRuidString("147067079_453357870")
            IBSQL.ExecQuery
        
            'Оставшееся деньги
            RestSum = wg_EmployeeCharge.Debit - wg_EmployeeCharge.Credit + wg_EmployeeCharge.PayedOut
        
           'Добавление алиментов в объект класса wg_Alimony
            AlimonyReservAll = 0
            while not IBSQL.Eof
              if AddDebtMontFlg then
              'Накопление долга по алиментам в месяцах, если сотрудник не проработал ни одного часа
                gdcAlimonyDebt.Insert
                gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
                gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = IBSQL.FieldByName("documentkey").AsInteger
                gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = 0
                gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 1
                gdcAlimonyDebt.Post
              else
                FormulaStr = Replace(Replace(IBSQL.FieldByName("usr$formula").AsString, ".", Application.DecimalSeparatorSys), ",", Application.DecimalSeparatorSys)
        
                Sum = wg_GetAlimonySum(wg_FoCal, FormulaStr, _
                      IBSQL.FieldByName("usr$datebegin").AsDateTime, wg_EmployeeCharge.BeginDate)
                'Проверка на бюджет прожиточного минимума
                if wg_EmployeeCharge.BeginDate >= DateSerial(2009, 5, 1) then
                  LivingWage = wg_MonthHour.LivingWage(wg_EmployeeCharge.BeginDate)
                  Count = IBSQL.FieldByName("USR$CHILDCOUNT").AsInteger
                  
                  if IBSQL.FieldByName("USR$LIVINGWAGEPERC").AsCurrency <= 0 then
                    if Count = 1 then
                      LivingWage = LivingWage / 2
                    elseif Count = 2 then
                      LivingWage = LivingWage * 75 / 100
                    elseif Count >= 3 then
        
                    end if
                  else
                    LivingWage = LivingWage *  IBSQL.FieldByName("USR$LIVINGWAGEPERC").AsCurrency / 100
                  end if
                  if Sum < LivingWage then
                    Sum = LivingWage
                  end if
                end if
               'Округление
                Sum = wg_RoundSum(FeeTypeKey, Sum)
                'Суммы для резерва денег по алименты и суммы для их перевода
                if not IBSQL.FieldByName("usr$transfertypekey").isNull then
                  ReservTransferSum = wg_RoundSum(wg_FeeType_TransferDed_ID, Sum * _
                    wg_TransferDed.Types(IBSQL.FieldByName("usr$transfertypekey").AsInteger).GetPercent(wg_EmployeeCharge.EndDate, Sum) / 100)
                else
                  ReservTransferSum = 0
                end if
                'Если резервировать некуда, то ...
                if AlimonyReservAll + Sum + ReservTransferSum > RestSum then
                  SumTmp = RestSum - AlimonyReservAll            'Резервируем все деньги, которые остаются
                else
                  SumTmp = Sum + ReservTransferSum
                end if
                if SumTmp < 0 then
                  SumTmp = 0
                end if
                'Добавление данных по алиментам в экземпляр класса
                call wg_Alimony.Add(IBSQL.FieldByName("documentkey").AsInteger, Sum, _
                               IBSQL.FieldByName("usr$restpercent").AsCurrency, _
                               IBSQL.FieldByName("usr$transfertypekey").Value, SumTmp) 'Sum + ReservTransferSum)
                AlimonyReservAll = AlimonyReservAll + SumTmp 'Sum + ReservTransferSum
              end if
              IBSQL.Next
            wend
            IBSQL.Close
            'Если по сотруднику было накапливание долга по месяцам, то расчет можно завершать
            if AddDebtMontFlg then
              gdcAlimonyDebt.Close
              wg_EmployeeCharge.FirstMoveKey = Null
              exit function
            end if
            'Выборка долгов по алиментам. Сортировка: по долгам в суммах, по дате начала долга
            IBSQL.SQL.Text = "SELECT line.documentkey, IIF(line.usr$debtsum > 0 and line.usr$debtsum > alrest.credit, 0, 1) AS debttype,  " & _
              "  total.usr$datebegin AS thedate, al.documentkey AS alimonykey,  " & _
              "  line.usr$debtsum, alrest.credit, line.usr$debtmonth, pmonth.mcount,  " & _
              "  al.usr$restpercent, al.usr$datebegin, al.usr$transfertypekey, al.usr$formula, al.usr$percent  " & _
              " FROM GD_DOCUMENT d " & _
              " LEFT JOIN usr$wg_alimony al ON al.DOCUMENTKEY = d.ID " & _
              "  LEFT JOIN usr$wg_alimonydebt line ON al.documentkey = line.usr$alimonykey " & _
              "  LEFT JOIN usr$wg_total total ON total.documentkey = line.usr$totaldockey  " & _
              "  LEFT JOIN USR$WG_P_TBLCHARGEBYDOC(al.usr$emplkey, :feetypekey, line.documentkey) alrest ON 1=1  " & _
              "  LEFT JOIN USR$WG_P_ALIMONYPAYEDMONTH(line.documentkey) pmonth ON 1=1  " & _
              "WHERE  " & _
              "  al.usr$emplkey = :emplkey  " & _
              "  AND (alrest.credit < line.usr$debtsum OR line.usr$debtmonth > pmonth.mcount)  " & _
              "  AND d.DOCUMENTTYPEKEY = :ruid  " & _
              "  AND total.USR$DATEBEGIN <= :DB  " & _
              "ORDER BY 2, 3 "
            IBSQL.ParamByName("feetypekey").AsInteger = wg_FeeType_AlimonyDebt_ID
            IBSQL.ParamByName("DB").AsDateTime = wg_EmployeeCharge.BeginDate
            IBSQL.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.Employeekey
            IBSQL.ParamByName("ruid").AsInteger = gdcBaseManager.GetIdByRuidString("147067079_453357870")
            IBSQL.ExecQuery
        '    while not (IBSQL.Eof or RestSum <= MustPaySum)
            'Добавление долгов по алиментам в объект класса wg_Alimony
            while not IBSQL.Eof
        
              if (IBSQL.FieldByName("usr$percent").AsCurrency > 0) and _
                 (IBSQL.FieldByName("usr$percent").AsCurrency < 100) then
                'sum = (RestSum - AlimonyReservAll) * IBSQL.FieldByName("usr$percent").AsCurrency / 100
                sum = (RestSum) * IBSQL.FieldByName("usr$percent").AsCurrency / 100
                if sum > (IBSQL.FieldByName("usr$debtsum").AsCurrency - IBSQL.FieldByName("credit").AsCurrency) then _
                  sum = IBSQL.FieldByName("usr$debtsum").AsCurrency  - IBSQL.FieldByName("credit").AsCurrency
                sum = wg_RoundSum(wg_FeeType_AlimonyDebt_ID, Sum)
              else
                sum = IBSQL.FieldByName("usr$debtsum").AsCurrency - IBSQL.FieldByName("credit").AsCurrency
              end if
              if sum < 0 then sum = 0
              'Если алиментов, по которым есть долг, нет в списке алиментов, то добавим алименты в список
              if not wg_Alimony.Exists(IBSQL.FieldByName("alimonykey").AsInteger) then
                call wg_Alimony.Add(IBSQL.FieldByName("alimonykey").AsInteger, 0, _
                             IBSQL.FieldByName("usr$restpercent").AsCurrency, _
                             IBSQL.FieldByName("usr$transfertypekey").Value, 0)
              end if
              AlimonyKey = IBSQL.FieldByName("alimonykey").AsInteger
              'Долг в месяцах
              DebtMonthCount = IBSQL.FieldByName("usr$debtmonth").AsInteger - IBSQL.FieldByName("mcount").AsInteger
        
              call wg_Alimony.ItemByID(AlimonyKey).Add(_
                IBSQL.FieldByName("documentkey").AsInteger, Sum, DebtMonthCount)
        
              if DebtMonthCount > 0 then
                if wg_Alimony.ItemByID(AlimonyKey).ForDebtMonthSum = 0 then
                  DebtMontSum = wg_GetAlimonySum(wg_FoCal, IBSQL.FieldByName("usr$formula").AsString, _
                        IBSQL.FieldByName("usr$datebegin").AsDateTime, wg_EmployeeCharge.BeginDate)
                 'Округление
                  DebtMontSum = wg_RoundSum(FeeTypeKey, DebtMontSum)
                  wg_Alimony.ItemByID(AlimonyKey).ForDebtMonthSum = DebtMontSum
                  DebtAllMontSum = DebtMontSum * DebtMonthCount
                else
                  DebtAllMontSum = wg_Alimony.ItemByID(AlimonyKey).ForDebtMonthSum * DebtMonthCount
                end if
              else
                DebtAllMontSum = 0
              end if
              wg_Alimony.ItemByID(AlimonyKey).MustPaySum = _
                wg_Alimony.ItemByID(AlimonyKey).MustPaySum + Sum + DebtAllMontSum
              IBSQL.Next
            wend
            IBSQL.Close
        
            AlimonyDebtAllSum = 0
            AlimonyAllSum = 0
            TransferAllSum = 0
            OverReservedSum = 0
            
        '    set gdcAlimonyDebt = Nothing
           'Цикл по алиментам
            for i = 0 to wg_Alimony.Count - 1
            'Определим сумму за перевод и сумму, которую может выплатить сотрудник (с учетом расходов за перевод)
              'Процент остатка. Т.е. процент, который нужно оставить сотруднику
              RestPercentSum = wg_Alimony.Item(i).RestPercent * _
                              (wg_EmployeeCharge.Debit - wg_EmployeeCharge.Credit + wg_EmployeeCharge.PayedOut) / 100
        
              'Сумма для резерва сумм других алиментов. Т.е. сначала нужно выплатить деньги по алиментам, а потом по их долгам
              'Из общей резервной суммы нужно исключить текущие алименты и те, которые уже расчитали
              AlimonyReservAll = AlimonyReservAll - wg_Alimony.Item(i).ReservedSum
        
        '      if AlimonyReservedSum > RestSum then
        '      end if
              OutArray = wg_CalcTransferSum(wg_Alimony.Item(i).MustPaySum, wg_Alimony.Item(i).TransferTypeKey, _
                wg_EmployeeCharge.BeginDate, RestSum - RestPercentSum - AlimonyReservAll)
              CanPaySum = OutArray(0)
              TransferSum = OutArray(1)
              'Занести сумму за пересылку алиментов в начисления по табелю
              if TransferSum > 0 then
                call wg_EmployeeCharge.AddCharge(0, TransferSum, Null, TotalDocKey, wg_FeeType_TransferDed_ID,_
                     wg_Alimony.Item(i).ID, wg_EmployeeCharge.BeginDate, 0, 0)
                     
                call wg_EmployeeCharge.AddChargeRegNew(0, TransferSum, TotalDocKey, wg_FeeType_TransferDed_ID, _
                     AccountKeyTransf, wg_EmployeeCharge.BeginDate, wg_Alimony.Item(i).ID)
        
              end if
        
              'Определение по каким документам возможны выплаты
              'Текущий долг по алиментам
              if wg_Alimony.Item(i).Sum > CanPaySum then
              'Добавление текущего долга в журнал долга по алиментам
        '        if not Assigned(gdcAlimonyDebt) then
        '          set gdcAlimonyDebt = Creator.GetObject(nil, "TgdcUserDocument", "")
        '          gdcAlimonyDebt.SubType = "147072391_453357870"
        '          gdcAlimonyDebt.Transaction = wg_EmployeeCharge.Transaction
        '          gdcAlimonyDebt.Open
        '        end if
                gdcAlimonyDebt.Insert
                gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
                gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = wg_Alimony.Item(i).ID
                gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = wg_Alimony.Item(i).Sum - CanPaySum
                gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 0
                gdcAlimonyDebt.Post
        
                AlimonyDebt = wg_Alimony.Item(i).Sum - CanPaySum
                AlimonySum = CanPaySum
              else
                AlimonySum = wg_Alimony.Item(i).Sum
              end if
              'Занести сумму выплаченных алиментов в начисления по табелю
              if AlimonySum > 0 then
                call wg_EmployeeCharge.AddCharge(0, AlimonySum, Null, TotalDocKey, FeeTypeKey,_
                  wg_Alimony.Item(i).ID, wg_EmployeeCharge.BeginDate, 0, 0)
                call wg_EmployeeCharge.AddChargeRegNew(0, AlimonySum, TotalDocKey, FeeTypeKey, _
                  AccountKey, wg_EmployeeCharge.BeginDate, wg_Alimony.Item(i).ID)
              end if
        
             'Гашение долгов в суммах
              TmpSum = CanPaySum - AlimonySum
              for j = 0 to wg_Alimony.Item(i).Count - 1
                if TmpSum > 0 then
                  if wg_Alimony.Item(i).Item(j).Sum > 0 then
                    if wg_Alimony.Item(i).Item(j).Sum <= TmpSum then
                      AlimonyDebtSum = wg_Alimony.Item(i).Item(j).Sum
                    else
                      AlimonyDebtSum = TmpSum
                    end if
                    'Занести сумму выплаченного долга в начисления по табелю
                    call wg_EmployeeCharge.AddCharge(0, AlimonyDebtSum, Null, TotalDocKey, wg_FeeType_AlimonyDebt_ID,_
                      wg_Alimony.Item(i).Item(j).ID, wg_EmployeeCharge.BeginDate, 0, 0)
                      
                    call wg_EmployeeCharge.AddChargeRegNew(0, AlimonyDebtSum, TotalDocKey, _
                      wg_FeeType_AlimonyDebt_ID, AccountKeyDebt, wg_EmployeeCharge.BeginDate, wg_Alimony.Item(i).Item(j).ID)
        
        
                    AlimonyDebtAllSum = AlimonyDebtAllSum + AlimonyDebtSum
                    TmpSum = TmpSum - AlimonyDebtSum 'wg_Alimony.Item(i).Item(j).Sum
                    end if
                else
                  exit for
                end if
              next
             'Гашение долгов в месяцах
              TmpSum = CanPaySum - AlimonySum - AlimonyDebtSum
              for j = 0 to wg_Alimony.Item(i).Count - 1
                if TmpSum > 0 then
                  if wg_Alimony.Item(i).Item(j).DebtMonth > 0 then
                    'Сумма за все месяцы
                    DebtAllMontSum = wg_Alimony.Item(i).ForDebtMonthSum * wg_Alimony.Item(i).Item(j).DebtMonth
        
                    if DebtAllMontSum <= TmpSum then
                      AlimonyMonthDebtSum = DebtAllMontSum
                      PayedMonthCount = wg_Alimony.Item(i).Item(j).DebtMonth
                    else
                      AlimonyMonthDebtSum = TmpSum
        '              PayedMonthCount = Int(DebtAllMontSum / wg_Alimony.Item(i).ForDebtMonthSum) + 1
                      PayedMonthCount = Int(AlimonyMonthDebtSum / wg_Alimony.Item(i).ForDebtMonthSum)
        
                      if AlimonyMonthDebtSum / wg_Alimony.Item(i).ForDebtMonthSum - PayedMonthCount > 0 then
                        PayedMonthCount = PayedMonthCount + 1
                      end if
        
        
                    end if
                    'Добавим сумму, которую должны выплатить по погашенным месяцам в журнал долгов,
                    ' иначе получится отрицательный кредит по долгу.
                    'TODO: это можно сделать в классе
                    gdcAlimonyDebt.Insert
                    gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
                    gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = wg_Alimony.Item(i).ID
                    gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 0
                    gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = PayedMonthCount * wg_Alimony.Item(i).ForDebtMonthSum
                    gdcAlimonyDebt.Post
                    'Занести сумму выплаченного долга в начисления по табелю на добавленный выше документ
                    call wg_EmployeeCharge.AddCharge(0, AlimonyMonthDebtSum, Null, TotalDocKey, wg_FeeType_AlimonyDebt_ID,_
                      gdcAlimonyDebt.ID, wg_EmployeeCharge.BeginDate, 0, 0)
                      
                    call wg_EmployeeCharge.AddChargeRegNew(0, AlimonyMonthDebtSum, TotalDocKey, _
                      wg_FeeType_AlimonyDebt_ID, AccountKeyDebt, wg_EmployeeCharge.BeginDate, gdcAlimonyDebt.ID)
        
                    'Занести погашенные месяцы в журнал
                    SQLUpdate.ParamByName("totaldockey").AsInteger = TotalDocKey
                    SQLUpdate.ParamByName("alimonydebtkey").AsInteger = wg_Alimony.Item(i).Item(j).ID
                    SQLUpdate.ParamByName("payedmonth").AsInteger = PayedMonthCount
                    SQLUpdate.ExecQuery
                    SQLUpdate.Close
        
                    AlimonyDebtAllSum = AlimonyDebtAllSum + AlimonyMonthDebtSum
                    TmpSum = TmpSum - AlimonyMonthDebtSum
                  end if
                else
                  exit for
                end if
              next
        
              AlimonyAllSum = AlimonyAllSum + AlimonySum
              TransferAllSum = TransferAllSum + TransferSum
              RestSum = RestSum - AlimonySum - AlimonyDebtSum - TransferSum
            next
        
        '  'Добавление сумм в журнал начислений
        '    'Алименты
        '    if AlimonyAllSum > 0 then
        '      AccountKey = wg_GetAccountKey(FeeTypeKey, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.EndDate)
        '      call wg_EmployeeCharge.AddChargeReg(0, AlimonyAllSum, TotalDocKey, FeeTypeKey, AccountKey, Null)
        '    end if
        '    'Выплаты долга по алиментам
        '    if AlimonyDebtAllSum > 0 then               'Сумма выплаты по долгу за алименты
        '      AccountKey = wg_GetAccountKey(wg_FeeType_AlimonyDebt_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.BeginDate)
        '      call wg_EmployeeCharge.AddChargeReg(0, AlimonyDebtAllSum, TotalDocKey, wg_FeeType_AlimonyDebt_ID, AccountKey, Null)
        '    end if
        '    'За почтовый перевод
        '    if TransferAllSum <> 0 then
        '      AccountKey = wg_GetAccountKey(wg_FeeType_TransferDed_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.BeginDate)
        '      call wg_EmployeeCharge.AddChargeReg(0, TransferAllSum, TotalDocKey, wg_FeeType_TransferDed_ID, AccountKey, Null)
        '    end if
        
            gdcAlimonyDebt.Close
        
            wg_FeeAlimonyCalc = AlimonyAllSum + AlimonyDebtAllSum + TransferAllSum
            wg_EmployeeCharge.FirstMoveKey = Null
          end if
        end function
        
        
      DISPLAYSCRIPT: | 
        WG_FEEALIMONYCALC
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: "Алименты, расчет"
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QRAAAAV0dfRU1QTE9ZRUVDSEFSR0URAAAAV0dfRU1QTE9ZRUVDSEFSR0UAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QLAAAAVE9UQUxET0NLRVkLAAAAVE9UQUxET0NLRVkA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QKAAAARkVFVFlQRUtFWQoAAABGRUVUWVBF
        S0VZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RQUlNUCwAAAE9CSl9GRUVEQVRBCwAAAE9C
        Sl9GRUVEQVRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RGTFBS
      INHERITEDRULE: 0
      USEDEBUGINFO: ~
      EDITIONDATE: 2014-10-15T14:22:08+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147019334_119619099 wg_MonthHour"
          - 
            ADDFUNCTIONKEY: "147168466_481542897 wg_GetAlimonySum"
          - 
            ADDFUNCTIONKEY: "147166442_481542897 wg_CalcTransferSum"
          - 
            ADDFUNCTIONKEY: "147804276_375143752 wg_RoundSum"
          - 
            ADDFUNCTIONKEY: "147743985_374487969 wg_EmplMoveList"
          - 
            ADDFUNCTIONKEY: "147170974_274788016 wg_TblCal"
          - 
            ADDFUNCTIONKEY: "147019760_119619099 wg_WageSettings"
          - 
            ADDFUNCTIONKEY: "147269378_531940465 wg_GetAccountKey"
          - 
            ADDFUNCTIONKEY: "195361376_166214404 wg_FeeAlimonyCalc_pl"
  - 
    Properties: 
      Class: "TgdcMacrosGroup"
      RUID: 147014502_256548741
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 198477540_219712981
    Fields: 
      HASCHILDREN: 1
      OBJECTNAME: "gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE"
      OBJECTPARENT: ~
      CLASSNAME: ""
      SUBTYPE: ""
      PARENT: ~
      NAME: "Локальные макросы"
      ISGLOBAL: 0
      DESCRIPTION: ~
      EDITIONDATE: 2004-10-20T15:07:58+03:00
  - 
    Properties: 
      Class: "TgdcDelphiObject"
      RUID: 147014287_256548741
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 198477540_219712981
    Fields: 
      NAME: "gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE"
      DESCRIPTION: ~
      PARENT: ~
      OBJECTTYPE: 0
      MACROSGROUPKEY: "147014502_256548741 Локальные макросы"
      REPORTGROUPKEY: "147014503_256548741 Отчеты(gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE)"
      CLASSNAME: ""
      OBJECTNAME: "gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE"
      SUBTYPE: ""
      EDITIONDATE: 2004-10-20T15:07:58+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 198477541_219712981
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 198477540_219712981
    Fields: 
      OBJECTNAME: "gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE"
      MODULE: "REPORTMAIN"
      LANGUAGE: "VBScript"
      NAME: "rp_FeeCalc_Prot"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        Function rp_FeeCalc_Prot(OwnerForm)
          Dim qProt
          Dim gdcObject, EmplKey, TotalDocKey, FeeTypeKey
        
          Set gdcObject = OwnerForm.gdcObject
          EmplKey = gdcObject.FieldByName("USR$EMPLKEY").AsInteger
          TotalDocKey = gdcObject.FieldByName("USR$TOTALDOCKEY").AsInteger
          FeeTypeKey = gdcObject.FieldByName("USR$FEETYPEKEY").AsInteger
          
          BaseQueryList.Clear
          Set qProt = BaseQueryList.Query(BaseQueryList.Add("Prot", 0))
          qProt.SQL = _
            " SELECT * FROM USR$WG_TBLCHARGE_PROT" & _
            " WHERE" & _
            "       USR$EMPLKEY = " & EmplKey & _
            "   AND USR$TOTALDOCKEY = " & TotalDocKey & _
            "   AND USR$FEETYPEKEY = " & FeeTypeKey
          qProt.Open
        
          Set rp_FeeCalc_Prot = BaseQueryList
        End Function
        
      DISPLAYSCRIPT: | 
        RP_FEECALC_PROT
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "147014287_256548741 gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QJAAAAT1dORVJGT1JNCQAAAE9XTkVSRk9STQAAAAAAAAAAAAAAAAsAAAAAAAAAAAAA
        AABGTlNURkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-09-09T12:30:03+03:00
  - 
    Properties: 
      Class: "TgdcReportGroup"
      RUID: 147014503_256548741
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 198477540_219712981
    Fields: 
      HASCHILDREN: 1
      PARENT: ~
      NAME: "Отчеты(gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE)"
      DESCRIPTION: ~
      USERGROUPNAME: "147014503_256548741"
      EDITIONDATE: 2000-01-01T00:00:00+03:00
  - 
    Properties: 
      Class: "TgdcReport"
      RUID: 198477540_219712981
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      NAME: "Протокол начисления/удержания"
      DESCRIPTION: ~
      FRQREFRESH: 1
      REPORTGROUPKEY: "147014503_256548741 Отчеты(gdc_frmAttrUserDefinedUSR_WG_TBLCHARGE)"
      PARAMFORMULAKEY: ~
      MAINFORMULAKEY: "198477541_219712981 rp_FeeCalc_Prot"
      EVENTFORMULAKEY: ~
      TEMPLATEKEY: "199205137_234369940 Зарплата.Начисления.Протокол"
      ISREBUILD: 1
      SERVERKEY: ~
      ISLOCALEXECUTE: 1
      PREVIEW: 1
      GLOBALREPORTKEY: ~
      EDITIONDATE: 2014-09-09T12:30:03+03:00
      DISPLAYINMENU: 1
      FOLDERKEY: ~
      MODALPREVIEW: 0
  - 
    Properties: 
      Class: "TgdcMacrosGroup"
      RUID: 147067101_481542897
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 199204906_234369940
    Fields: 
      HASCHILDREN: ~
      OBJECTNAME: "gdc_frmUserSimpleDocument147067079_453357870"
      OBJECTPARENT: ~
      CLASSNAME: ""
      SUBTYPE: ""
      PARENT: ~
      NAME: "Локальные макросы"
      ISGLOBAL: 0
      DESCRIPTION: ~
      EDITIONDATE: 2005-10-14T10:56:53+03:00
  - 
    Properties: 
      Class: "TgdcDelphiObject"
      RUID: 147067094_453357870
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 199204906_234369940
    Fields: 
      NAME: "gdc_frmUserSimpleDocument147067079_453357870"
      DESCRIPTION: ~
      PARENT: ~
      OBJECTTYPE: 0
      MACROSGROUPKEY: "147067101_481542897 Локальные макросы"
      REPORTGROUPKEY: "147067102_481542897 Отчеты(gdc_frmUserSimpleDocument147067079_453357870)1"
      CLASSNAME: ""
      OBJECTNAME: "gdc_frmUserSimpleDocument147067079_453357870"
      SUBTYPE: ""
      EDITIONDATE: 2005-10-14T10:56:53+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 199204907_234369940
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 199204906_234369940
    Fields: 
      OBJECTNAME: "gdc_frmUserSimpleDocument147067079_453357870"
      MODULE: "REPORTMAIN"
      LANGUAGE: "VBScript"
      NAME: "rp_Alimony_Prot"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        Function rp_Alimony_Prot(OwnerForm, TotalDocKey)
          Dim qProt
          Dim gdcObject, EmplKey, FeeTypeKey
        
          Set gdcObject = OwnerForm.gdcObject
          EmplKey = gdcObject.FieldByName("USR$EMPLKEY").AsInteger
          FeeTypeKey = gdcBaseManager.GetIDByRUIDString(wg_FeeType_Alimony_RUID)
        
          BaseQueryList.Clear
          Set qProt = BaseQueryList.Query(BaseQueryList.Add("Prot", 0))
          qProt.SQL = _
            " SELECT * FROM USR$WG_TBLCHARGE_PROT" & _
            " WHERE" & _
            "       USR$EMPLKEY = " & EmplKey & _
            "   AND USR$TOTALDOCKEY = " & TotalDocKey(0) & _
            "   AND USR$FEETYPEKEY = " & FeeTypeKey
          qProt.Open
        
          Set rp_Alimony_Prot = BaseQueryList
        End Function
        
      DISPLAYSCRIPT: | 
        RP_ALIMONY_PROT
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "147067094_453357870 gdc_frmUserSimpleDocument147067079_453357870"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QJAAAAT1dORVJGT1JNCQAAAE9XTkVSRk9STQAAAAAAAAAAAAAAAAsAAAAAAAAAAAAA
        AABGTlNUUFJTVAsAAABUT1RBTERPQ0tFWRMAAADI8u7j7uLu5SDt4Pfo8evl7ejlDAAAAFVTUiRX
        R19UT1RBTAgAAABVU1IkTkFNRQsAAABET0NVTUVOVEtFWQcdAAAAVVNSJERBVEVCRUdJTiA+PSAn
        MjAxNC0wMS0wMScAAAAAAgAAAF5ERk5TVEZMUFI=
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-09-09T12:26:47+03:00
  - 
    Properties: 
      Class: "TgdcTemplate"
      RUID: 199205137_234369940
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 199204906_234369940
    Fields: 
      NAME: "Зарплата.Начисления.Протокол"
      DESCRIPTION: ~
      TEMPLATEDATA: | 
        <?xml version="1.0" encoding="utf-8"?>
        <Tgs_fr4SingleReport Version="4.12.6" DotMatrixReport="False" IniFile="\Software\Fast Reports" PreviewOptions.Buttons="4095" PreviewOptions.Zoom="1" PrintOptions.Printer="По умолчанию" PrintOptions.PrintOnSheet="0" ReportOptions.CreateDate="41891,5121925926" ReportOptions.Description.Text="" ReportOptions.LastChange="41891,518099456" ScriptLanguage="PascalScript" ScriptText.Text="begin&#13;&#10;&#13;&#10;end." PropData="08446174617365747301010C2200000020446174615365743D2250524F542220446174615365744E616D653D2250524F54220000095661726961626C65730100055374796C650100">
          <TfrxDataPage Name="Data" Height="1000" Left="0" Top="0" Width="1000"/>
          <TfrxReportPage Name="Page1" PaperWidth="210" PaperHeight="297" PaperSize="9" LeftMargin="10" RightMargin="10" TopMargin="10" BottomMargin="10" ColumnWidth="0" ColumnPositions.Text="" HGuides.Text="" VGuides.Text="">
            <TfrxMasterData Name="MasterData1" Height="18,89765" Left="0" Top="18,89765" Width="718,1107" ColumnWidth="0" ColumnGap="0" DataSetName="PROT" RowCount="0" Stretched="True">
              <TfrxMemoView Name="PROTUSRDESCRIPTION" Left="3,77953" Top="0" Width="185,19697" Height="18,89765" ShowHint="False" StretchMode="smActualHeight" AutoWidth="True" AllowExpressions="False" DataField="USR$DESCRIPTION" DataSetName="PROT" Font.Charset="1" Font.Color="0" Font.Height="-12" Font.Name="Courier New" Font.Style="0" ParentFont="False" Text="[PROT.&#34;USR$DESCRIPTION&#34;]"/>
            </TfrxMasterData>
          </TfrxReportPage>
        </Tgs_fr4SingleReport>
        
      TEMPLATETYPE: "FR4"
      EDITIONDATE: 2014-09-09T12:30:03+03:00
  - 
    Properties: 
      Class: "TgdcReportGroup"
      RUID: 147067102_481542897
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 199204906_234369940
    Fields: 
      HASCHILDREN: 1
      PARENT: ~
      NAME: "Отчеты(gdc_frmUserSimpleDocument147067079_453357870)1"
      DESCRIPTION: ~
      USERGROUPNAME: "147067102_453357870"
      EDITIONDATE: 2000-01-01T00:00:00+03:00
  - 
    Properties: 
      Class: "TgdcReport"
      RUID: 199204906_234369940
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      NAME: "Протокол удержания алиментов"
      DESCRIPTION: ~
      FRQREFRESH: 1
      REPORTGROUPKEY: "147067102_481542897 Отчеты(gdc_frmUserSimpleDocument147067079_453357870)1"
      PARAMFORMULAKEY: ~
      MAINFORMULAKEY: "199204907_234369940 rp_Alimony_Prot"
      EVENTFORMULAKEY: ~
      TEMPLATEKEY: "199205137_234369940 Зарплата.Начисления.Протокол"
      ISREBUILD: 1
      SERVERKEY: ~
      ISLOCALEXECUTE: 1
      PREVIEW: 1
      GLOBALREPORTKEY: ~
      EDITIONDATE: 2014-09-09T12:26:47+03:00
      DISPLAYINMENU: 1
      FOLDERKEY: ~
      MODALPREVIEW: 0