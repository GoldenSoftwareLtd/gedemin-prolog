%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 195379689_166214404
  Name: "GS.Зарплата.Пролог.Алименты и штрафы"
  Caption: "Алименты и штрафы"
  Version: "1.0.0.47"
  Optional: False
  Internal: True
Uses: 
  - "151049506_187967073 GS.Зарплата.Пролог.Общие"
Objects: 
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362816_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 195362815_166214404
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee_in_params"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee_in_params
        %  входные параметры для twg_fee
        %
        
        %:- ['../common/lib', '../common/params'].
        
        twg_fee_in_params:-
            Type = in, Section = pCommon,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать общие входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pStartDate-'2012-01-01', pNullDate-'2100-01-01',
                pKindOfWork_Basic_ruid-'147017405,119619099',
                pPayFormSalary_ruid-'147009181,119619099',
                pFeeGroupKey_IncomeTax_ruid-'147021000,274788016',  % Облагается ПН
                pDocType_Total_ruid-'147567052,119619099',
                pTblCal_DocType_Plan_ruid-'147567935,1514418708',
                pTblCal_DocType_Fact_ruid-'187613422,1596169984'
                ]),
            fail.
        twg_fee_in_params:-
            Type = in, Section = pAlimony,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                Section-1,
                pFeeGroupKey_ruid-'147732349,375143752',           % Для алиментов
                pDocType_Alimony_ruid-'147067079,453357870',       % 04. Алименты
                pVar_BV_ruid-'147021364,256548741',           % БВ
                pVar_ForAlimony_ruid-'147068435,453357870',   % ДЛЯАЛИМЕНТОВ
                pBudget_ruid-'147073065,1224850260', % БПМ
                pFeeType_Alimony_ruid-'147567138,119619099',     % Алименты
                pFeeType_HolidayComp_ruid-'147076028,274788016', % Компенсация отпуска
                pFeeType_IncomeTax_ruid-'147567139,119619099',   % Подоходный
                pFeeType_TransferDed_ruid-'147069035,453357870', % Расходы по переводу
                pFeeType_AlimonyDebt_ruid-'147067786,453357870'  % Долг по алиментам
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 1,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pRestPercent-0.3, % Процент остатка
                pPercent-0.2,     % Процент списания долга
                pCalcDelta-100    % Дельта для расчета при нехватке средств
                ]),
            fail.
        twg_fee_in_params:-
            Type = fit, Section = 2,
            member(Scope, [
                wg_fee_alimony
                ]),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % Процент от БПМ (не менее) от количества детей
            member([ChildQtyCmp, LivingWagePerc],
                [ ['=:=0', 0.0], ['=1', 0.5], ['=2', 0.75], ['>=3', 1.0] ]),
            % записать входные параметры
            new_param_list(Scope, Type,
                [pChildQtyCmp-ChildQtyCmp, pLivingWagePerc-LivingWagePerc]),
            fail.
        twg_fee_in_params.
        
        :- twg_fee_in_params.
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-08-11T14:42:37+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362817_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 195362815_166214404
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee_sql"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee_sql
        %  спецификации и sql-шаблоны для базы знаний twg_fee
        %
        
        :-
            GetSQL = [gd_pl_ds/5, get_sql/5],
            %dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql(
                    [
                    usr_wg_MovementLine/15,
                    usr_wg_TblCharge/14,
                    usr_wg_TblCharge_Prev/12,
                    usr_wg_TblCharge_AlimonyDebt/9,
                    usr_wg_FeeType/4,
                    usr_wg_FeeType_Taxable/3,
                    usr_wg_FeeType_Dict/6,
                    usr_wg_TblCalLine/7,
                    usr_wg_TblCal_FlexLine/68,
                    usr_wg_FCRate/2,
                    gd_const_budget/2,
                    usr_wg_Variables/2,
                    usr_wg_Alimony/12,
                    usr_wg_TransferType/4,
                    usr_wg_TransferScale/3,
                    usr_wg_AlimonyDebt/8,
                    usr_wg_AlimonyDebt_delete/0,
                    -
                    ]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            member(Functor/Arity, ValidSQL),
            !.
        
        /* база знаний */
        
        gd_pl_ds(Scope, kb, usr_wg_MovementLine, 15, [
            fEmplKey-integer, fDocumentKey-integer, fFirstMoveKey-integer,
            fMoveYear-integer, fMoveMonth-integer, fDateBegin-date,
            fScheduleKey-integer, fMovementType-integer,
            fRate-float, fListNumber-string, fMSalary-float,
            fPayFormKey-integer, fSalaryKey-integer, fTSalary-float, fAvgWageRate-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_MovementLine(EmplKey, DocumentKey, FirstMoveKey,
        %   MoveYear, MoveMonth, DateBegin,
        %   ScheduleKey, MovementType, Rate, ListNumber, MSalary,
        %   PayFormKey, SalaryKey, TSalary, AvgWageRate)
        get_sql(Scope, kb, usr_wg_MovementLine/15,
        "\n SELECT \n \c
          ml.USR$EMPLKEY, \n \c
          ml.DOCUMENTKEY, \n \c
          ml.USR$FIRSTMOVE AS FirstMoveKey, \n \c
          EXTRACT(YEAR FROM ml.USR$DATEBEGIN) AS MoveYear, \n \c
          EXTRACT(MONTH FROM ml.USR$DATEBEGIN) AS MoveMonth, \n \c
          ml.USR$DATEBEGIN, \n \c
          ml.USR$SCHEDULEKEY, \n \c
          ml.USR$MOVEMENTTYPE, \n \c
          COALESCE(ml.USR$RATE, 0) AS Rate, \n \c
          ml.USR$LISTNUMBER, \n \c
          COALESCE(ml.USR$MSALARY, 0) AS MSalary, \n \c
          COALESCE(ml.USR$PAYFORMKEY, 0) AS PayFormKey, \n \c
          (SELECT id FROM GD_P_GETID(pPayFormSalary_ruid)) AS SalaryKey, \n \c
          COALESCE(ml.USR$TSALARY, 0) AS TSalary, \n \c
          8 * COALESCE(USR$THOURRATE, 0) AS AvgWageRate \n \c
        FROM \n \c
          USR$WG_MOVEMENTLINE ml \n \c
        JOIN \n \c
          USR$WG_KINDOFWORK kw \n \c
            ON kw.ID = ml.USR$KINDOFWORKKEY \n \c
        WHERE \n \c
          ml.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          ml.USR$KINDOFWORKKEY = \n \c
            (SELECT id FROM GD_P_GETID(pKindOfWork_Basic_ruid)) \n \c
        ORDER BY \n \c
          ml.USR$EMPLKEY, \n \c
          ml.USR$FIRSTMOVE, \n \c
          ml.USR$DATEBEGIN \n \c
        ",
            [
            pEmplKey-_, pPayFormSalary_ruid-_, pKindOfWork_Basic_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge, 14, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fDOW-float, fHOW-float,
            fTotalYear-integer, fTotalMonth-integer, fTotalDateBegin-date
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCharge(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, DOW, HOW, TotalYear, TotalMonth, TotalDateBegin)
        get_sql(Scope, kb, usr_wg_TblCharge/14,
        "\n SELECT \n \c
          tch.USR$DOCUMENTKEY, \n \c
          tch.USR$EMPLKEY, \n \c
          tch.USR$FIRSTMOVEKEY, \n \c
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear, \n \c
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth, \n \c
          tch.USR$DATEBEGIN, \n \c
          tch.USR$DEBIT, \n \c
          tch.USR$CREDIT, \n \c
          tch.USR$FEETYPEKEY, \n \c
          tch.USR$DOW, \n \c
          tch.USR$HOW, \n \c
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS TotalYear, \n \c
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS TotalMonth, \n \c
          t.USR$DATEBEGIN AS TotalDateBegin \n \c
        FROM \n \c
          USR$WG_TBLCHARGE tch \n \c
        JOIN \n \c
          USR$WG_TOTAL t \n \c
            ON t.DOCUMENTKEY = tch.USR$TOTALDOCKEY \n \c
        WHERE \n \c
          tch.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          tch.USR$TOTALDOCKEY = pTotalDocKey \n \c
        ",
            [
            pEmplKey-_, pTotalDocKey-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge_Prev, 12, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer,
            fTotalYear-integer, fTotalMonth-integer, fTotalDateBegin-date
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCharge_Prev(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey, TotalYear, TotalMonth, TotalDateBegin)
        get_sql(Scope, kb, usr_wg_TblCharge_Prev/12,
        "\n SELECT \n \c
          tch.USR$DOCUMENTKEY, \n \c
          tch.USR$EMPLKEY, \n \c
          tch.USR$FIRSTMOVEKEY, \n \c
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear, \n \c
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth, \n \c
          tch.USR$DATEBEGIN, \n \c
          tch.USR$DEBIT, \n \c
          tch.USR$CREDIT, \n \c
          tch.USR$FEETYPEKEY, \n \c
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS TotalYear, \n \c
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS TotalMonth, \n \c
          t.USR$DATEBEGIN AS TotalDateBegin \n \c
        FROM \n \c
          USR$WG_TBLCHARGE tch \n \c
        JOIN \n \c
          USR$WG_TOTAL t \n \c
            ON t.DOCUMENTKEY = tch.USR$TOTALDOCKEY \n \c
        WHERE \n \c
          tch.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          t.USR$DATEBEGIN >= 'pDatePrevCalcFrom' \n \c
          AND \n \c
          t.USR$DATEBEGIN < 'pDatePrevCalcTo' \n \c
        ",
            [
            pEmplKey-_,
            pDatePrevCalcFrom-_, pDatePrevCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCharge_AlimonyDebt, 9, [
            fDocKey-integer, fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fCredit-float, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCharge_AlimonyDebt(DocKey, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, Debit, Credit, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_TblCharge_AlimonyDebt/9,
        "\n SELECT \n \c
          tch.USR$DOCUMENTKEY, \n \c
          tch.USR$EMPLKEY, \n \c
          tch.USR$FIRSTMOVEKEY, \n \c
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear, \n \c
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth, \n \c
          tch.USR$DATEBEGIN, \n \c
          tch.USR$DEBIT, \n \c
          tch.USR$CREDIT, \n \c
          tch.USR$FEETYPEKEY \n \c
        FROM \n \c
          USR$WG_TBLCHARGE tch \n \c
        WHERE \n \c
          tch.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          tch.USR$DATEBEGIN < 'pDateCalcFrom' \n \c
          AND \n \c
          tch.USR$FEETYPEKEY = \n \c
            (SELECT id FROM GD_P_GETID(pFeeType_AlimonyDebt_ruid)) \n \c
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pFeeType_AlimonyDebt_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType, 4, [
            fEmplKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer, fAvgDayHOW-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_FeeType(EmplKey, FeeGroupKey, FeeTypeKey, AvgDayHOW)
        get_sql(Scope, kb, usr_wg_FeeType/4,
        "\n SELECT \n \c
          pEmplKey AS EmplKey,  \n \c
          ft.USR$WG_FEEGROUPKEY, \n \c
          ft.USR$WG_FEETYPEKEY, \n \c
          ft_avg.USR$AVGDAYHOW \n \c
        FROM \n \c
          USR$CROSS179_256548741 ft \n \c
        JOIN \n \c
          USR$WG_FEETYPE ft_avg \n \c
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY \n \c
        WHERE \n \c
          ft.USR$WG_FEEGROUPKEY = \n \c
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_ruid)) \n \c
        ",
            [
            pEmplKey-_, pFeeGroupKey_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Taxable, 3, [
            fEmplKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_FeeType_Taxable(EmplKey, FeeGroupKey, FeeTypeKey)
        get_sql(Scope, kb, usr_wg_FeeType_Taxable/3,
        "\n SELECT \n \c
          pEmplKey AS EmplKey,  \n \c
          ft.USR$WG_FEEGROUPKEY, \n \c
          ft.USR$WG_FEETYPEKEY \n \c
        FROM \n \c
          USR$CROSS179_256548741 ft \n \c
        JOIN \n \c
          USR$WG_FEETYPE ft_avg \n \c
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY \n \c
        WHERE \n \c
          ft.USR$WG_FEEGROUPKEY = \n \c
            (SELECT id FROM GD_P_GETID(pFeeGroupKey_IncomeTax_ruid)) \n \c
        ",
            [
            pEmplKey-_, pFeeGroupKey_IncomeTax_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_FeeType_Dict, 6, [
            fID-integer, fAlias-string, fName-string,
            fRoundByFeeType-integer, fRoundType-integer, fRoundValue-float
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_FeeType_Dict(ID, Alias, Name, RoundByFeeType, RoundType, RoundValue)
        get_sql(Scope, kb, usr_wg_FeeType_Dict/6,
        "\n SELECT \n \c
          ft.ID, \n \c
          CASE ft.ID \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pFeeType_Alimony_ruid)) \n \c
                THEN 'ftAlimony' \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pFeeType_HolidayComp_ruid)) \n \c
                THEN 'ftHolidayComp' \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pFeeType_IncomeTax_ruid)) \n \c
                THEN 'ftIncomeTax' \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pFeeType_TransferDed_ruid)) \n \c
                THEN 'ftTransferDed' \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pFeeType_AlimonyDebt_ruid)) \n \c
                THEN 'ftAlimonyDebt' \n \c
            ELSE \n \c
                'unknown' \n \c
          END \n \c
            AS Alias, \n \c
          USR$NAME, \n \c
          USR$ROUNDBYFEETYPE, \n \c
          USR$ROUNDTYPE, \n \c
          USR$ROUNDVALUE \n \c
        FROM \n \c
          USR$WG_FEETYPE ft \n \c
        ",
            [
            pFeeType_Alimony_ruid-_,
            pFeeType_HolidayComp_ruid-_,
            pFeeType_IncomeTax_ruid-_,
            pFeeType_TransferDed_ruid-_,
            pFeeType_AlimonyDebt_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCalLine, 7, [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDate-date,
            fDuration-float, fHoureType-integer
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCalLine(EmplKey, FirstMoveKey, CalYear, CalMonth, Date, Duration, HoureType)
        get_sql(Scope, kb, usr_wg_TblCalLine/7,
        "\n SELECT \n \c
          tc.USR$EMPLKEY, \n \c
          tc.USR$FIRSTMOVEKEY, \n \c
          EXTRACT(YEAR FROM tcl.USR$DATE) AS CalYear, \n \c
          EXTRACT(MONTH FROM tcl.USR$DATE) AS CalMonth, \n \c
          tcl.USR$DATE, \n \c
          tcl.USR$DURATION, \n \c
          tcl.USR$HOURTYPE \n \c
        FROM \n \c
          USR$WG_TBLCAL tc \n \c
        JOIN \n \c
          USR$WG_TBLCALLINE tcl \n \c
            ON tcl.MASTERKEY = tc.DOCUMENTKEY \n \c
        WHERE \n \c
          tc.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          tcl.USR$DATE >= 'pDateCalcFrom' \n \c
          AND \n \c
          tcl.USR$DATE < 'pDateCalcTo' \n \c
        ORDER BY \n \c
          tc.USR$EMPLKEY, \n \c
          tc.USR$FIRSTMOVEKEY, \n \c
          tcl.USR$DATE \n \c
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, [
            fFlexType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fS1-variant, fH1-variant, fS2-variant, fH2-variant,
            fS3-variant, fH3-variant, fS4-variant, fH4-variant,
            fS5-variant, fH5-variant, fS6-variant, fH6-variant,
            fS7-variant, fH7-variant, fS8-variant, fH8-variant,
            fS9-variant, fH9-variant, fS10-variant, fH10-variant,
            fS11-variant, fH11-variant, fS12-variant, fH12-variant,
            fS13-variant, fH13-variant, fS14-variant, fH14-variant,
            fS15-variant, fH15-variant, fS16-variant, fH16-variant,
            fS17-variant, fH17-variant, fS18-variant, fH18-variant,
            fS19-variant, fH19-variant, fS20-variant, fH20-variant,
            fS21-variant, fH21-variant, fS22-variant, fH22-variant,
            fS23-variant, fH23-variant, fS24-variant, fH24-variant,
            fS25-variant, fH25-variant, fS26-variant, fH26-variant,
            fS27-variant, fH27-variant, fS28-variant, fH28-variant,
            fS29-variant, fH29-variant, fS30-variant, fH30-variant,
            fS31-variant, fH31-variant
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        % usr_wg_TblCal_FlexLine(FlexType, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, S1, H1, ..., S31, H31)
        get_sql(Scope, kb, usr_wg_TblCal_FlexLine/68,
        "\n SELECT \n \c
          CASE gd.DOCUMENTTYPEKEY \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Plan_ruid)) \n \c
                THEN 'plan' \n \c
            WHEN \n \c
              (SELECT id FROM GD_P_GETID(pTblCal_DocType_Fact_ruid)) \n \c
                THEN 'fact' \n \c
            ELSE \n \c
                'unknown' \n \c
          END \n \c
            AS FlexType, \n \c
          tcfl.USR$EMPLKEY, \n \c
          tcfl.USR$FIRSTMOVEKEY, \n \c
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear, \n \c
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth, \n \c
          t.USR$DATEBEGIN, \n \c
          tcfl.USR$S1, tcfl.USR$H1, tcfl.USR$S2, tcfl.USR$H2, \n \c
          tcfl.USR$S3, tcfl.USR$H3, tcfl.USR$S4, tcfl.USR$H4, \n \c
          tcfl.USR$S5, tcfl.USR$H5, tcfl.USR$S6, tcfl.USR$H6, \n \c
          tcfl.USR$S7, tcfl.USR$H7, tcfl.USR$S8, tcfl.USR$H8, \n \c
          tcfl.USR$S9, tcfl.USR$H9, tcfl.USR$S10, tcfl.USR$H10, \n \c
          tcfl.USR$S11, tcfl.USR$H11, tcfl.USR$S12, tcfl.USR$H12, \n \c
          tcfl.USR$S13, tcfl.USR$H13, tcfl.USR$S14, tcfl.USR$H14, \n \c
          tcfl.USR$S15, tcfl.USR$H15, tcfl.USR$S16, tcfl.USR$H16, \n \c
          tcfl.USR$S17, tcfl.USR$H17, tcfl.USR$S18, tcfl.USR$H18, \n \c
          tcfl.USR$S19, tcfl.USR$H19, tcfl.USR$S20, tcfl.USR$H20, \n \c
          tcfl.USR$S21, tcfl.USR$H21, tcfl.USR$S22, tcfl.USR$H22, \n \c
          tcfl.USR$S23, tcfl.USR$H23, tcfl.USR$S24, tcfl.USR$H24, \n \c
          tcfl.USR$S25, tcfl.USR$H25, tcfl.USR$S26, tcfl.USR$H26, \n \c
          tcfl.USR$S27, tcfl.USR$H27, tcfl.USR$S28, tcfl.USR$H28, \n \c
          tcfl.USR$S29, tcfl.USR$H29, tcfl.USR$S30, tcfl.USR$H30, \n \c
          tcfl.USR$S31, tcfl.USR$H31 \n \c
        FROM \n \c
          GD_DOCUMENT gd \n \c
        JOIN \n \c
          USR$WG_TBLCAL_FLEXLINE tcfl \n \c
            ON gd.ID = tcfl.DOCUMENTKEY \n \c
        JOIN \n \c
          USR$WG_TBLCAL_FLEX tcf \n \c
            ON tcf.DOCUMENTKEY = tcfl.MASTERKEY \n \c
        JOIN \n \c
          USR$WG_TOTAL t \n \c
            ON t.DOCUMENTKEY = tcf.USR$TOTALDOCKEY \n \c
        WHERE \n \c
          tcfl.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          t.USR$DATEBEGIN >= 'pDateCalcFrom' \n \c
          AND \n \c
          t.USR$DATEBEGIN < 'pDateCalcTo' \n \c
         ORDER BY \n \c
           tcfl.USR$EMPLKEY, \n \c
           tcfl.USR$FIRSTMOVEKEY, \n \c
           t.USR$DATEBEGIN \n \c
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_,
            pTblCal_DocType_Plan_ruid-_, pTblCal_DocType_Fact_ruid-_
            ]) :-
            memberchk(Scope, [
                wg_fee_alimony
                ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_FCRate, 2, [
            fDate-date, fMinWage-float
            ]).
        % usr_wg_FCRate(Date, MinWage)
        get_sql(wg_fee_alimony, kb, usr_wg_FCRate/2,
        "\n SELECT \n \c
          fc.USR$WG_DATE, \n \c
          fc.USR$WG_MINWAGE \n \c
        FROM \n \c
          USR$WG_FCRATE fc \n \c
        WHERE \n \c
          fc.USR$WG_DATE >= 'pStartDate' \n \c
        ORDER BY \n \c
          fc.USR$WG_DATE \n \c
        ",
            [
            pStartDate-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, gd_const_budget, 2, [
            fConstDate-date, fBudget-float
            ]).
        % gd_const_budget(ConstDate, Budget)
        get_sql(wg_fee_alimony, kb, gd_const_budget/2,
        "\n SELECT \n \c
          cv.CONSTDATE, \n \c
          CAST(cv.CONSTVALUE AS DECIMAL(15,4)) AS Budget \n \c
        FROM \n \c
          GD_CONSTVALUE cv \n \c
        JOIN \n \c
          GD_CONST c \n \c
            ON c.ID  =  cv.CONSTKEY \n \c
        WHERE \n \c
          cv.CONSTDATE >= 'pStartDate' \n \c
          AND \n \c
          cv.CONSTKEY = \n \c
            (SELECT id FROM GD_P_GETID(pBudget_ruid)) \n \c
        ORDER BY \n \c
          cv.CONSTDATE \n \c
        ",
            [
            pStartDate-_, pBudget_ruid-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_Variables, 2, [
            fAlias-string, fName-string
            ]).
        % usr_wg_Varuables(Alias, Name)
        get_sql(wg_fee_alimony, kb, usr_wg_Variables/2,
        "\n SELECT \n \c
          'vBV' AS Alias, \n \c
          USR$NAME \n \c
        FROM \n \c
          USR$WG_VARIABLES \n \c
        WHERE \n \c
          ID = (SELECT id FROM GD_P_GETID(pVar_BV_ruid)) \n \c
        UNION ALL \n \c
        SELECT \n \c
          'vForAlimony' AS Alias, \n \c
          USR$NAME \n \c
        FROM \n \c
          USR$WG_VARIABLES \n \c
        WHERE \n \c
          ID = (SELECT id FROM GD_P_GETID(pVar_ForAlimony_ruid)) \n \c
        ",
            [
            pVar_BV_ruid-_, pVar_ForAlimony_ruid-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_Alimony, 12, [
            fDocKey-integer, fEmplKey-integer,
            fDateBegin-date, fDateEnd-date,
            fDebtSum-float, fFormula-string,
            fTransferTypeKey-integer, fRecipient-integer,
            fRestPercent-float, fChildCount-integer,
            fPercent-float, fLivingWagePerc-float
            ]).
        % usr_wg_Alimony(DocKey, EmplKey, DateBegin, DateEnd, DebtSum, Formula, TransferTypeKey, Recipient, RestPercent, ChildCount, Percent, LivingWagePerc)
        get_sql(wg_fee_alimony, kb, usr_wg_Alimony/12,
        "\n SELECT \n \c
          calc.DOCUMENTKEY, \n \c
          calc.USR$EMPLKEY, \n \c
          calc.USR$DATEBEGIN, \n \c
          COALESCE(calc.USR$DATEEND, CAST('pNullDate' AS DATE)) AS DateEnd, \n \c
          calc.USR$DEBTSUM, \n \c
          calc.USR$FORMULA, \n \c
          calc.USR$TRANSFERTYPEKEY, \n \c
          calc.USR$RECIPIENT, \n \c
          calc.USR$RESTPERCENT, \n \c
          calc.USR$CHILDCOUNT, \n \c
          calc.USR$PERCENT, \n \c
          calc.USR$LIVINGWAGEPERC \n \c
        FROM \n \c
          USR$WG_ALIMONY calc \n \c
        JOIN \n \c
          GD_DOCUMENT d
            ON calc.DOCUMENTKEY = d.ID \n \c
        WHERE \n \c
          d.COMPANYKEY = <COMPANYKEY/> \n \c
          AND \n \c
          d.DOCUMENTTYPEKEY = (SELECT id FROM GD_P_GETID(pDocType_Alimony_ruid)) \n \c
          AND \n \c
          calc.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          calc.USR$DATEBEGIN < 'pDateCalcTo' \n \c
          AND \n \c
          COALESCE(calc.USR$DATEEND, 'pNullDate') >= 'pDateCalcFrom' \n \c
        ORDER BY \n \c
          calc.USR$DATEBEGIN \n \c
        ",
            [
            pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_, pDocType_Alimony_ruid-_,
            pNullDate-_
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_TransferType, 4, [
            fID-integer, fParent-integer,
            fDateBegin-date, fName-string
            ]).
        % usr_wg_TransferType(ID, Parent, DateBegin, Name)
        get_sql(wg_fee_alimony, kb, usr_wg_TransferType/4,
        "\n SELECT \n \c
          tt.ID, \n \c
          COALESCE(tt.PARENT, 0) AS Parent, \n \c
          COALESCE(tt.USR$DATE, current_date) AS DateBegin, \n \c
          tt.USR$NAME \n \c
        FROM \n \c
          USR$WG_TRANSFERTYPE tt \n \c
        ORDER BY \n \c
          Parent, DateBegin, tt.ID \n \c
        ",
            [
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_TransferScale, 3, [
            fTranferTypeKey-integer,
            fStartSum-float, fPercent-float
            ]).
        % usr_wg_TransferScale(TranferTypeKey, StartSum, Percent)
        get_sql(wg_fee_alimony, kb, usr_wg_TransferScale/3,
        "\n SELECT \n \c
          ts.USR$TRANSFERTYPEKEY, \n \c
          COALESCE(ts.USR$STARTSUM, 0) AS StartSum, \n \c
          COALESCE(ts.USR$PERCENT, 0) AS Percent \n \c
        FROM \n \c
          USR$WG_TRANSFERSCALE ts \n \c
        ORDER BY \n \c
          ts.USR$TRANSFERTYPEKEY, StartSum \n \c
        ",
            [
            ]).
        
        gd_pl_ds(wg_fee_alimony, kb, usr_wg_AlimonyDebt, 8, [
            fDocKey-integer, fEmplKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fAlimonyKey-integer, fTotalDocKey-integer, fDebtSum-float
            ]).
        % usr_wg_AlimonyDebt(DocKey, EmplKey, CalYear, CalMonth, DateBegin, AlimonyKey, TotalDocKey, DebtSum)
        get_sql(wg_fee_alimony, kb, usr_wg_AlimonyDebt/8,
        "\n SELECT \n \c
          aldebt.DOCUMENTKEY, \n \c
          al.USR$EMPLKEY, \n \c
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear, \n \c
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth, \n \c
          t.USR$DATEBEGIN, \n \c
          aldebt.USR$ALIMONYKEY, \n \c
          aldebt.USR$TOTALDOCKEY, \n \c
          aldebt.USR$DEBTSUM \n \c
        FROM \n \c
          USR$WG_ALIMONYDEBT aldebt \n \c
        JOIN \n \c
          USR$WG_ALIMONY al \n \c
            ON al.DOCUMENTKEY = aldebt.USR$ALIMONYKEY \n \c
        JOIN \n \c
          USR$WG_TOTAL t \n \c
            ON t.DOCUMENTKEY = aldebt.USR$TOTALDOCKEY \n \c
        WHERE \n \c
          al.USR$EMPLKEY = pEmplKey \n \c
          AND \n \c
          t.USR$DATEBEGIN < 'pDateCalcFrom' \n \c
        ORDER BY \n \c
          t.USR$DATEBEGIN \n \c
        ",
            [
            pEmplKey-_, pDateCalcFrom-_
            ]).
        
        /* удаление данных */
        
        gd_pl_ds(wg_fee_alimony, cmd, usr_wg_AlimonyDebt_delete, 0, []).
        % usr_wg_AlimonyDebt_delete
        get_sql(wg_fee_alimony, cmd, usr_wg_AlimonyDebt_delete/0,
        "\n DELETE \n \c
        FROM \n \c
          USR$WG_ALIMONYDEBT aldebt \n \c
        WHERE \n \c
          aldebt.USR$TOTALDOCKEY = pTotalDocKey \n \c
          AND \n \c
          aldebt.USR$ALIMONYKEY IN \n \c
            (SELECT al.DOCUMENTKEY FROM USR$WG_ALIMONY al WHERE al.USR$EMPLKEY = pEmplKey) \n \c
        ",
            [
            pEmplKey-_, pTotalDocKey-_
            ]).
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-08-11T14:47:05+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195362815_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_fee"
      COMMENT: ~
      SCRIPT: | 
        %% twg_fee
        % Зарплата и Отдел кадров -> Зарплата -> 02. Прочие доходы, расходы, льготы
        %    04. Алименты
        %    11. Штрафы
        %
        
        :- retractall(debug_mode).
        
        % ! при использовании в ТП Гедымин
        % ! для begin & end debug mode section
        % ! убрать символ процента из первой позиции
        /* %%% begin debug mode section
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        %#INCLUDE params
        %#INCLUDE wg_data_mix
        :- ['../common/lib', '../common/params', '../common/wg_data_mix'].
        %#INCLUDE twg_fee_sql
        :- [twg_fee_sql].
        %#INCLUDE twg_fee_in_params
        %:- [twg_fee_in_params].
        %%
        
        %% facts
        :-  init_data,
            working_directory(_, 'kb'),
            [
            usr_wg_MovementLine,
            usr_wg_TblCharge,
            usr_wg_TblCharge_Prev,
            usr_wg_TblCharge_Extra,
            usr_wg_TblCharge_AlimonyDebt,
            usr_wg_FeeType,
            usr_wg_FeeType_Taxable,
            usr_wg_FeeType_Dict,
            usr_wg_TblCalLine,
            usr_wg_TblCal_FlexLine,
            usr_wg_FCRate,
            gd_const_budget,
            usr_wg_Variables,
            usr_wg_Alimony,
            usr_wg_TransferType,
            usr_wg_TransferScale,
            usr_wg_AlimonyDebt
            ],
            working_directory(_, '..').
        %%
        
        %% dynamic state
        :- ['kb/param_list'].
        %%
        
        %% flag
        :- assertz(debug_mode).
        %%
        
        % ! при использовании в ТП Гедымин
        % ! для begin & end debug mode section
        % ! убрать символ процента из первой позиции
        */ %%% end debug mode section
        
        :- ps32k_lgt(64, 128, 64).
        
        /* реализация - расчет */
        
        % расчет итогового начисления
        fee_calc(Scope) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            % для каждого сотрудника
            get_param(Scope, in, pEmplKey-EmplKey),
            % выполнить расчет
            fee_calc(Scope, EmplKey),
            % найти альтернативу
            fail.
        fee_calc(_) :-
            % больше альтернатив нет
            !.
        
        % выполнить расчет
        fee_calc(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, begin-Section),
            % удалить временные данные по расчету
            forall( get_param(Scope, Type, pEmplKey-EmplKey, Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % расчет табеля
            calc_tab(Scope, EmplKey),
            % расчет суммы
            calc_amount(Scope, EmplKey),
            % расчет формулы
            calc_formula(Scope, EmplKey),
            % расчет расходов по переводу
            calc_transf(Scope, EmplKey, 1),
            % контроль остатка
            check_rest(Scope, EmplKey),
            % начисление долгов
            add_debt(Scope, EmplKey),
            % списание долгов
            drop_debt(Scope, EmplKey),
            % расчет итога
            calc_total(Scope, EmplKey),
            % записать отладочную информацию
            param_list_debug(Scope, end-Section),
            !.
        
        % расчет табеля
        calc_tab(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcTab,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % последний прием на работу
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_last_hire(Scope, PK, DateIn),
            % начало итогового месяца
            get_param_list(Scope, in, [pEmplKey-EmplKey, pDateBegin-DateBegin]),
            DateBegin @>= DateIn,
            % Общий табель за итоговый месяц
            atom_date(DateBegin, date(Y, M, _)),
            calc_month_tab(Scope, PK, Y-M, TabDays),
            sum_days_houres(TabDays, TDays, THoures),
            % спецификация временных данных
            append([ [Section-1], PK,
                     [pYM-Y-M, pTDays-TDays, pTHoures-THoures] ],
                        TabPairs),
            % добавить временные данные
            new_param_list(Scope, Type, TabPairs),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fDateBegin-ADateBegin, fDateEnd-ADateEnd ],
            % спецификация временных данных
            append([ [Section-2], PK,
                     [pAlimonyKey-AlimonyKey, pDateBegin-ADateBegin, pDateEnd-ADateEnd],
                     [pYM-Y-M, pTDays-ADays, pTHoures-AHoures, pTCoef-TCoef] ],
                        AlimonyPairs),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % посчитать Дни и Часы для периода действия алиментов
                      sum_days_houres(TabDays, ADays, AHoures, ADateBegin, ADateEnd),
                      % вычислить Коеффициент от Общего табеля
                      catch( TCoef is AHoures / THoures, _, TCoef = 1),
                      % добавить временные данные
                      new_param_list(Scope, Type, AlimonyPairs)
                    )
                  ),
            !.
        
        % расчет суммы
        calc_amount(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcAmount,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация Начислений по Предыдущему периоду
            SpecTblChargePrev = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fDebit-Debit, fCredit-Credit,
                        fFeeTypeKey-FeeTypeKey ],
            % спецификация временных данных
            AmountPaidPairs = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyAmountPaid-AlimonyAmountPaid,
                        pAlimonyAmount-AlimonyAmount, pAlimonyCoef-AlimonyCoef ],
            SumPaidPairs = [
                        Section-5, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonySumPaid-AlimonySumPaid,
                        pAlimonySum-AlimonySum, pAlimonyCoef-AlimonyCoef ],
            % сумма по Предыдущему периоду
            calc_amount(Scope, EmplKey, 1),
            get_param_list(Scope, Type, [
                            Section-1, pEmplKey-EmplKey,
                            pForAlimony-ForAlimony1 ]),
            % сумма по Предыдущему периоду
            % где дата Зачисления соответствует Текущему периоду
            calc_amount(Scope, EmplKey, 2),
            get_param_list(Scope, Type, [
                            Section-2, pEmplKey-EmplKey,
                            pForAlimony-ForAlimony2 ]),
            % Коэффициент для Переходящего начисления
            catch( AlimonyCoef is ForAlimony1 / ForAlimony2, _, AlimonyCoef = 0),
            % начислено Алиментов по Предыдущему периоду
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-"ftAlimony" ]),
            findall( AlimonySum,
                     ( get_data(Scope, kb, usr_wg_TblCharge_Prev, SpecTblChargePrev),
                       AlimonySum is Credit - Debit
                     ),
            AlimonySumList),
            sum_list(AlimonySumList, AlimonyAmount),
            % Оплачено по Предыдущему периоду
            AlimonyAmountPaid is round(AlimonyAmount * AlimonyCoef) * 1.0,
            % сумма по Текущему периоду
            calc_amount(Scope, EmplKey, 3),
            % добавить временные данные
            new_param_list(Scope, Type, AmountPaidPairs),
            forall( get_data(Scope, kb, usr_wg_TblCharge_Prev, SpecTblChargePrev),
                    ( AlimonySum is Credit - Debit,
                      AlimonySumPaid is round(AlimonySum * AlimonyCoef) * 1.0,
                      % добавить временные данные
                      new_param_list(Scope, Type, SumPaidPairs)
                    )
                  ),
            !.
        %
        calc_amount(Scope, EmplKey, Shape) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcAmount,
            % собрать начисления по Группе начислений
            fee_group_charges(Scope, EmplKey, Charges, Shape),
            % Общая сумма
            charges_sum(Charges, AmountAll),
            % Исключаемые начисления
            charges_excl(Scope, EmplKey, Charges, ChargesExcl),
            % Исключаемая сумма
            charges_sum(ChargesExcl, [debit(1), credit(0)], AmountExcl),
            % Подоходный налог (ПН)
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-IncomeTaxFeeType, fAlias-"ftIncomeTax" ]),
            charges_sum(Charges, [debit(0), credit(1)], [IncomeTaxFeeType], IncomeTax),
            % собрать виды начислений, облагаемые ПН
            findall( TaxableFeeType,
                     get_data(Scope, kb, usr_wg_FeeType_Taxable, [
                                 fEmplKey-EmplKey, fFeeTypeKey-TaxableFeeType ]),
            TaxableFeeTypeList),
            % Облагаемая ПН сумма
            charges_sum(Charges, [debit(1), credit(0)], TaxableFeeTypeList, AmountTaxable),
            % Коеффициент ПН
            ( AmountTaxable =:= 0, IncomeTaxCoef = 0
            ; IncomeTaxCoef is IncomeTax / AmountTaxable
            ),
            % Облагаемая ПН Исключаемая сумма
            charges_sum(ChargesExcl, [debit(1), credit(0)], TaxableFeeTypeList, AmountTaxableExcl),
            % Исключаемый ПН
            IncomeTaxExcl is AmountTaxableExcl * IncomeTaxCoef,
            % Расчетная сумма = Общая сумма - Исключаемая сумма - Исключаемый ПН
            ForAlimony0 is AmountAll - AmountExcl - IncomeTaxExcl,
            to_currency(ForAlimony0, ForAlimony, 0),
            % спецификация временных данных
            AmountPairs = [
                        Section-Shape, pEmplKey-EmplKey, pForAlimony-ForAlimony,
                        pAmountAll-AmountAll, pAmountExcl-AmountExcl, pIncomeTaxExcl-IncomeTaxExcl,
                        pAmountTaxableExcl-AmountTaxableExcl, pIncomeTaxCoef-IncomeTaxCoef,
                        pIncomeTax-IncomeTax, pAmountTaxable-AmountTaxable ],
            % добавить временные данные
            new_param_list(Scope, Type, AmountPairs),
            !.
        
        % расчет формулы
        calc_formula(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcFormula,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fFormula-Formula,
                        fChildCount-_, fLivingWagePerc-_ ],
            % спецификации временных данных
            FormulaPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-_,
                        pAlimonySum-_,  pByBudget-_,
                        pFormula-Formula, pForAlimony-_, pBV-_,
                        pResult-_, pEval-_, pTCoef-_,
                        pChildCount-_, pLivingWagePerc-_,
                        pBudgetConst-_, pBudgetPart-_ ],
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % получить сумму по формуле
                      calc_formula(Scope, EmplKey, SpecAlimony, FormulaPairs),
                      % добавить временные данные
                      new_param_list(Scope, Type, FormulaPairs)
                    )
                  ),
            !.
        
        % расчет формулы по спецификациям
        calc_formula(Scope, EmplKey, SpecAlimony, FormulaPairs) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcFormula,
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateCalcTo-DateCalcTo ]),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fFormula-Formula,
                        fChildCount-ChildCount0, fLivingWagePerc-LivingWagePerc0 ],
            % сопоставить с данными по умолчанию
            LivingWagePerc1 is LivingWagePerc0 / 100,
            fit_data(Scope,
                        [pChildCount-ChildCount0, pLivingWagePerc-LivingWagePerc1],
                        [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc]),
            % спецификация временных данных
            FormulaPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-AlimonySum,
                        pAlimonySum-AlimonySum, pByBudget-ByBudget,
                        pFormula-Formula, pForAlimony-ForAlimony, pBV-BV,
                        pResult-Result, pEval-Eval, pTCoef-TCoef,
                        pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc,
                        pBudgetConst-BudgetConst, pBudgetPart-BudgetPart ],
            % сумма БВ
            get_data(Scope, kb, usr_wg_Variables, [fAlias-"vBV", fName-Var_BV]),
            get_min_wage(Scope, DateCalcTo, BV),
            replace_all(Formula, Var_BV, BV, Formula1),
            % сумма Для алиментов
            get_data(Scope, kb, usr_wg_Variables, [fAlias-"vForAlimony", fName-Var_ForAlimony]),
            get_param_list(Scope, Type, [
                            pCalcAmount-3, pEmplKey-EmplKey, pForAlimony-ForAlimony ]),
            replace_all(Formula1, Var_ForAlimony, ForAlimony, Formula2),
            % Результат
            replace_all(Formula2, ",", ".", Formula3),
            ( catch( term_to_atom(Expr, Formula3), _, fail ),
              catch( Eval is round(Expr) * 1.0, _, fail), FormulaError = 0
            ; Eval = 0.0, FormulaError = 1
            ),
            get_param_list(Scope, Type, [
                            pCalcTab-2, pAlimonyKey-AlimonyKey, pTCoef-TCoef ]),
            Result is round(Eval * TCoef) * 1.0,
            % Часть БПМ
            ( ChildCount > 0 ->
              get_budget(Scope, DateCalcTo, BudgetConst),
              BudgetPart is round(BudgetConst * LivingWagePerc) * 1.0
            ; BudgetPart = 0.0
            ),
            % Оплачено по Предыдущему периоду
            once( ( get_param_list(Scope, Type, [
                                    pCalcAmount-5, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                                    pAlimonySumPaid-AlimonySumPaid ])
                  ; AlimonySumPaid = 0.0
                  )
                ),
            % сумма Удержания c Контролем от БПМ
            ( FormulaError = 0, Result + AlimonySumPaid < BudgetPart ->
              AlimonySum0 is BudgetPart - AlimonySumPaid,
              ByBudget = 1
            ; AlimonySum0 = Result,
              ByBudget = 0
            ),
            get_round_data(Scope, EmplKey, "ftAlimony", RoundType, RoundValue),
            round_sum(AlimonySum0, AlimonySum, RoundType, RoundValue),
            !.
        
        % расчет расходов по переводу
        calc_transf(Scope, EmplKey, Stage) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCalcTransf,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fEmplKey-EmplKey, fDocKey-AlimonyKey,
                        fTransferTypeKey-TransferTypeKey0, fRecipient-Recipient0 ],
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyCharge-AlimonyCharge ],
            % спецификация параметров списания долгов алиментов
            DropDebtParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCharge-DropDebtCharge ],
            % спецификация временных данных
            TransfPairs = [
                        Section-Stage, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey1,
                        pTransfCharge-TransfCharge, pTransfByGroup-TransfByGroup,
                        pTransferTypeKey-TransferTypeKey, pRecipient-Recipient,
                        pForTransfAmount-ForTransfAmount, pTransfPercent-TransfPercent ],
            % спецификации данных для расходов по переводу
            AlimonyData = [
                        AlimonyKey, TransferTypeKey0, Recipient0, AlimonyCharge ],
            DropDebtData = [
                        AlimonyKey, TransferTypeKey0, Recipient0, DropDebtCharge ],
            AggrTransfData = [
                        AlimonyKey1, TransfByGroup, TransferTypeKey, Recipient,
                        ForTransfAmount, TransfPercent, TransfCharge ],
            % собрать данные для расходов по переводу
            findall( AlimonyData,
                     ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                       TransferTypeKey0 > 0,
                       get_param_list(Scope, Type, AlimonyParams)
                     ),
            AlimonyDataList ),
            findall( DropDebtData,
                     ( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                       TransferTypeKey0 > 0,
                       get_param_list(Scope, Type, DropDebtParams)
                     ),
            DropDebtDataList ),
            append(AlimonyDataList, DropDebtDataList, TransfDataList),
            % агрегировать суммы расходов по переводам
            aggr_fransf(Scope, EmplKey, TransfDataList, AggrTransfDataList),
            % удалить временные данные по переводам
            forall( get_param_list(Scope, Type, [Section-_, pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % для всех расходов по переводам
            forall( ( member(AggrTransfData, AggrTransfDataList),
                      TransfCharge > 0
                    ),
                    % добавить временные данные
                    new_param_list(Scope, Type, TransfPairs)
                  ),
            !.
        
        % агрегировать суммы расходов по переводам
        aggr_fransf(_, _, [], []) :-
            !.
        aggr_fransf(Scope, EmplKey, [TransfData|TransfDataList], [TransfAggrData|TransfAggrDataList]) :-
            aggr_fransf(Scope, EmplKey, TransfData, [TransfData|TransfDataList], TransfDataList1, TransfAggrData),
            !,
            aggr_fransf(Scope, EmplKey, TransfDataList1, TransfAggrDataList).
        %
        aggr_fransf(Scope, EmplKey, TransfData, TransfDataList, TransfDataList1, TransfAggrData) :-
            % спецификации данных для расходов по переводу
            TransfData = [AlimonyKey, TransferTypeKey, Recipient, _],
            TransfAggrData = [
                        AlimonyKey, TransfByGroup, TransferTypeKey, Recipient,
                        ForTransfAmount, TransfPercent, TransfCharge ],
            % собрать суммы по Группе [Документ, Вид перевода, Получатель]
            findall( AlimonyCharge,
                     member([AlimonyKey, TransferTypeKey, Recipient, AlimonyCharge],
                             TransfDataList),
            AlimonyChargeList),
            % Итог по группе
            sum_list(AlimonyChargeList, ForTransfAmount),
            % Признак группы
            ( length(AlimonyChargeList, 1),
              TransfByGroup = 0
            ;
              TransfByGroup = 1
            ),
            % Процент для расхода на перевод
            get_transf_percent(Scope, EmplKey, TransferTypeKey, ForTransfAmount, TransfPercent),
            % Сумма расхода по переводу
            TransfCharge0 is ForTransfAmount * TransfPercent / 100,
            get_round_data(Scope, EmplKey, "ftTransferDed", RoundType, RoundValue),
            round_sum(TransfCharge0, TransfCharge, RoundType, RoundValue),
            % если есть Группа
            ( TransfByGroup = 1,
              % исключить Группу из списка данных
              findall( [AlimonyKey1, TransferTypeKey1, Recipient1, AlimonySum1],
                       ( member([AlimonyKey1, TransferTypeKey1, Recipient1, AlimonySum1], TransfDataList),
                         \+ [TransferTypeKey, Recipient] = [TransferTypeKey1, Recipient1]
                       ),
              TransfDataList1)
            ; % иначе исключить Текущие данные
              selectchk(TransfData, TransfDataList, TransfDataList1)
            ),
            !.
        
        % контроль остатка
        check_rest(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCheckRest,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификация алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey, fRestPercent-RestPercent0 ],
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonySum-AlimonySum ],
            % спецификация параметров контроля
            CheckParams = [
                        pCalcAmount-3, pEmplKey-EmplKey,
                        pAmountAll-AmountAll ],
            % спецификация временных данных
            CheckPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyAmount-AlimonyAmount, pCheckAmount-CheckAmount,
                        pAmountAll-AmountAll, pRestPercent-RestPercent, pRestAmount-RestAmount
                         ],
            AlimonyPairs = [
                        Section-2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCoef-AlimonyCoef,
                        pAlimonySum-AlimonySum, pAlimonyAmount-AlimonyAmount ],
            % Итог по алиментам
            findall( AlimonySum,
                     get_param_list(Scope, Type, AlimonyParams),
            AlimonySumList),
            sum_list(AlimonySumList, AlimonyAmount),
            % Процент остатка
            findall( RestPercent0,
                     get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
            RestPercentList),
            min_list(RestPercentList, RestPercent0),
            RestPercent1 is RestPercent0 / 100,
            fit_data(Scope, [pRestPercent-RestPercent1], [pRestPercent-RestPercent]),
            % сумма Контроля
            get_param_list(Scope, Type, CheckParams),
            RestAmount is round(AmountAll * RestPercent) * 1.0,
            CheckAmount is round(AmountAll - RestAmount) * 1.0,
            % добавить временные данные
            new_param_list(Scope, Type, CheckPairs),
            % для всех алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( get_param_list(Scope, Type, AlimonyParams),
                      % вычислить коеффициент от Итога
                      catch( AlimonyCoef is AlimonySum / AlimonyAmount, _, AlimonyCoef = 1),
                      % добавить временные данные
                      new_param_list(Scope, Type, AlimonyPairs)
                    )
                  ),
            % Дельта для расчета при нехватке средств
            get_param(Scope, fit, pCalcDelta-CalcDelta), CalcDelta > 0,
            % контроль остатка по сумме Контроля
            check_rest(Scope, EmplKey, CheckAmount, 0, CalcDelta, 0),
            !.
        check_rest(_, _) :-
            !.
        % контроль остатка по сумме Контроля
        check_rest(Scope, EmplKey, CheckAmount, CalcDelta0, CalcDelta, CalcSwitch) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pCheckRest,
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyCharge-AlimonyCharge ],
            % спецификация параметров переводов
            TransfParams = [
                        pCalcTransf-_, pEmplKey-EmplKey, pTransfCharge-TransfCharge ],
            % спецификация временных данных
            CheckPairs = [
                        Section-3, pEmplKey-EmplKey,
                        pBalance-Balance, pChargeAmount-ChargeAmount,
                        pAlimonyChargeAmount-AlimonyChargeAmount, pTransfAmount-TransfAmount,
                        pReserveAmount-ReserveAmount, pCheckAmount-CheckAmount,
                        pCalcDelta-CalcDelta, pChargeStep-ChargeStep ],
            % сумма к Удержанию
            findall( AlimonyCharge,
                     get_param_list(Scope, Type, AlimonyParams),
            AlimonyChargeList),
            sum_list(AlimonyChargeList, AlimonyChargeAmount),
            findall( TransfCharge,
                     get_param_list(Scope, Type, TransfParams),
            TransfChargeList),
            sum_list(TransfChargeList, TransfAmount),
            ChargeAmount is AlimonyChargeAmount + TransfAmount,
            % сумма Контроля не меньше суммы к Удержанию
            \+ CheckAmount < ChargeAmount,
            % сумма Баланса
            Balance is round(CheckAmount - ChargeAmount) * 1.0,
            % сумма Резерва
            ReserveAmount is CheckAmount - CalcDelta0 * CalcSwitch,
            % количество Итераций
            ChargeStep is CalcDelta0 / CalcDelta,
            % добавить временные данные
            new_param_list(Scope, Type, CheckPairs),
            !.
        check_rest(Scope, EmplKey, CheckAmount, CalcDelta0, CalcDelta, CalcSwitch) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            % увеличить Дельту
            CalcDelta1 is CalcDelta0 + CalcDelta * CalcSwitch,
            % сумма Резерва
            ReserveAmount0 is CheckAmount - CalcDelta1,
            ( ReserveAmount0 > 0, ReserveAmount = ReserveAmount0
            ; ReserveAmount = 0
            ),
            % распределить суммы по Коэффициентам от суммы Резерва
            charge_by_coef(Scope, EmplKey, ReserveAmount),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 2),
            !,
            check_rest(Scope, EmplKey, CheckAmount, CalcDelta1, CalcDelta, 1).
        
        % распределить суммы по Коэффициентам от суммы Резерва
        charge_by_coef(Scope, EmplKey, ReserveAmount) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp,
            % спецификации параметров алиментов
            AlimonyParams1 = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-_ ],
            AlimonyParams2 = [
                        pCheckRest-2, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCoef-AlimonyCoef ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimony", RoundType, RoundValue),
            % для всех Алиментов
            forall( get_param_list(Scope, Type, AlimonyParams1, Pairs),
                    ( % вычислить Пропорцию
                      get_param_list(Scope, Type, AlimonyParams2),
                      AlimonyCharge0 is ReserveAmount * AlimonyCoef,
                      round_sum(AlimonyCharge0, AlimonyCharge, RoundType, RoundValue),
                      % заменить сумму Удержания
                      replace_list(Pairs,
                                      [pAlimonyCharge-_],
                                      [pAlimonyCharge-AlimonyCharge],
                                          Pairs1),
                      dispose_param_list(Scope, Type, Pairs),
                      new_param_list(Scope, Type, Pairs1)
                    )
                  ),
            !.
        
        % начисление долгов
        add_debt(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pAddDebt,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % спецификации параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum,
                        pChildCount-ChildCount ],
            % спецификация временных данных
            DebtPairs = [
                        Section-1, pEmplKey-EmplKey, pAlimonyKey-AlimonyKey,
                        pAlimonyDebt-AlimonyDebt,
                        pAlimonyCharge-AlimonyCharge, pAlimonySum-AlimonySum ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % для всех Алиментов с заполненным Количеством детей
            forall( ( get_param_list(Scope, Type, AlimonyParams), ChildCount > 0 ),
                    ( % рассчитать сумму Долга по алиментам
                      AlimonyDebt0 is AlimonySum - AlimonyCharge,
                              % при наличии Долга по алиментам
                      once( ( round_sum(AlimonyDebt0, AlimonyDebt, RoundType, RoundValue),
                              AlimonyDebt > 0,
                              % добавить временные данные
                              new_param_list(Scope, Type, DebtPairs)
                            ; % иначе продолжить
                              true
                            )
                          )
                     )
                  ),
            !.
        
        % списание долгов
        drop_debt(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % нет новых долгов
            \+ get_param_list(Scope, Type, [pAddDebt-1, pEmplKey-EmplKey]),
            % последний прием на работу
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_last_hire(Scope, PK, DateIn),
            % есть данные по долгам
            once( ( get_data(Scope, kb, usr_wg_AlimonyDebt, [
                                fEmplKey-EmplKey, fDateBegin-DebtDate ]),
                    DebtDate @>= DateIn
                  )
                ),
            % спецификация параметров Контроля
            CheckParams = [
                        pCheckRest-3, pEmplKey-EmplKey, pBalance-Balance ],
            % Контроль Баланса
            get_param_list(Scope, Type, CheckParams),
            Balance > 0,
            % Подготовка данных по Cписанию долгов
            drop_debt_prep_data(Scope, EmplKey, DateIn, Balance),
            % Списание долгов
            drop_debt_charge(Scope, EmplKey),
            % Контроль остатка после Списания долгов
            drop_debt_check_rest(Scope, EmplKey),
            !.
        drop_debt(Scope, _) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            !.
        
        % Подготовка данных по Cписанию долгов
        drop_debt_prep_data(Scope, EmplKey, DateIn, Balance) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            CutRoundType = 3,
            % спецификация Алиментов
            SpecAlimony = [
                        fDocKey-AlimonyKey, fEmplKey-EmplKey,
                        fPercent-Percent ],
            % спецификация Долгов по алиментам
            SpecAlimonyDebt = [
                        fDocKey-AlimonyDebtKey, fEmplKey-EmplKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-DateBegin,
                        fAlimonyKey-AlimonyKey, fDebtSum-DebtSum ],
            % спецификация Списания долгов по алиментам
            SpecAlimonyPaid = [
                        fDocKey-AlimonyDebtKey, fEmplKey-EmplKey,
                        fDebit-Debit, fCredit-Credit ],
            % спецификации временных данных
            RestDebtPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pRestSum-RestSum, pDebtSum-DebtSum, pPaidSum-PaidSum,
                        pYM-Y-M, pDateBegin-DateBegin ],
            DropDebtPairs = [
                        Section-2, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtAmount-DropDebtAmount,
                        pRestDebtAmount-RestDebtAmount, pEvalDebtAmount-EvalDebtAmount,
                        pForAlimony-ForAlimony, pDebtPercent-DebtPercent ],
            TotalDebtPairs = [
                        Section-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance,
                        pDropDebtTotal-DropDebtTotal, pRestDebtTotal-RestDebtTotal,
                        pCalcDelta-CalcDelta, pChargeStep-0 ],
            CoefDebtPairs = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCoef-DropDebtCoef ],
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % сумма Баланса для Cписания долгов по алиментам
            round_sum(Balance, DropDeptBalance, CutRoundType, RoundValue),
            DropDeptBalance > 0,
            % для всех Долгов по алиментам
            forall( ( get_data(Scope, kb, usr_wg_AlimonyDebt, SpecAlimonyDebt),
                      DateBegin @>= DateIn
                    ),
                    ( % суммировать Cписание долгов
                      findall( PaidSum0,
                               ( get_data(Scope, kb, usr_wg_TblCharge_AlimonyDebt, SpecAlimonyPaid),
                                 PaidSum0 is Credit - Debit
                               ),
                      PaidSumList ),
                      sum_list(PaidSumList, PaidSum),
                      % вычислить Остаток
                      RestSum0 is DebtSum - PaidSum,
                      round_sum(RestSum0, RestSum, CutRoundType, RoundValue),
                      % добавить временные данные
                      once( ( RestSum > 0,
                              new_param_list(Scope, Type, RestDebtPairs)
                            ; true
                            )
                          )
                    )
                  ),
            % Общая сумма Остатков по долгам
            findall( RestSum,
                     get_param_list(Scope, Type, RestDebtPairs),
            RestSumList ),
            sum_list(RestSumList, RestDebtTotal),
            RestDebtTotal > 0,
            % для всех Алиментов
            forall( get_data(Scope, kb, usr_wg_Alimony, SpecAlimony),
                    ( % суммировать Остатки по долгам
                      findall( RestSum,
                               get_param_list(Scope, Type, RestDebtPairs),
                      RestDebtList ),
                      sum_list(RestDebtList, RestDebtAmount),
                      % сумма Для алиментов
                      get_param_list(Scope, Type, [
                            pCalcAmount-3, pEmplKey-EmplKey, pForAlimony-ForAlimony ]),
                      % Процент Списания долга
                      Percent1 is Percent / 100,
                      fit_data(Scope, [pPercent-Percent1], [pPercent-DebtPercent]),
                      % расчет Списания долга
                      EvalDebtAmount0 is ForAlimony * DebtPercent,
                      round_sum(EvalDebtAmount0, EvalDebtAmount, RoundType, RoundValue),
                      % сумма Списания долга
                      ( EvalDebtAmount < RestDebtAmount ->
                        DropDebtAmount = EvalDebtAmount
                      ; DropDebtAmount = RestDebtAmount
                      ),
                      % добавить временные данные
                      once( ( DropDebtAmount > 0,
                              new_param_list(Scope, Type, DropDebtPairs)
                            ; true
                            )
                          )
                    )
                  ),
            % Общая сумма Списания долга
            findall( DropDebtAmount,
                     get_param_list(Scope, Type, DropDebtPairs),
            DropDebtAmountList ),
            sum_list(DropDebtAmountList, DropDebtTotal),
            DropDebtTotal > 0,
            % Дельта для расчета при нехватке средств
            get_param(Scope, fit, pCalcDelta-CalcDelta),
            % добавить временные данные
            new_param_list(Scope, Type, TotalDebtPairs),
            % для всех Списаний долгов по Алиментам
            forall( get_param_list(Scope, Type, DropDebtPairs),
                    ( % рассчитать Пропорцию
                      DropDebtCoef is DropDebtAmount / DropDebtTotal,
                      % добавить временные данные
                      new_param_list(Scope, Type, CoefDebtPairs)
                    )
                  ),
            !.
        
        % Списание долгов
        drop_debt_charge(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            % Итоги для Списания долгов
            TotalDebtParams = [
                        Section-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance, pDropDebtTotal-DropDebtTotal ],
            get_param_list(Scope, Type, TotalDebtParams),
            ( DropDeptBalance < DropDebtTotal,
              ByDropDebtCoef = 1
            ; ByDropDebtCoef = 0
            ),
            % Списание долгов по Балансу
            drop_debt_charge(Scope, EmplKey, DropDeptBalance, ByDropDebtCoef),
            !.
        % Списание долгов по Балансу
        drop_debt_charge(Scope, EmplKey, DropDeptBalance, ByDropDebtCoef) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, Section = pDropDebt,
            % спецификации параметров Долгов по алиментам
            RestDebtParams = [
                        Section-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pRestSum-RestSum, pDateBegin-DateBegin ],
            DropDebtParams = [
                        Section-2, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtAmount-DropDebtAmount ],
            CoefDebtParams = [
                        Section-4, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pDropDebtCoef-DropDebtCoef ],
            % спецификация временных данных по Списанию долгов
            DropDebtChargePairs = [
                        Section-5, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebtKey-AlimonyDebtKey,
                        pDropDebtCharge-_, pByDropDebtCoef-ByDropDebtCoef ],
            % удалить временные данные по Списанию долгов
            forall( get_param_list(Scope, Type, [Section-5, pEmplKey-EmplKey], Pairs),
                    dispose_param_list(Scope, Type, Pairs) ),
            % параметры Округления
            get_round_data(Scope, EmplKey, "ftAlimonyDebt", RoundType, RoundValue),
            % для всех Долгов по алиментам
            forall( get_param_list(Scope, Type, DropDebtParams),
                    ( % собрать Остатки долгов
                      findall( DateBegin-AlimonyDebtKey-RestSum,
                               get_param_list(Scope, Type, RestDebtParams),
                      RestDebtDataList0 ),
                      % в порядке их образования
                      msort(RestDebtDataList0, RestDebtDataList),
                      % определить Баланс для Списания долгов
                      ( ByDropDebtCoef = 0 ->
                        DropDeptBalance1 is DropDeptBalance
                      ; get_param_list(Scope, Type, CoefDebtParams),
                        DropDeptBalance1 is DropDeptBalance * DropDebtCoef
                      ),
                      round_sum(DropDeptBalance1, DropDeptBalance2, RoundType, RoundValue),
                      % списать Остатки долгов
                      drop_debt_charge(Scope, RestDebtDataList, DropDebtChargePairs, DropDebtAmount, DropDeptBalance2, RoundType, RoundValue)
                    )
                  ),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 3),
            !.
        
        % списать Остатки долгов
        drop_debt_charge(Scope, RestDebtDataList, _, DropDebtAmount, DropDeptBalance, _, _) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            ( RestDebtDataList = [] ; DropDebtAmount =< 0 ; DropDeptBalance =< 0 ),
            !.
        drop_debt_charge(Scope, [_-AlimonyDebtKey-RestSum|RestDebtDataList], DropDebtChargePairs, DropDebtAmount, DropDeptBalance, RoundType, RoundValue) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp,
            % определить сумму Списания
            ( RestSum < DropDebtAmount  ->
              DropDebtCharge0 is RestSum
            ; DropDebtCharge0 is DropDebtAmount
            ),
            ( DropDebtCharge0 < DropDeptBalance  ->
              DropDebtCharge1 is DropDebtCharge0
            ; DropDebtCharge1 is DropDeptBalance
            ),
            round_sum(DropDebtCharge1, DropDebtCharge, RoundType, RoundValue),
            member_list([pAlimonyDebtKey-AlimonyDebtKey, pDropDebtCharge-DropDebtCharge],
                            DropDebtChargePairs),
            % добавить временные данные
            new_param_list(Scope, Type, DropDebtChargePairs),
            % новая спецификация временных данных
            replace_list(DropDebtChargePairs,
                            [pAlimonyDebtKey-AlimonyDebtKey, pDropDebtCharge-DropDebtCharge],
                            [pAlimonyDebtKey-_, pDropDebtCharge-_],
                                DropDebtChargePairs1),
            % новый Баланс для Списания долгов
            DropDebtAmount1 is DropDebtAmount - DropDebtCharge,
            DropDeptBalance1 is DropDeptBalance - DropDebtCharge,
            !,
            drop_debt_charge(Scope, RestDebtDataList, DropDebtChargePairs1, DropDebtAmount1, DropDeptBalance1, RoundType, RoundValue).
        
        % Контроль остатка после Списания долгов
        drop_debt_check_rest(Scope, EmplKey) :-
            Type = temp, NextType = out,
            % спецификация параметров Контроля остатка
            CheckParams = [
                        pCheckRest-1, pEmplKey-EmplKey,
                        pCheckAmount-CheckAmount ],
            % спецификация параметров Общего итога
            TotalParams = [
                        pCalcTotal-1, pEmplKey-EmplKey,
                        pAllChargeTotal-AllChargeTotal ],
            % спецификация параметров Итога Списания долгов
            TotalDebtParams = [
                        pDropDebt-3, pEmplKey-EmplKey,
                        pDropDeptBalance-DropDeptBalance,
                        pCalcDelta-CalcDelta, pChargeStep-ChargeStep ],
            % сумма Контроля остатка
            get_param_list(Scope, Type, CheckParams),
            % сумма Итога
            calc_total(Scope, EmplKey),
            get_param_list(Scope, NextType, TotalParams),
            % Контроль остатка
            AllChargeTotal > CheckAmount,
            % уменьшение Баланса для Списания долгов
            get_param_list(Scope, Type, TotalDebtParams, TotalDebtPairs),
            DropDeptBalance1 is DropDeptBalance - CalcDelta,
            DropDeptBalance1 > 0,
            % Списание долгов по Балансу
            drop_debt_charge(Scope, EmplKey, DropDeptBalance1, 1),
            % изменение Итога Списания долгов
            ChargeStep1 is ChargeStep + 1,
            replace_list(TotalDebtPairs,
                            [pDropDeptBalance-DropDeptBalance],
                            [pDropDeptBalance-DropDeptBalance1],
                                TotalDebtPairs1),
            replace_list(TotalDebtPairs1,
                            [pChargeStep-ChargeStep],
                            [pChargeStep-ChargeStep1],
                                TotalDebtPairs2),
            dispose_param_list(Scope, Type, TotalDebtPairs),
            new_param_list(Scope, Type, TotalDebtPairs2),
            % пересчитать расходы по Переводу
            calc_transf(Scope, EmplKey, 3),
            !,
            drop_debt_check_rest(Scope, EmplKey).
        drop_debt_check_rest(_, _) :-
            !.
        
        % расчет итога
        calc_total(Scope, EmplKey) :-
            % - для алиментов
            Scope = wg_fee_alimony, Type = temp, NextType = out, Section = pCalcTotal,
            % записать отладочную информацию
            param_list_debug(Scope, NextType-Section),
            % спецификации параметров
            AlimonyChargeParams = [
                        pCheckRest-3, pEmplKey-EmplKey,
                        pAlimonyChargeAmount-AlimonyChargeAmount ],
            DropDebtChargeParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pDropDebtCharge-DropDebtCharge ],
            TransfChargeParams = [
                        pCalcTransf-_, pEmplKey-EmplKey,
                        pTransfCharge-TransfCharge ],
            % спецификация временных данных
            TotalPairs = [
                        Section-1, pEmplKey-EmplKey,
                        pAllChargeTotal-AllChargeTotal,
                        pAlimonyChargeTotal-AlimonyChargeAmount,
                        pDropDebtChargeTotal-DropDebtChargeTotal,
                        pTransfChargeTotal-TransfChargeTotal ],
            % Итог по Алиментам
            once( ( get_param_list(Scope, Type, AlimonyChargeParams)
                  ; AlimonyChargeAmount = 0
                  )
                ),
            % Итог по Списанию Долгов
            findall( DropDebtCharge,
                     get_param_list(Scope, Type, DropDebtChargeParams),
            DropDebtChargeList),
            sum_list(DropDebtChargeList, DropDebtChargeTotal),
            % Итог по Расходам на переводы
            findall( TransfCharge,
                     get_param_list(Scope, Type, TransfChargeParams),
            TransfChargeList),
            sum_list(TransfChargeList, TransfChargeTotal),
            % Общий итог
            AllChargeTotal is AlimonyChargeAmount + DropDebtChargeTotal + TransfChargeTotal,
            % удалить выходные данные по расчету
            forall( get_param(Scope, NextType, pEmplKey-EmplKey, Pairs),
                    dispose_param_list(Scope, NextType, Pairs) ),
            % добавить выходные данные
            new_param_list(Scope, NextType, TotalPairs),
            !.
        
        /* реализация - сервис */
        
        % взять параметры Округления
        get_round_data(Scope, _, Alias, RoundType, RoundValue) :-
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fAlias-Alias, fRoundByFeeType-1,
                        fRoundType-RoundType, fRoundValue-RoundValue ]),
            !.
        get_round_data(Scope, EmplKey, _, RoundType, RoundValue) :-
            get_param_list(Scope, in, [
                        pEmplKey-EmplKey,
                        pRoundType-RoundType, pRoundValue-RoundValue ]),
            !.
        
        % Процент для расхода на перевод
        get_transf_percent(Scope, EmplKey, TransferTypeKey, Sum, Percent) :-
            get_param_list(Scope, run, [pEmplKey-EmplKey, pDateCalcTo-DateCalcTo]),
            findall( TransferData,
                     get_transf_type(Scope, DateCalcTo, TransferTypeKey, TransferData),
            TransferDataList),
            msort(TransferDataList, TransferDataList1),
            last(TransferDataList1, _-TransferTypeKey1),
            get_transf_scale(Scope, TransferTypeKey1, Sum, Percent),
            !.
        get_transf_percent(_, _, _, _, 0.0) :-
            !.
        
        % Расценки на перевод
        get_transf_type(Scope, DateCalcTo, TransferTypeKey0, DateBegin-TransferTypeKey) :-
            get_data(Scope, kb, usr_wg_TransferType, [
                        fID-TransferTypeKey, fParent-TransferTypeKey0,
                        fDateBegin-DateBegin ]),
            \+ get_data(Scope, kb, usr_wg_TransferType, [
                            fParent-TransferTypeKey]),
            DateBegin @< DateCalcTo.
        get_transf_type(Scope, DateCalcTo, TransferTypeKey0, TransferData) :-
            get_data(Scope, kb, usr_wg_TransferType, [
                        fID-TransferTypeKey1, fParent-TransferTypeKey0 ]),
            get_transf_type(Scope, DateCalcTo, TransferTypeKey1, TransferData).
        
        % Шкала расценок
        get_transf_scale(Scope, TransferTypeKey, Sum, Percent) :-
            findall( StartSum-Percent0,
                     ( get_data(Scope, kb, usr_wg_TransferScale, [
                                 fTranferTypeKey-TransferTypeKey,
                                 fStartSum-StartSum, fPercent-Percent0 ]),
                       Sum >= StartSum ),
            ScaleDataList),
            msort(ScaleDataList, ScaleDataList1),
            last(ScaleDataList1, _-Percent),
            !.
        get_transf_scale(_, _, _, 0.0) :-
            !.
        
        % собрать начисления по Группе начислений
        fee_group_charges(Scope, EmplKey, Charges, Shape) :-
            % спецификация для начислений
            SpecTblCharge =  [
                fEmplKey-EmplKey,
                fCalYear-Y, fCalMonth-M, fDateBegin-DateBegin,
                fDebit-Debit, fCredit-Credit,
                fFeeTypeKey-FeeTypeKey ],
            % спецификация для группы начислений
            SpecFeeType =  [
                fEmplKey-EmplKey, fFeeTypeKey-FeeTypeKey ],
            % спецификация данных начисления
            ChargeData = [
                Y-M, DateBegin, Debit, Credit, FeeTypeKey ],
            % текущее Итоговое начисление
            get_param_list(Scope, run, [
                            pEmplKey-EmplKey, pDateBegin-DateBegin0 ]),
            atom_date(DateBegin0, date(Y0, M0, _)),
            % выбор набора данных по виду расчета
            memberchk(Shape-DatasetName, [
                            1-usr_wg_TblCharge_Prev,
                            2-usr_wg_TblCharge_Prev,
                            3-usr_wg_TblCharge ]),
            % взять данные
            findall( ChargeData,
                      % по начислениям
                    ( get_data(Scope, kb, DatasetName, SpecTblCharge),
                      % соответствующего типа
                      get_data(Scope, kb, usr_wg_FeeType, SpecFeeType),
                      % с фильтром для вида расчета
                      ( Shape = 1, Y-M = Y0-M0 ; \+ Shape = 1 ),
                      % и контролем суммы
                      ( \+ Debit =:= 0 ; \+ Credit =:= 0 )
                    ),
            % в список
            Charges ),
            !.
        
        % исключаемые начисления
        charges_excl(Scope, EmplKey, Charges, ChargesExcl) :-
            % спецификация данных начисления
            ChargeData = [
                _-_, DateBegin, _, _, FeeTypeKey ],
            % собрать исключаемые начисления
            findall( ChargeData,
                     ( member(ChargeData, Charges),
                       is_fee_type_excl(Scope, EmplKey, DateBegin, FeeTypeKey)
                     ),
            ChargesExcl ),
            !.
        
        % сумма начислений
        charges_sum(Charges, Amount) :-
            charges_sum(Charges, [], [], 0, Amount),
            !.
        %
        charges_sum(Charges, Options, Amount) :-
            charges_sum(Charges, Options, [], 0, Amount),
            !.
        %
        charges_sum(Charges, Options, ValidFeeTypes, Amount) :-
            charges_sum(Charges, Options, ValidFeeTypes, 0, Amount),
            !.
        %
        charges_sum([], _, _, Amount, Amount) :-
            !.
        charges_sum([Charge|Charges], Options, ValidFeeTypes, Amount0, Amount) :-
            charge_acc(Charge, Options, ValidFeeTypes, Amount0, Amount1),
            !,
            charges_sum(Charges, Options, ValidFeeTypes, Amount1, Amount).
        
        % накопление суммы начислений
        charge_acc(ChargeData, Options, ValidFeeTypes, Amount0, Amount1) :-
            % спецификация данных
            ChargeData = [
                _-_, _, Debit, Credit, FeeTypeKey ],
            % если тип начисления дейсвителен
            ( ValidFeeTypes = [] ; memberchk(FeeTypeKey, ValidFeeTypes) ),
            % установить опции
            ( memberchk(debit(InclDebit), Options) ; InclDebit = 1 ),
            ( memberchk(credit(InclCredit), Options) ; InclCredit = 1 ),
            % и произвести накопление
            Amount1 is Amount0 + Debit * InclDebit - Credit * InclCredit,
            !.
        charge_acc(_, _, _, Amount, Amount) :-
            !.
        
        % тип начисления исключается из расчета
        is_fee_type_excl(Scope, EmplKey, DateBegin, FeeTypeKey) :-
            % - для алиментов
            Scope = wg_fee_alimony,
            % если вид начисления "Компенсация отпуска"
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-Alias ]),
            memberchk(Alias, ["ftHolidayComp"]),
            % и сотрудник уволен в месяце текущей даты
            is_fired(Scope, EmplKey, DateBegin),
            !.
        
        % сотрудник уволен в месяце текущей даты
        is_fired(Scope, EmplKey, DateBegin) :-
            atom_date(DateBegin, date(Y, M, _)),
            get_data(Scope, kb, usr_wg_MovementLine, [
                        fEmplKey-EmplKey,
                        fMoveYear-Y, fMoveMonth-M,
                        fMovementType-3 ]),
            !.
        
        % сопоставить с данными по умолчанию
        fit_data(Scope, [Name-Value0], [Name-Value]) :-
            % - для алиментов (Процент остатка)
            Scope = wg_fee_alimony, Type = fit,
            Name = pRestPercent,
            get_param(Scope, Type, Name-Value1),
            ( Value0 < Value1, Value = Value1
            ; Value = Value0
            ),
            !.
        % сопоставить с данными по умолчанию
        fit_data(Scope, [Name-Value0], [Name-Value]) :-
            % - для алиментов ( Процент списания долга)
            Scope = wg_fee_alimony, Type = fit,
            Name = pPercent,
            ( Value0 > 0, Value = Value0
            ; get_param(Scope, Type, Name-Value)
            ),
            !.
        fit_data(Scope, Pairs0, Pairs) :-
            % - для алиментов (Процент от БПМ)
            Scope = wg_fee_alimony, Type = fit,
            Pairs0 = [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc0],
            Pairs = [pChildCount-ChildCount, pLivingWagePerc-LivingWagePerc],
            Pairs1 = [pChildQtyCmp-ChildQtyCmp, pLivingWagePerc-LivingWagePerc1],
            %
            get_param_list(Scope, Type, Pairs1),
            catch( atomic_concat(ChildCount, ChildQtyCmp, Atom), _, fail ),
            catch( term_to_atom(Term, Atom), _, fail),
            catch( Term, _, fail),
            %
            ( LivingWagePerc0 < LivingWagePerc1, LivingWagePerc = LivingWagePerc1
            ; LivingWagePerc = LivingWagePerc0
            ),
            !.
        fit_data(_, Pairs, Pairs) :-
            !.
        
        /* реализация - расширение для клиента */
        
        % загрузка входных данных по сотруднику
        fee_calc_in(Scope, EmplKey, DateBegin, TotalDocKey, FeeTypeKey, RoundType, RoundValue) :-
            Scope = wg_fee_alimony, Type = in, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            % записать входные параметры
            new_param_list(Scope, Type, [
                pEmplKey-EmplKey, pDateBegin-DateBegin,
                pTotalDocKey-TotalDocKey, pFeeTypeKey-FeeTypeKey,
                pRoundType-RoundType, pRoundValue-RoundValue
                ]),
            !.
        
        % подготовка данных выполнения
        fee_calc_prep(Scope) :-
            Scope = wg_fee_alimony, Type = in, TypeNextStep = run,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % для каждого сотрудника
            get_param_list(Scope, Type, [pEmplKey-_, pDateBegin-DateBegin], Pairs),
            % собрать входные данные
            findall( Pairs0,
                     ( member(Template, [pCommon-1, pAlimony-1]),
                       get_param_list(Scope, Type, [Template], Pairs0)
                     ),
            PairsList ),
            append(PairsList, PairsNextStep0),
            % сформировать данные выполнения
            date_add(DateBegin, -1, month, DateBegin0),
            atom_date(DateBegin0, date(Y0, M0, _)),
            atom_date(DatePrevCalcFrom, date(Y0, M0, 1)),
            atom_date(DateBegin, date(Y, M, _)),
            atom_date(DateCalcFrom, date(Y, M, 1)),
            date_add(DateBegin, 1, month, DateBegin1),
            atom_date(DateBegin1, date(Y1, M1, _)),
            atom_date(DateCalcTo, date(Y1, M1, 1)),
            % записать данные выполнения
            append([ Pairs,
                     [
                       pDatePrevCalcFrom-DatePrevCalcFrom, pDatePrevCalcTo-DateCalcFrom,
                       pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo
                     ],
                     PairsNextStep0
                   ],
                       PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            % найти альтернативу
            fail.
        fee_calc_prep(_) :-
            % больше альтернатив нет
            !.
        
        % выгрузка данных выполнения по сотруднику
        fee_calc_run(Scope, EmplKey) :-
            Scope = wg_fee_alimony, Type = run, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % взять данные выполнения
            get_param_list(Scope, Type, PK),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % формирование SQL-запросов по сотруднику
        fee_calc_sql(Scope, EmplKey, PredicateName, Arity, SQL) :-
            Scope = wg_fee_alimony, Type = run, TypeNextStep = query,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, kb, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, kb, Query, SQL0, Params),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-запросу
            PairsNextStep = [pEmplKey-EmplKey, pQuery-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % формирование SQL-команд по сотруднику
        fee_calc_cmd(Scope, EmplKey, PredicateName, Arity, SQL) :-
            Scope = wg_fee_alimony, Type = run, TypeNextStep = cmd,
            % записать отладочную информацию
            param_list_debug(Scope, Type-TypeNextStep),
            % взять данные выполнения для подстановки параметров
            get_param_list(Scope, Type, [pEmplKey-EmplKey], Pairs),
            % для каждой спецификации набора данных
            gd_pl_ds(Scope, cmd, PredicateName, Arity, _),
            Query = PredicateName/Arity,
            is_valid_sql(Query),
            % взять SQL-строку с параметрами
            get_sql(Scope, cmd, Query, SQL0, Params),
            % сопоставить параметры с данными выполнения
            member_list(Params, Pairs),
            % подготовить SQL-запрос
            prepare_sql(SQL0, Params, SQL),
            % записать данные по SQL-команде
            PairsNextStep = [pEmplKey-EmplKey, pCmd-Query, pSQL-SQL],
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            true.
        
        % выгрузка выходных данных по сотруднику
        fee_calc_out(Scope, EmplKey, Result) :-
            Scope = wg_fee_alimony, Type = out, Section = PK,
            % первичный ключ
            PK = [pEmplKey-EmplKey],
            % спецификация параметров выходных данных
            append([[pCalcTotal-1], PK, [pAllChargeTotal-Result]], OutPairs),
            % взять выходные данные
            get_param_list(Scope, Type, OutPairs),
            % записать отладочную информацию
            param_list_debug(Scope, Type-Section),
            true.
        
        % выгрузка выходных данных по начислениям по сотруднику
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeKey, DocKey, AccountKeyIndex) :-
            % - начисление алиментов
            Scope = wg_fee_alimony, Type = temp, AccountKeyIndex = 0,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-"ftAlimony" ]),
            % спецификация параметров алиментов
            AlimonyParams = [
                        pCalcFormula-1, pEmplKey-EmplKey,
                        pAlimonyCharge-ChargeSum, pAlimonyKey-DocKey ],
            % взять данные по алиментам
            get_param_list(Scope, Type, AlimonyParams),
            ChargeSum > 0,
            true.
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeKey, DocKey, AccountKeyIndex) :-
            % - списание долгов по алиментам
            Scope = wg_fee_alimony, Type = temp, AccountKeyIndex = 1,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-"ftAlimonyDebt" ]),
            % спецификация параметров списания долгов
            DebtParams = [
                        pDropDebt-5, pEmplKey-EmplKey,
                        pDropDebtCharge-ChargeSum, pAlimonyDebtKey-DocKey ],
            % взять данные по списанию долгов
            get_param_list(Scope, Type, DebtParams),
            ChargeSum > 0,
            true.
        fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeKey, DocKey, AccountKeyIndex) :-
            % - пересылка алиментов
            Scope = wg_fee_alimony, Type = temp, AccountKeyIndex = 2,
            get_data(Scope, kb, usr_wg_FeeType_Dict, [
                        fID-FeeTypeKey, fAlias-"ftTransferDed" ]),
            % спецификация параметров перевода
            TransfParams = [
                        pCalcTransf-_, pEmplKey-EmplKey,
                        pTransfCharge-ChargeSum, pAlimonyKey-DocKey ],
            % взять данные по переводу
            get_param_list(Scope, Type, TransfParams),
            ChargeSum > 0,
            true.
        
        % выгрузка выходных данных по долгам по сотруднику
        fee_calc_debt(Scope, EmplKey, AlimonyKey, DebtSum) :-
            % - долги по алиментам
            Scope = wg_fee_alimony, Type = temp,
            % спецификация параметров долга
            DebtParams = [
                        pAddDebt-1, pEmplKey-EmplKey,
                        pAlimonyKey-AlimonyKey, pAlimonyDebt-DebtSum ],
            % взять данные по списанию долгу
            get_param_list(Scope, Type, DebtParams),
            DebtSum > 0,
            true.
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-08-12T14:05:03+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "151042959_187967073 wg_data_mix"
          - 
            ADDFUNCTIONKEY: "195362817_166214404 twg_fee_sql"
          - 
            ADDFUNCTIONKEY: "195362816_166214404 twg_fee_in_params"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 195361376_166214404
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_FeeAlimonyCalc_pl"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        '#include wg_WageSettings
        '
        '#include pl_GetScriptIDByName
        
        Function wg_FeeAlimonyCalc_pl(ByRef wg_EmployeeCharge, ByVal TotalDocKey, ByVal AccountKeyArr)
        '
          Dim T, T1, T2
          '
          Dim Creator
          '
          Dim PL, Ret, Pred, Tv, PredFile, Append
          Dim ScriptName, Scope
          'fee_calc_in, fee_calc_prep
          Dim P_in, Tv_in, Q_in, P_prep, Tv_prep, Q_prep
          Dim EmplKey, DateBegin, RoundType, RoundValue
          'fee_calc_run
          Dim P_run, Tv_run, Q_run
          'fee_calc_sql, fee_calc_cmd
          Dim P_sql, Tv_sql, Q_sql, P_cmd, Tv_cmd, Q_cmd
          Dim PredicateName, Arity, SQL
          Dim SQLUpdate
          'fee_calc
          Dim P_main, Tv_main, Q_main
          'fee_calc_out, fee_calc_charge
          Dim P_out, Tv_out, Q_out, P_charge, Tv_charge, Q_charge
          Dim Result, ChargeSum, FeeTypeKey, DocKey, AccountKeyIndex
          'fee_calc_debt
          Dim P_debt, Tv_debt, Q_debt
          Dim AlimonyKey, DebtSum
          Dim gdcAlimonyDebt
        
          T1 = Timer
        
          Result = 0
          wg_FeeAlimonyCalc_pl = Result
            
          'init
          Set Creator = New TCreator
          Set PL = Creator.GetObject(nil, "TgsPLClient", "")
          Ret = PL.Initialise("")
          If Not Ret Then
            Exit Function
          End If
          'debug
          PL.Debug = False
          'load
          ScriptName = "twg_fee"
          Ret = PL.LoadScript(pl_GetScriptIDByName(ScriptName))
          If Not Ret Then
            Exit Function
          End If
          Scope = "wg_fee_alimony"
          'debug
          PL.Debug = True
        
          'params
          EmplKey = wg_EmployeeCharge.EmployeeKey
          DateBegin = wg_EmployeeCharge.BeginDate
          '
          RoundType = wg_WageSettings.Wage.RoundType
          RoundValue = wg_WageSettings.Wage.RoundValue
        
          'fee_calc_in(Scope, EmplKey, DateBegin, TotalDocKey, FeeTypeKey, RoundType, RoundValue)
          P_in = "fee_calc_in"
          Set Tv_in = Creator.GetObject(7, "TgsPLTermv", "")
          Set Q_in = Creator.GetObject(nil, "TgsPLQuery", "")
          '
          Tv_in.PutAtom 0, Scope
          Tv_in.PutInteger 1, EmplKey
          Tv_in.PutDate 2, DateBegin
          Tv_in.PutInteger 3, TotalDocKey
          Tv_in.PutInteger 4, FeeTypeKey
          Tv_in.PutInteger 5, RoundType
          Tv_in.PutFloat 6, RoundValue
          '
          Q_in.PredicateName = P_in
          Q_in.Termv = Tv_in
          '
          Q_in.OpenQuery
          If Q_in.EOF Then
            Exit Function
          End If
          Q_in.Close
        
          'fee_calc_prep(Scope)
          P_prep = "fee_calc_prep"
          Set Tv_prep = Creator.GetObject(1, "TgsPLTermv", "")
          Set Q_prep = Creator.GetObject(nil, "TgsPLQuery", "")
          '
          Tv_prep.PutAtom 0, Scope
          '
          Q_prep.PredicateName = P_prep
          Q_prep.Termv = Tv_prep
          '
          Q_prep.OpenQuery
          If Q_prep.EOF Then
            Exit Function
          End If
          Q_prep.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          'fee_calc_run(Scope, EmplKey)
          P_run = "fee_calc_run"
          Set Tv_run = Creator.GetObject(2, "TgsPLTermv", "")
          Set Q_run = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_run.PredicateName = P_run
          Q_run.Termv = Tv_run
          '
          Tv_run.PutAtom 0, Scope
          '
          Q_run.OpenQuery
          If Q_run.EOF Then
            Exit Function
          End If
        
          'fee_calc_sql(Scope, EmplKey, PredicateName, Arity, SQL)
          P_sql = "fee_calc_sql"
          Set Tv_sql = Creator.GetObject(5, "TgsPLTermv", "")
          Set Q_sql = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_sql.PredicateName = P_sql
          Q_sql.Termv = Tv_sql
          'fee_calc_cmd(Scope, EmplKey, PredicateName, Arity, SQL)
          P_cmd = "fee_calc_cmd"
          Set Tv_cmd = Creator.GetObject(5, "TgsPLTermv", "")
          Set Q_cmd = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_cmd.PredicateName = P_cmd
          Q_cmd.Termv = Tv_cmd
          '
          Set SQLUpdate = Creator.GetObject(nil, "TIBSQL", "")
          Set SQLUpdate.Transaction = wg_EmployeeCharge.Transaction
        
          Append = False
          '
          Do Until Q_run.EOF
            EmplKey = Tv_run.ReadInteger(1)
            '
            Tv_sql.Reset
            Tv_sql.PutAtom 0, Scope
            Tv_sql.PutInteger 1, EmplKey
            Q_sql.OpenQuery
            '
            Do Until Q_sql.EOF
              PredicateName = Tv_sql.ReadAtom(2)
              Arity = Tv_sql.ReadInteger(3)
              SQL = Tv_sql.ReadString(4)
              '
              Ret =  PL.MakePredicatesOfSQLSelect _
                        (SQL, _
                        wg_EmployeeCharge.Transaction, _
                        PredicateName, PredicateName, Append)
              '
              Q_sql.NextSolution
            Loop
            Q_sql.Close
            '
            Append = True
            '
            Tv_cmd.Reset
            Tv_cmd.PutAtom 0, Scope
            Tv_cmd.PutInteger 1, EmplKey
            Q_cmd.OpenQuery
            '
            Do Until Q_cmd.EOF
              PredicateName = Tv_cmd.ReadAtom(2)
              Arity = Tv_cmd.ReadInteger(3)
              SQL = Tv_cmd.ReadString(4)
              '
              SQLUpdate.SQL.Text = SQL
              SQLUpdate.ExecQuery
              SQLUpdate.Close
              '
              Q_cmd.NextSolution
            Loop
            Q_cmd.Close
            '
            Q_run.NextSolution
          Loop
          Q_run.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          'fee_calc(Scope)
          P_main = "fee_calc"
          Set Tv_main = Creator.GetObject(1, "TgsPLTermv", "")
          Set Q_main = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_main.PredicateName = P_main
          Q_main.Termv = Tv_main
          '
          Tv_main.PutAtom 0, Scope
          '
          Q_main.OpenQuery
          If Q_main.EOF Then
            Exit Function
          End If
          Q_main.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          'fee_calc_out(Scope, EmplKey, Result)
          P_out = "fee_calc_out"
          Set Tv_out = Creator.GetObject(3, "TgsPLTermv", "")
          Set Q_out = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_out.PredicateName = P_out
          Q_out.Termv = Tv_out
          '
          Tv_out.PutAtom 0, Scope
          '
          Q_out.OpenQuery
          If Q_out.EOF Then
            Exit Function
          End If
        
          'fee_calc_charge(Scope, EmplKey, ChargeSum, FeeTypeKey, DocKey, AccountKeyIndex)
          P_charge = "fee_calc_charge"
          Set Tv_charge = Creator.GetObject(6, "TgsPLTermv", "")
          Set Q_charge = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_charge.PredicateName = P_charge
          Q_charge.Termv = Tv_charge
        
          'fee_calc_debt(Scope, EmplKey, AlimonyKey, DebtSum)
          P_debt = "fee_calc_debt"
          Set Tv_debt = Creator.GetObject(4, "TgsPLTermv", "")
          Set Q_debt = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_debt.PredicateName = P_debt
          Q_debt.Termv = Tv_debt
          'Журнал долгов по алиментам
          Set gdcAlimonyDebt = Creator.GetObject(nil, "TgdcUserDocument", "")
          gdcAlimonyDebt.SubType = "147072391_453357870"
          gdcAlimonyDebt.Transaction = wg_EmployeeCharge.Transaction
          gdcAlimonyDebt.Open
            
          Do Until Q_out.EOF
            EmplKey = Tv_out.ReadInteger(1)
            Result = Tv_out.ReadFloat(2)
            '
            Tv_charge.Reset
            Tv_charge.PutAtom 0, Scope
            Tv_charge.PutInteger 1, EmplKey
            Q_charge.OpenQuery
            '
            Do Until Q_charge.EOF
              ChargeSum = Tv_charge.ReadFloat(2)
              FeeTypeKey = Tv_charge.ReadInteger(3)
              DocKey = Tv_charge.ReadInteger(4)
              AccountKeyIndex = Tv_charge.ReadInteger(5)
              '
              Call wg_EmployeeCharge.AddCharge(0, ChargeSum, Null, TotalDocKey, FeeTypeKey, _
                  DocKey, wg_EmployeeCharge.BeginDate, 0, 0)
              Call wg_EmployeeCharge.AddChargeRegNew(0, ChargeSum, TotalDocKey, FeeTypeKey, _
                  AccountKeyArr(AccountKeyIndex), wg_EmployeeCharge.BeginDate, DocKey)
              '
              Q_charge.NextSolution
            Loop
            Q_charge.Close
            '
            Tv_debt.Reset
            Tv_debt.PutAtom 0, Scope
            Tv_debt.PutInteger 1, EmplKey
            Q_debt.OpenQuery
            '
            Do Until Q_debt.EOF
              AlimonyKey = Tv_debt.ReadInteger(2)
              DebtSum = Tv_debt.ReadFloat(3)
              '
              gdcAlimonyDebt.Insert
              gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
              gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = AlimonyKey
              gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = DebtSum
              gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 0
              gdcAlimonyDebt.Post
              '
              Q_debt.NextSolution
            Loop
            Q_debt.Close
            '
            Q_out.NextSolution
          Loop
          Q_out.Close
        
          gdcAlimonyDebt.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            PredFile = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, PredFile
          End If
        
          wg_FeeAlimonyCalc_pl = Result
        
          T2 = Timer
          T = T2 - T1
        '
        End Function
        
      DISPLAYSCRIPT: | 
        WG_FEEALIMONYCALC_PL
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QRAAAAV0dfRU1QTE9ZRUVDSEFSR0URAAAAV0dfRU1QTE9ZRUVDSEFSR0UAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QLAAAAVE9UQUxET0NLRVkLAAAAVE9UQUxET0NLRVkA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QNAAAAQUNDT1VOVEtFWUFSUg0AAABBQ0NP
        VU5US0VZQVJSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RGTFBS
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-07-29T12:40:35+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147019760_119619099 wg_WageSettings"
          - 
            ADDFUNCTIONKEY: "151158419_5956463 pl_GetScriptIDByName"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 147656112_119619099
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "WAGE"
      LANGUAGE: "VBScript"
      NAME: "wg_FeeAlimonyCalc"
      COMMENT: ~
      SCRIPT: | 
        '#include wg_MonthHour
        '#include wg_GetAlimonySum
        '#include wg_CalcTransferSum
        '#include wg_RoundSum
        '#include wg_EmplMoveList
        '#include wg_TblCal
        '#include wg_WageSettings
        '#include wg_GetAccountKey
        '<pl>
        '#include wg_FeeAlimonyCalc_pl
        '</pl>
        function wg_FeeAlimonyCalc(ByRef wg_EmployeeCharge, ByVal TotalDocKey, ByVal FeeTypeKey, ByRef obj_FeeData)
        'Расчет алиментов, долга по алиментам и расходов на их пересылку
          wg_FeeAlimonyCalc = 0
        
          Dim wg_FeeType_TransferDed_ID, wg_FeeType_AlimonyDebt_ID
          Dim AccountKey, AccountKeyDebt, AccountKeyTransf
        
          wg_FeeType_TransferDed_ID = gdcBaseManager.GetIDByRUIDString(wg_FeeType_TransferDed_RUID)
          wg_FeeType_AlimonyDebt_ID = gdcBaseManager.GetIDByRUIDString(wg_FeeType_AlimonyDebt_RUID)
        
          AccountKey = wg_GetAccountKey(FeeTypeKey, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.EndDate)
          AccountKeyDebt = wg_GetAccountKey(wg_FeeType_AlimonyDebt_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.BeginDate)
          AccountKeyTransf = wg_GetAccountKey(wg_FeeType_TransferDed_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.BeginDate)
        
          '<pl>
          Dim AccountKeyArr
          '
          AccountKeyArr = Array(AccountKey, AccountKeyDebt, AccountKeyTransf)
        
          Dim frmAlimony, dlgAlimony, Prolog_Alimony
          '
          Set frmAlimony = _
            Application.FindComponent("gdc_frmUserComplexDocument147567052_119619099")
          Set dlgAlimony = _
            frmAlimony.FindComponent("gdc_dlgUserComplexDocument147567052_119619099")
          Set Prolog_Alimony = _
            dlgAlimony.FindComponent("usrg_Prolog_Alimony")
        
          If Assigned(Prolog_Alimony) Then
            If Prolog_Alimony.Checked = True Then
              'Расчет через Пролог-скрипт
              wg_FeeAlimonyCalc = _
                wg_FeeAlimonyCalc_pl(wg_EmployeeCharge, TotalDocKey, AccountKeyArr)
              Exit Function
            End If
          End If
          '</pl>
        
        'Удаление результатов прошлого расчета
          set Creator = New TCreator
          set SQLUpdate = Creator.GetObject(nil, "TIBSQL", "")
          set SQLUpdate.Transaction = wg_EmployeeCharge.Transaction
          'Удаление результатов прошлого расчета из журнала долга
          SQLUpdate.SQL.Text = "DELETE " & _
            "FROM usr$wg_alimonydebt aldebt " & _
            "WHERE " & _
            "    usr$totaldockey = :totaldockey " & _
            "  AND aldebt.usr$alimonykey IN " & _
            " (SELECT al.documentkey " & _
            "  FROM usr$wg_alimony al " & _
            "  WHERE al.usr$emplkey = :emplkey) "
        
          SQLUpdate.ParamByName("totaldockey").AsInteger = TotalDocKey
          SQLUpdate.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.EmployeeKey
          SQLUpdate.ExecQuery
          SQLUpdate.Close
          'Удаление результатов прошлого расчета из журнала погашенных месяцев
          SQLUpdate.SQL.Text = "DELETE " & _
            "FROM usr$wg_alimonypayedmonth " & _
            "WHERE " & _
            "  usr$totaldockey = :totaldockey " & _
            "  AND usr$alimonydebtkey IN ( " & _
            "    SELECT aldebt.documentkey " & _
            "    FROM usr$wg_alimonydebt aldebt " & _
            "      JOIN usr$wg_alimony al ON aldebt.usr$alimonykey = al.documentkey AND al.usr$emplkey = :emplkey) "
        
          SQLUpdate.ParamByName("totaldockey").AsInteger = TotalDocKey
          SQLUpdate.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.EmployeeKey
          SQLUpdate.ExecQuery
          SQLUpdate.Close
        
          set MoveCard = wg_EmplMoveList.MoveCardList(wg_EmployeeCharge.EmployeeKey, null)._
            MoveCardByDate(wg_EmployeeCharge.EndDate)
          if Assigned(MoveCard) then
        
            'Журнал долгов по алиментам
            Set gdcAlimonyDebt = Creator.GetObject(nil, "TgdcUserDocument", "")
            gdcAlimonyDebt.SubType = "147072391_453357870"
            gdcAlimonyDebt.Transaction = wg_EmployeeCharge.Transaction
            gdcAlimonyDebt.Open
        
            'Определим кол-во отработанных часов (для определения текущего долга по алиментам в месяцах)
            if wg_WageSettings.Wage.Alimonymonthdebt then
        '      set Tbl = wg_TblCal.EmplTblCal(wg_EmployeeCharge.Employeekey, MoveCard.FirstMoveKey)
        '      AddDebtMontFlg = (Tbl.WorkDuration = 0)
              AddDebtMontFlg = False
            else
              AddDebtMontFlg = False
            end if
        
            'Класс для работы с алиментами
            set wg_Alimony = New Twg_Alimony
        
            wg_EmployeeCharge.FirstMoveKey = MoveCard.FirstMoveKey
            'Класс для расчета формул
            set wg_FoCal = New Twg_FoCal
            set wg_FoCal.ReadTransaction = wg_EmployeeCharge.ReadTransaction
            wg_FoCal.EmplKey   = wg_EmployeeCharge.Employeekey
            wg_FoCal.DateBegin = wg_EmployeeCharge.BeginDate
            wg_FoCal.DateEnd   = wg_EmployeeCharge.EndDate
            'Запрос для добавления погашенных месяцев в отдельный журнал
            SQLUpdate.SQL.Text = " INSERT INTO usr$wg_alimonypayedmonth " & _
              " (usr$totaldockey, usr$alimonydebtkey, usr$payedmonth) " & _
              " VALUES (:totaldockey, :alimonydebtkey, :payedmonth) "
        
            set IBSQL = Creator.GetObject(nil, "TIBSQL", "")
            IBSQL.Transaction = wg_EmployeeCharge.ReadTransaction
            'Выбираем документы о назначении алиментов
            IBSQL.SQL.Text = " SELECT calc.* " & _
              " FROM usr$wg_alimony calc " & _
              " LEFT JOIN GD_DOCUMENT d ON calc.DOCUMENTKEY = d.ID " & _
              " WHERE d.COMPANYKEY = <COMPANYKEY/> AND " & _
              "   calc.usr$emplkey = :emplkey AND " & _
              "   calc.usr$datebegin <= :dateend AND " & _
              "   (calc.usr$dateend >= :datebegin or calc.usr$dateend is NULL) " & _
              "   AND d.documenttypekey = :doctype " & _
              " ORDER BY calc.usr$datebegin "
            IBSQL.ParamByName("DateBegin").AsDateTime = wg_EmployeeCharge.BeginDate
            IBSQL.ParamByName("DateEnd").AsDateTime =  wg_EmployeeCharge.EndDate
            IBSQL.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.Employeekey
            IBSQL.ParamByName("doctype").AsInteger = gdcBaseManager.GetIdByRuidString("147067079_453357870")
            IBSQL.ExecQuery
        
            'Оставшееся деньги
            RestSum = wg_EmployeeCharge.Debit - wg_EmployeeCharge.Credit + wg_EmployeeCharge.PayedOut
        
           'Добавление алиментов в объект класса wg_Alimony
            AlimonyReservAll = 0
            while not IBSQL.Eof
              if AddDebtMontFlg then
              'Накопление долга по алиментам в месяцах, если сотрудник не проработал ни одного часа
                gdcAlimonyDebt.Insert
                gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
                gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = IBSQL.FieldByName("documentkey").AsInteger
                gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = 0
                gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 1
                gdcAlimonyDebt.Post
              else
                FormulaStr = Replace(Replace(IBSQL.FieldByName("usr$formula").AsString, ".", Application.DecimalSeparatorSys), ",", Application.DecimalSeparatorSys)
        
                Sum = wg_GetAlimonySum(wg_FoCal, FormulaStr, _
                      IBSQL.FieldByName("usr$datebegin").AsDateTime, wg_EmployeeCharge.BeginDate)
                'Проверка на бюджет прожиточного минимума
                if wg_EmployeeCharge.BeginDate >= DateSerial(2009, 5, 1) then
                  LivingWage = wg_MonthHour.LivingWage(wg_EmployeeCharge.BeginDate)
                  Count = IBSQL.FieldByName("USR$CHILDCOUNT").AsInteger
                  
                  if IBSQL.FieldByName("USR$LIVINGWAGEPERC").AsCurrency <= 0 then
                    if Count = 1 then
                      LivingWage = LivingWage / 2
                    elseif Count = 2 then
                      LivingWage = LivingWage * 75 / 100
                    elseif Count >= 3 then
        
                    end if
                  else
                    LivingWage = LivingWage *  IBSQL.FieldByName("USR$LIVINGWAGEPERC").AsCurrency / 100
                  end if
                  if Sum < LivingWage then
                    Sum = LivingWage
                  end if
                end if
               'Округление
                Sum = wg_RoundSum(FeeTypeKey, Sum)
                'Суммы для резерва денег по алименты и суммы для их перевода
                if not IBSQL.FieldByName("usr$transfertypekey").isNull then
                  ReservTransferSum = wg_RoundSum(wg_FeeType_TransferDed_ID, Sum * _
                    wg_TransferDed.Types(IBSQL.FieldByName("usr$transfertypekey").AsInteger).GetPercent(wg_EmployeeCharge.EndDate, Sum) / 100)
                else
                  ReservTransferSum = 0
                end if
                'Если резервировать некуда, то ...
                if AlimonyReservAll + Sum + ReservTransferSum > RestSum then
                  SumTmp = RestSum - AlimonyReservAll            'Резервируем все деньги, которые остаются
                else
                  SumTmp = Sum + ReservTransferSum
                end if
                if SumTmp < 0 then
                  SumTmp = 0
                end if
                'Добавление данных по алиментам в экземпляр класса
                call wg_Alimony.Add(IBSQL.FieldByName("documentkey").AsInteger, Sum, _
                               IBSQL.FieldByName("usr$restpercent").AsCurrency, _
                               IBSQL.FieldByName("usr$transfertypekey").Value, SumTmp) 'Sum + ReservTransferSum)
                AlimonyReservAll = AlimonyReservAll + SumTmp 'Sum + ReservTransferSum
              end if
              IBSQL.Next
            wend
            IBSQL.Close
            'Если по сотруднику было накапливание долга по месяцам, то расчет можно завершать
            if AddDebtMontFlg then
              gdcAlimonyDebt.Close
              wg_EmployeeCharge.FirstMoveKey = Null
              exit function
            end if
            'Выборка долгов по алиментам. Сортировка: по долгам в суммах, по дате начала долга
            IBSQL.SQL.Text = "SELECT line.documentkey, IIF(line.usr$debtsum > 0 and line.usr$debtsum > alrest.credit, 0, 1) AS debttype,  " & _
              "  total.usr$datebegin AS thedate, al.documentkey AS alimonykey,  " & _
              "  line.usr$debtsum, alrest.credit, line.usr$debtmonth, pmonth.mcount,  " & _
              "  al.usr$restpercent, al.usr$datebegin, al.usr$transfertypekey, al.usr$formula, al.usr$percent  " & _
              " FROM GD_DOCUMENT d " & _
              " LEFT JOIN usr$wg_alimony al ON al.DOCUMENTKEY = d.ID " & _
              "  LEFT JOIN usr$wg_alimonydebt line ON al.documentkey = line.usr$alimonykey " & _
              "  LEFT JOIN usr$wg_total total ON total.documentkey = line.usr$totaldockey  " & _
              "  LEFT JOIN USR$WG_P_TBLCHARGEBYDOC(al.usr$emplkey, :feetypekey, line.documentkey) alrest ON 1=1  " & _
              "  LEFT JOIN USR$WG_P_ALIMONYPAYEDMONTH(line.documentkey) pmonth ON 1=1  " & _
              "WHERE  " & _
              "  al.usr$emplkey = :emplkey  " & _
              "  AND (alrest.credit < line.usr$debtsum OR line.usr$debtmonth > pmonth.mcount)  " & _
              "  AND d.DOCUMENTTYPEKEY = :ruid  " & _
              "  AND total.USR$DATEBEGIN <= :DB  " & _
              "ORDER BY 2, 3 "
            IBSQL.ParamByName("feetypekey").AsInteger = wg_FeeType_AlimonyDebt_ID
            IBSQL.ParamByName("DB").AsDateTime = wg_EmployeeCharge.BeginDate
            IBSQL.ParamByName("emplkey").AsInteger = wg_EmployeeCharge.Employeekey
            IBSQL.ParamByName("ruid").AsInteger = gdcBaseManager.GetIdByRuidString("147067079_453357870")
            IBSQL.ExecQuery
        '    while not (IBSQL.Eof or RestSum <= MustPaySum)
            'Добавление долгов по алиментам в объект класса wg_Alimony
            while not IBSQL.Eof
        
              if (IBSQL.FieldByName("usr$percent").AsCurrency > 0) and _
                 (IBSQL.FieldByName("usr$percent").AsCurrency < 100) then
                'sum = (RestSum - AlimonyReservAll) * IBSQL.FieldByName("usr$percent").AsCurrency / 100
                sum = (RestSum) * IBSQL.FieldByName("usr$percent").AsCurrency / 100
                if sum > (IBSQL.FieldByName("usr$debtsum").AsCurrency - IBSQL.FieldByName("credit").AsCurrency) then _
                  sum = IBSQL.FieldByName("usr$debtsum").AsCurrency  - IBSQL.FieldByName("credit").AsCurrency
                sum = wg_RoundSum(wg_FeeType_AlimonyDebt_ID, Sum)
              else
                sum = IBSQL.FieldByName("usr$debtsum").AsCurrency - IBSQL.FieldByName("credit").AsCurrency
              end if
              if sum < 0 then sum = 0
              'Если алиментов, по которым есть долг, нет в списке алиментов, то добавим алименты в список
              if not wg_Alimony.Exists(IBSQL.FieldByName("alimonykey").AsInteger) then
                call wg_Alimony.Add(IBSQL.FieldByName("alimonykey").AsInteger, 0, _
                             IBSQL.FieldByName("usr$restpercent").AsCurrency, _
                             IBSQL.FieldByName("usr$transfertypekey").Value, 0)
              end if
              AlimonyKey = IBSQL.FieldByName("alimonykey").AsInteger
              'Долг в месяцах
              DebtMonthCount = IBSQL.FieldByName("usr$debtmonth").AsInteger - IBSQL.FieldByName("mcount").AsInteger
        
              call wg_Alimony.ItemByID(AlimonyKey).Add(_
                IBSQL.FieldByName("documentkey").AsInteger, Sum, DebtMonthCount)
        
              if DebtMonthCount > 0 then
                if wg_Alimony.ItemByID(AlimonyKey).ForDebtMonthSum = 0 then
                  DebtMontSum = wg_GetAlimonySum(wg_FoCal, IBSQL.FieldByName("usr$formula").AsString, _
                        IBSQL.FieldByName("usr$datebegin").AsDateTime, wg_EmployeeCharge.BeginDate)
                 'Округление
                  DebtMontSum = wg_RoundSum(FeeTypeKey, DebtMontSum)
                  wg_Alimony.ItemByID(AlimonyKey).ForDebtMonthSum = DebtMontSum
                  DebtAllMontSum = DebtMontSum * DebtMonthCount
                else
                  DebtAllMontSum = wg_Alimony.ItemByID(AlimonyKey).ForDebtMonthSum * DebtMonthCount
                end if
              else
                DebtAllMontSum = 0
              end if
              wg_Alimony.ItemByID(AlimonyKey).MustPaySum = _
                wg_Alimony.ItemByID(AlimonyKey).MustPaySum + Sum + DebtAllMontSum
              IBSQL.Next
            wend
            IBSQL.Close
        
            AlimonyDebtAllSum = 0
            AlimonyAllSum = 0
            TransferAllSum = 0
            OverReservedSum = 0
            
        '    set gdcAlimonyDebt = Nothing
           'Цикл по алиментам
            for i = 0 to wg_Alimony.Count - 1
            'Определим сумму за перевод и сумму, которую может выплатить сотрудник (с учетом расходов за перевод)
              'Процент остатка. Т.е. процент, который нужно оставить сотруднику
              RestPercentSum = wg_Alimony.Item(i).RestPercent * _
                              (wg_EmployeeCharge.Debit - wg_EmployeeCharge.Credit + wg_EmployeeCharge.PayedOut) / 100
        
              'Сумма для резерва сумм других алиментов. Т.е. сначала нужно выплатить деньги по алиментам, а потом по их долгам
              'Из общей резервной суммы нужно исключить текущие алименты и те, которые уже расчитали
              AlimonyReservAll = AlimonyReservAll - wg_Alimony.Item(i).ReservedSum
        
        '      if AlimonyReservedSum > RestSum then
        '      end if
              OutArray = wg_CalcTransferSum(wg_Alimony.Item(i).MustPaySum, wg_Alimony.Item(i).TransferTypeKey, _
                wg_EmployeeCharge.BeginDate, RestSum - RestPercentSum - AlimonyReservAll)
              CanPaySum = OutArray(0)
              TransferSum = OutArray(1)
              'Занести сумму за пересылку алиментов в начисления по табелю
              if TransferSum > 0 then
                call wg_EmployeeCharge.AddCharge(0, TransferSum, Null, TotalDocKey, wg_FeeType_TransferDed_ID,_
                     wg_Alimony.Item(i).ID, wg_EmployeeCharge.BeginDate, 0, 0)
                     
                call wg_EmployeeCharge.AddChargeRegNew(0, TransferSum, TotalDocKey, wg_FeeType_TransferDed_ID, _
                     AccountKeyTransf, wg_EmployeeCharge.BeginDate, wg_Alimony.Item(i).ID)
        
              end if
        
              'Определение по каким документам возможны выплаты
              'Текущий долг по алиментам
              if wg_Alimony.Item(i).Sum > CanPaySum then
              'Добавление текущего долга в журнал долга по алиментам
        '        if not Assigned(gdcAlimonyDebt) then
        '          set gdcAlimonyDebt = Creator.GetObject(nil, "TgdcUserDocument", "")
        '          gdcAlimonyDebt.SubType = "147072391_453357870"
        '          gdcAlimonyDebt.Transaction = wg_EmployeeCharge.Transaction
        '          gdcAlimonyDebt.Open
        '        end if
                gdcAlimonyDebt.Insert
                gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
                gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = wg_Alimony.Item(i).ID
                gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = wg_Alimony.Item(i).Sum - CanPaySum
                gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 0
                gdcAlimonyDebt.Post
        
                AlimonyDebt = wg_Alimony.Item(i).Sum - CanPaySum
                AlimonySum = CanPaySum
              else
                AlimonySum = wg_Alimony.Item(i).Sum
              end if
              'Занести сумму выплаченных алиментов в начисления по табелю
              if AlimonySum > 0 then
                call wg_EmployeeCharge.AddCharge(0, AlimonySum, Null, TotalDocKey, FeeTypeKey,_
                  wg_Alimony.Item(i).ID, wg_EmployeeCharge.BeginDate, 0, 0)
                call wg_EmployeeCharge.AddChargeRegNew(0, AlimonySum, TotalDocKey, FeeTypeKey, _
                  AccountKey, wg_EmployeeCharge.BeginDate, wg_Alimony.Item(i).ID)
              end if
        
             'Гашение долгов в суммах
              TmpSum = CanPaySum - AlimonySum
              for j = 0 to wg_Alimony.Item(i).Count - 1
                if TmpSum > 0 then
                  if wg_Alimony.Item(i).Item(j).Sum > 0 then
                    if wg_Alimony.Item(i).Item(j).Sum <= TmpSum then
                      AlimonyDebtSum = wg_Alimony.Item(i).Item(j).Sum
                    else
                      AlimonyDebtSum = TmpSum
                    end if
                    'Занести сумму выплаченного долга в начисления по табелю
                    call wg_EmployeeCharge.AddCharge(0, AlimonyDebtSum, Null, TotalDocKey, wg_FeeType_AlimonyDebt_ID,_
                      wg_Alimony.Item(i).Item(j).ID, wg_EmployeeCharge.BeginDate, 0, 0)
                      
                    call wg_EmployeeCharge.AddChargeRegNew(0, AlimonyDebtSum, TotalDocKey, _
                      wg_FeeType_AlimonyDebt_ID, AccountKeyDebt, wg_EmployeeCharge.BeginDate, wg_Alimony.Item(i).Item(j).ID)
        
        
                    AlimonyDebtAllSum = AlimonyDebtAllSum + AlimonyDebtSum
                    TmpSum = TmpSum - AlimonyDebtSum 'wg_Alimony.Item(i).Item(j).Sum
                    end if
                else
                  exit for
                end if
              next
             'Гашение долгов в месяцах
              TmpSum = CanPaySum - AlimonySum - AlimonyDebtSum
              for j = 0 to wg_Alimony.Item(i).Count - 1
                if TmpSum > 0 then
                  if wg_Alimony.Item(i).Item(j).DebtMonth > 0 then
                    'Сумма за все месяцы
                    DebtAllMontSum = wg_Alimony.Item(i).ForDebtMonthSum * wg_Alimony.Item(i).Item(j).DebtMonth
        
                    if DebtAllMontSum <= TmpSum then
                      AlimonyMonthDebtSum = DebtAllMontSum
                      PayedMonthCount = wg_Alimony.Item(i).Item(j).DebtMonth
                    else
                      AlimonyMonthDebtSum = TmpSum
        '              PayedMonthCount = Int(DebtAllMontSum / wg_Alimony.Item(i).ForDebtMonthSum) + 1
                      PayedMonthCount = Int(AlimonyMonthDebtSum / wg_Alimony.Item(i).ForDebtMonthSum)
        
                      if AlimonyMonthDebtSum / wg_Alimony.Item(i).ForDebtMonthSum - PayedMonthCount > 0 then
                        PayedMonthCount = PayedMonthCount + 1
                      end if
        
        
                    end if
                    'Добавим сумму, которую должны выплатить по погашенным месяцам в журнал долгов,
                    ' иначе получится отрицательный кредит по долгу.
                    'TODO: это можно сделать в классе
                    gdcAlimonyDebt.Insert
                    gdcAlimonyDebt.FieldByName("usr$totaldockey").AsInteger = TotalDocKey
                    gdcAlimonyDebt.FieldByName("usr$alimonykey").AsInteger = wg_Alimony.Item(i).ID
                    gdcAlimonyDebt.FieldByName("usr$debtmonth").AsInteger = 0
                    gdcAlimonyDebt.FieldByName("usr$debtsum").AsCurrency = PayedMonthCount * wg_Alimony.Item(i).ForDebtMonthSum
                    gdcAlimonyDebt.Post
                    'Занести сумму выплаченного долга в начисления по табелю на добавленный выше документ
                    call wg_EmployeeCharge.AddCharge(0, AlimonyMonthDebtSum, Null, TotalDocKey, wg_FeeType_AlimonyDebt_ID,_
                      gdcAlimonyDebt.ID, wg_EmployeeCharge.BeginDate, 0, 0)
                      
                    call wg_EmployeeCharge.AddChargeRegNew(0, AlimonyMonthDebtSum, TotalDocKey, _
                      wg_FeeType_AlimonyDebt_ID, AccountKeyDebt, wg_EmployeeCharge.BeginDate, gdcAlimonyDebt.ID)
        
                    'Занести погашенные месяцы в журнал
                    SQLUpdate.ParamByName("totaldockey").AsInteger = TotalDocKey
                    SQLUpdate.ParamByName("alimonydebtkey").AsInteger = wg_Alimony.Item(i).Item(j).ID
                    SQLUpdate.ParamByName("payedmonth").AsInteger = PayedMonthCount
                    SQLUpdate.ExecQuery
                    SQLUpdate.Close
        
                    AlimonyDebtAllSum = AlimonyDebtAllSum + AlimonyMonthDebtSum
                    TmpSum = TmpSum - AlimonyMonthDebtSum
                  end if
                else
                  exit for
                end if
              next
        
              AlimonyAllSum = AlimonyAllSum + AlimonySum
              TransferAllSum = TransferAllSum + TransferSum
              RestSum = RestSum - AlimonySum - AlimonyDebtSum - TransferSum
            next
        
        '  'Добавление сумм в журнал начислений
        '    'Алименты
        '    if AlimonyAllSum > 0 then
        '      AccountKey = wg_GetAccountKey(FeeTypeKey, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.EndDate)
        '      call wg_EmployeeCharge.AddChargeReg(0, AlimonyAllSum, TotalDocKey, FeeTypeKey, AccountKey, Null)
        '    end if
        '    'Выплаты долга по алиментам
        '    if AlimonyDebtAllSum > 0 then               'Сумма выплаты по долгу за алименты
        '      AccountKey = wg_GetAccountKey(wg_FeeType_AlimonyDebt_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.BeginDate)
        '      call wg_EmployeeCharge.AddChargeReg(0, AlimonyDebtAllSum, TotalDocKey, wg_FeeType_AlimonyDebt_ID, AccountKey, Null)
        '    end if
        '    'За почтовый перевод
        '    if TransferAllSum <> 0 then
        '      AccountKey = wg_GetAccountKey(wg_FeeType_TransferDed_ID, wg_EmployeeCharge.EmployeeKey, wg_EmployeeCharge.FirstMoveKey, wg_EmployeeCharge.BeginDate)
        '      call wg_EmployeeCharge.AddChargeReg(0, TransferAllSum, TotalDocKey, wg_FeeType_TransferDed_ID, AccountKey, Null)
        '    end if
        
            gdcAlimonyDebt.Close
        
            wg_FeeAlimonyCalc = AlimonyAllSum + AlimonyDebtAllSum + TransferAllSum
            wg_EmployeeCharge.FirstMoveKey = Null
          end if
        end function
        
        
      DISPLAYSCRIPT: | 
        WG_FEEALIMONYCALC
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: "Алименты, расчет"
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QRAAAAV0dfRU1QTE9ZRUVDSEFSR0URAAAAV0dfRU1QTE9ZRUVDSEFSR0UAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QLAAAAVE9UQUxET0NLRVkLAAAAVE9UQUxET0NLRVkA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARk5TVFBSU1QKAAAARkVFVFlQRUtFWQoAAABGRUVUWVBF
        S0VZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RQUlNUCwAAAE9CSl9GRUVEQVRBCwAAAE9C
        Sl9GRUVEQVRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RGTFBS
      INHERITEDRULE: 0
      USEDEBUGINFO: ~
      EDITIONDATE: 2014-08-06T16:36:01+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147019334_119619099 wg_MonthHour"
          - 
            ADDFUNCTIONKEY: "147168466_481542897 wg_GetAlimonySum"
          - 
            ADDFUNCTIONKEY: "147166442_481542897 wg_CalcTransferSum"
          - 
            ADDFUNCTIONKEY: "147804276_375143752 wg_RoundSum"
          - 
            ADDFUNCTIONKEY: "147743985_374487969 wg_EmplMoveList"
          - 
            ADDFUNCTIONKEY: "147170974_274788016 wg_TblCal"
          - 
            ADDFUNCTIONKEY: "147019760_119619099 wg_WageSettings"
          - 
            ADDFUNCTIONKEY: "147269378_531940465 wg_GetAccountKey"
          - 
            ADDFUNCTIONKEY: "195361376_166214404 wg_FeeAlimonyCalc_pl"