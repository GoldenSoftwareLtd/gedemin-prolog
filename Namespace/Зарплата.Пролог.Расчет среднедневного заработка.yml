%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 151163573_5956463
  Name: "Зарплата.Пролог.Расчет среднедневного заработка"
  Caption: "Начисление отпускных (Пролог-скрипт)"
  Version: "1.0.0.57"
  Optional: False
  Internal: True
Uses: 
  - "147698171_43451302 Зарплата"
Objects: 
  - 
    Properties: 
      Class: "TgdcStoredProc"
      RUID: 151162335_5956463
      AlwaysOverwrite: True
      DontRemove: True
      IncludeSiblings: False
    Fields: 
      RDB$DESCRIPTION: | 
        USR$WG_TBLCALDAY_P
      PROCEDURENAME: "USR$WG_TBLCALDAY_P"
      PROCEDURESOURCE: | 
        CREATE OR ALTER PROCEDURE USR$WG_TBLCALDAY_P (
            IN_EMPLKEY INTEGER,
            IN_FIRSTMOVE INTEGER,
            IN_DATEFROM DATE,
            IN_DATETO DATE)
        RETURNS ( 
            EMPLKEY INTEGER,
            FIRSTMOVEKEY INTEGER,
            THEDAY DATE,
            WYEAR INTEGER,
            WMONTH INTEGER,
            WDAY INTEGER,
            WDURATION INTEGER,
            WORKDAY INTEGER,
            SCHEDULEKEY INTEGER)
         AS
         BEGIN
        FOR
        
        SELECT * FROM
        (
        SELECT
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          tcd.THEDAY,
          EXTRACT(YEAR FROM tcd.THEDAY) AS WYEAR,
          EXTRACT(MONTH FROM tcd.THEDAY) AS WMONTH,
          EXTRACT(DAY FROM tcd.THEDAY) AS WDAY,
          tcd.WDURATION,
          tcd.WORKDAY,
          ml.USR$SCHEDULEKEY
        FROM
          (
          SELECT FIRST 1 * FROM USR$WG_MOVEMENTLINE
          WHERE
            USR$EMPLKEY = :IN_EMPLKEY
            AND
            USR$FIRSTMOVE = :IN_FIRSTMOVE
          ORDER BY USR$DATEBEGIN
          ) ml
        JOIN
          WG_TBLCAL tc
            ON tc.ID = ml.USR$SCHEDULEKEY
        JOIN
          WG_TBLCALDAY tcd
            ON tcd.TBLCALKEY = tc.ID
        WHERE
          ml.USR$EMPLKEY = :IN_EMPLKEY
          AND
          ml.USR$FIRSTMOVE = :IN_FIRSTMOVE
          AND
          COALESCE(tcd.WDURATION, 0) > 0
          AND
          tcd.THEDAY >= :IN_DATEFROM
          AND
          tcd.THEDAY < :IN_DATETO
          AND
          tcd.THEDAY < ml.USR$DATEBEGIN
        UNION ALL
        SELECT
          ml.USR$EMPLKEY,
          ml.USR$FIRSTMOVE AS FirstMoveKey,
          tcd.THEDAY,
          EXTRACT(YEAR FROM tcd.THEDAY) AS WYEAR,
          EXTRACT(MONTH FROM tcd.THEDAY) AS WMONTH,
          EXTRACT(DAY FROM tcd.THEDAY) AS WDAY,
          tcd.WDURATION,
          tcd.WORKDAY,
          ml.USR$SCHEDULEKEY
        FROM
          USR$WG_MOVEMENTLINE ml
        RIGHT JOIN
          WG_TBLCAL tc
            ON tc.ID = ml.USR$SCHEDULEKEY
        JOIN
          WG_TBLCALDAY tcd
            ON tcd.TBLCALKEY = tc.ID
        WHERE
          ml.USR$EMPLKEY = :IN_EMPLKEY
          AND
          ml.USR$FIRSTMOVE = :IN_FIRSTMOVE
          AND
          ml.USR$DATEBEGIN < :IN_DATETO
          AND
          COALESCE(tcd.WDURATION, 0) > 0
          AND
          tcd.THEDAY >= :IN_DATEFROM
          AND
          tcd.THEDAY < :IN_DATETO
          AND
          tcd.THEDAY >= ml.USR$DATEBEGIN
          AND
          tcd.THEDAY <
            COALESCE(
              (
              SELECT
                FIRST 1
                ml_next.USR$DATEBEGIN
              FROM
                USR$WG_MOVEMENTLINE ml_next
              WHERE
                ml_next.USR$EMPLKEY = :IN_EMPLKEY
                AND
                ml_next.USR$FIRSTMOVE = :IN_FIRSTMOVE
                AND
                ml_next.USR$DATEBEGIN > ml.USR$DATEBEGIN
              ORDER BY
                ml_next.USR$DATEBEGIN
              ),
            :IN_DATETO
            )
        ) ml_union
        ORDER BY
          THEDAY
        
        INTO
            :EMPLKEY,
            :FirstMoveKey,
            :THEDAY,
            :WYEAR,
            :WMONTH,
            :WDAY,
            :WDURATION,
            :WORKDAY,
            :SCHEDULEKEY
        DO
          SUSPEND;
        
        END
        
      EDITIONDATE: 2013-11-18T12:13:11+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151164077_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "gdc_dlgUserComplexDocument147020774_119619099"
      MODULE: "MACROS"
      LANGUAGE: "VBScript"
      NAME: "Macros151164077_5956463"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        '#include wg_AvgSalaryStrGenerate
        
        Sub Macros151164077_5956463(OwnerForm)
          'Dim Ret
          
          call wg_AvgSalaryStrGenerate(OwnerForm, 0)
        End Sub
        
      DISPLAYSCRIPT: | 
        MACROS151164077_5956463
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "147021903_119619099 gdc_dlgUserComplexDocument147020774_119619099"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QJAAAAT1dORVJGT1JNCQAAAE9XTkVSRk9STQAAAAAAAAAAAAAAAAsAAAAAAAAAAAAA
        AABGTlNURkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-01-10T16:42:52+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147489128_336327731 wg_AvgSalaryStrGenerate"
  - 
    Properties: 
      Class: "TgdcMacros"
      RUID: 151164075_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "gdc_dlgUserComplexDocument147020774_119619099"
      MACROSGROUPKEY: "147021904_119619099 Локальные макросы"
      FUNCTIONKEY: "151164077_5956463 Macros151164077_5956463"
      NAME: "Рассчитать ср. заработок"
      SERVERKEY: ~
      ISLOCALEXECUTE: 0
      ISREBUILD: 0
      EXECUTEDATE: ~
      SHORTCUT: 0
      EDITIONDATE: 2014-01-10T16:42:52+03:00
      DISPLAYINMENU: 1
      RUNONLOGIN: 0
  - 
    Properties: 
      Class: "TgdcTableField"
      RUID: 155817502_77029543
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      REFRELATIONNAME: ~
      REFLISTFIELD: ~
      REFCROSSRELATION: ~
      SETLISTFIELD: ~
      SETLISTFIELDKEY: ~
      RELATIONTYPE: "T"
      STRINGLENGTH: ~
      DEFSOURCE: | 
        DEFAULT '0'
      COMPUTED_VALUE: ~
      SOURCENULLFLAG: ~
      NULLFLAG: ~
      RDB$FIELD_POSITION: 33
      FIELDNAME: "USR$AVGDAYHOW"
      RELATIONNAME: "USR$WG_FEETYPE"
      FIELDSOURCE: "DBOOLEAN"
      CROSSTABLE: ~
      CROSSFIELD: ~
      RELATIONKEY: "147567082_119619099 Виды начислений, USR$WG_FEETYPE"
      FIELDSOURCEKEY: "147000135_486813904 Логическое, DBOOLEAN"
      CROSSTABLEKEY: ~
      CROSSFIELDKEY: ~
      LNAME: "Дни/часы для среднего"
      LSHORTNAME: "Дни/часы для среднег"
      DESCRIPTION: ~
      VISIBLE: 1
      FORMAT: ~
      ALIGNMENT: "L"
      COLWIDTH: 20
      READONLY: 0
      GDCLASSNAME: ~
      GDSUBTYPE: ~
      OBJECTS: ~
      DELETERULE: ~
      EDITIONDATE: 2013-12-26T15:52:05+03:00
  - 
    Properties: 
      Class: "TgdcAttrUserDefinedLBRBTree"
      SubType: "USR$WG_FEEGROUP"
      RUID: 147757383_84733194
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      PARENT: "147071456_274788016 Все начисления\\Ср. заработок\\Ср. заработок для отпусков"
      DISABLED: 0
      EDITIONDATE: 2014-01-08T18:30:20+03:00
      USR$NAME: "Ср. заработок для отпусков - не осовременивать"
      USR$DESCRIPTION: ~
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151158419_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151163587_5956463
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "pl_GetScriptIDByName"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        
        'uses pl_Const
        Function pl_GetScriptIDByName(Name)
          Dim Creator, ibsql
        
          pl_GetScriptIDByName = 0
        
          Set Creator = New TCreator
          Set ibsql = Creator.GetObject(nil, "TIBSQL", "")
        
          ibsql.Transaction = gdcBaseManager.ReadTransaction
          ibsql.SQL.TEXT = _
              "SELECT * FROM gd_function" & _
              " WHERE UPPER(name) = UPPER(:name) AND module = :module"
          ibsql.ParamByName("name").AsString = Name
          ibsql.ParamByName("module").AsString = scrPrologModuleName
          ibsql.ExecQuery
        
          If Not ibsql.EOF Then
             pl_GetScriptIDByName = ibsql.FieldByName("id").AsInteger
          End If
        End Function
        
      DISPLAYSCRIPT: | 
        PL_GETSCRIPTIDBYNAME
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QEAAAATkFNRQQAAABOQU1FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RGTFBS
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2013-10-11T16:45:28+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 156299481_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151163587_5956463
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_AvgSalary_CoefOption"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        '#include wg_WageSettings
        
        Sub wg_AvgSalary_CoefOption(ByRef Sender)
        '
          Dim InflType, InflFCType
          Dim rbFCRate, rbRateInf, rbMovementRate, rbSalaryInf
          
          InflType = wg_WageSettings.Inflation.InflType
          InflFCType = wg_WageSettings.Inflation.InflFCType
          '
          'От оклада
          Set rbSalaryInf = Sender.GetComponent("usrg_rbSalaryInf")
          rbSalaryInf.Checked = False
          'От ставки 1-го разряда
          Set rbRateInf = Sender.FindComponent("usrg_rbRateInf")
          rbRateInf.Checked = False
          '  справочника
          Set rbFCRate = Sender.FindComponent("usrg_rbFCRate")
          rbFCRate.Checked = False
          '  кадрового движения
          Set rbMovementRate = Sender.FindComponent("usrg_rbMovementRate")
          rbMovementRate.Checked = False
          '
          Select Case InflType
            'usrg_rbSalaryInf - От оклада
            Case 0
              rbSalaryInf.Checked = True
            'usrg_rbRateInf - От ставки 1-го разряда
            Case 1
              rbRateInf.Checked = True
              '
              Select Case InflFCType
                'usrg_rbFCRate - справочника
                Case 0
                  rbFCRate.Checked = True
                'usrg_rbMovementRate - кадрового движения
                Case 2
                  rbMovementRate.Checked = True
              End Select
              '
          End Select
        '
        End Sub
        
      DISPLAYSCRIPT: | 
        WG_AVGSALARY_COEFOPTION
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QGAAAAU0VOREVSBgAAAFNFTkRFUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGTlNU
        RkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-02-27T10:57:15+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147019760_119619099 wg_WageSettings"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 147016040_119619099
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151163587_5956463
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_EnableFieldChange"
      COMMENT: ~
      SCRIPT: | 
        option explicit
        
        sub wg_CheckVariableExists(ByRef Self, ByVal VarName)
          if not Self.VariableExists(VarName) then
            Self.AddVariableItem(VarName)
            Self.Variables(VarName) = 0
          end if
        end sub
        
        sub wg_CheckObjectExists(ByRef Self, ByVal VarName, ByRef O)
          if not Self.ObjectExists(VarName) then
            Self.AddObjectItem(VarName)
            Self.Objects(VarName) = O
          end if
        end sub
        
        sub wg_EnableFieldChange(ByRef Self, ByVal VarName)
          call wg_CheckVariableExists(Self, VarName)
          if Self.Variables(VarName) > 0 then
            Self.Variables(VarName) = Self.Variables(VarName) - 1
          end if
        end sub
        
        sub wg_DisableFieldChange(ByRef Self, ByVal VarName)
          call wg_CheckVariableExists(Self, VarName)
          Self.Variables(VarName) = Self.Variables(VarName) + 1
        end sub
        
        function wg_EnabledFieldChange(ByRef Self, ByVal VarName)
          call wg_CheckVariableExists(Self, VarName)
          wg_EnabledFieldChange = (Self.Variables(VarName) = 0)
        end function
        
      DISPLAYSCRIPT: | 
        WG_CHECKVARIABLEEXISTS
        WG_CHECKOBJECTEXISTS
        WG_ENABLEFIELDCHANGE
        WG_DISABLEFIELDCHANGE
        WG_ENABLEDFIELDCHANGE
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QEAAAAU0VMRgQAAABTRUxGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RQUlNU
        BwAAAFZBUk5BTUUHAAAAVkFSTkFNRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGTlNURkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: ~
      EDITIONDATE: 2007-03-13T16:49:05+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 147019760_119619099
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151163587_5956463
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_WageSettings"
      COMMENT: ~
      SCRIPT: | 
        option explicit
        function wg_WageSettings
          if not Assigned(wg_WageSettings_) then
            set wg_WageSettings_ = New Twg_WageSettings
          end if
          
          set wg_WageSettings = wg_WageSettings_
        end function
        
      DISPLAYSCRIPT: | 
        WG_WAGESETTINGS
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: ~
      EDITIONDATE: 2004-12-24T12:23:47+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151163587_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_AvgSalaryStrGenerate_pl"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        '#include wg_WageSettings
        '#include wg_EnableFieldChange
        '#include pl_GetScriptIDByName
        '#include wg_AvgSalary_CoefOption
        
        Function wg_AvgSalaryStrGenerate_pl(ByRef Sender, ByVal CalcType)
        '
          Dim T, T1, T2
          
          Dim Creator, gdcObject, gdcSalary
          '
          Dim PL, Ret, Pred, Tv, Append
          'avg_wage
          Dim P_main, Tv_main, Q_main
          'avg_wage_in
          Dim P_in, Tv_in, Q_in
          Dim EmplKey, FirstMoveKey, DateCalc
          Dim InflType, InflFCType
          Dim MonthOffset, CoefOption
          'avg_wage_run, avg_wage_sql
          Dim P_run, Tv_run, Q_run, P_sql, Tv_sql, Q_sql, P_kb
          Dim DateCalcFrom, DateCalcTo
          Dim Connection, PredicateName, Arity, SQL
          'avg_wage_out, avg_wage_det
          Dim P_out, Tv_out, Q_out, P_det, Tv_det, Q_det
          Dim AvgWage, AvgWageRule
          Dim Period, PeriodRule, Wage, ModernWage, ModernCoef
          Dim TabDays, TabHoures, NormDays, NormHoures
          Dim IsFull, IsCheck
        
          T1 = Timer
          wg_AvgSalaryStrGenerate_pl = False
          Set Creator = New TCreator
          
          Sender.GetComponent("actApply").Execute
        
          Set gdcObject = Sender.gdcObject
          '
          EmplKey = gdcObject.FieldByName("usr$emplkey").AsInteger
          FirstMoveKey = gdcObject.FieldByName("usr$firstmovekey").AsInteger
          '
          if CalcType = 0 then
            dim IBSQL
            set IBSQL = Creator.GetObject(nil, "TIBSQL", "")
            IBSQL.Transaction = gdcBaseManager.ReadTransaction
            IBSQL.SQL.Text = _
              "select " & _
              "  t.USR$DATEBEGIN " & _
              "from " & _
              "  usr$wg_total t " & _
              "where " & _
              "  t.DOCUMENTKEY = :TDK "
            IBSQL.ParamByName("TDK").asInteger = gdcObject.FieldByName("USR$TOTALDOCKEY").AsInteger
            IBSQL.ExecQuery
            DateCalc = IBSQL.FieldByName("USR$DATEBEGIN").AsDateTime
          else
            DateCalc = gdcObject.FieldByName("usr$from").AsDateTime
          end if
          '
          MonthOffset = 0
          '
          InflType = wg_WageSettings.Inflation.InflType
          InflFCType = wg_WageSettings.Inflation.InflFCType
          'CoefOption: fc_fcratesum ; ml_rate ; ml_msalary
          Select Case InflType
            'usrg_rbSalaryInf - От оклада
            Case 0
              CoefOption = "ml_msalary"
            'usrg_rbRateInf - От ставки 1-го разряда
            Case 1
              Select Case InflFCType
                'usrg_rbFCRate - справочника
                Case 0
                  CoefOption = "fc_fcratesum"
                'usrg_rbMovementRate - кадрового движения
                Case 2
                  CoefOption = "ml_rate"
              End Select
          End Select
          '
        
          'проблема wg_WageSettings
          'CoefOption = "ml_rate" 'только для ММК, иначе эту строку закомментировать
        
          wg_AvgSalary_CoefOption(Sender)
        
          'init
          Set PL = Creator.GetObject(nil, "TgsPLClient", "")
          Ret = PL.Initialise("")
          If Not Ret Then
            Exit Function
          End If
          'debug
          PL.Debug = True
          'load
          Ret = PL.LoadScript(pl_GetScriptIDByName("twg_avg_wage"))
          If Not Ret Then
            Exit Function
          End If
        
          Set gdcSalary = Sender.GetComponent("usrg_gdcAvgSalaryStr")
          '
          Call wg_DisableFieldChange(gdcSalary, "AVGSALARYCALC")
          '
          gdcSalary.First
          While Not gdcSalary.EOF
            gdcSalary.Delete
          Wend
          '
          gdcObject.FieldByName("USR$AVGSUMMA").AsCurrency = 0
          '
          Sender.Repaint
        
          'avg_wage_in(EmplKey, FirstMoveKey, DateCalc, MonthOffset, CoefOption)
          P_in = "avg_wage_in"
          Set Tv_in = Creator.GetObject(5, "TgsPLTermv", "")
          Set Q_in = Creator.GetObject(nil, "TgsPLQuery", "")
          Tv_in.PutInteger 0, EmplKey
          Tv_in.PutInteger 1, FirstMoveKey
          Tv_in.PutDate 2, DateCalc
          Tv_in.PutInteger 3, MonthOffset
          Tv_in.PutAtom 4, CoefOption
          '
          Q_in.PredicateName = P_in
          Q_in.Termv = Tv_in
          '
          Q_in.OpenQuery
          If Q_in.EOF Then
            Exit Function
          End If
          Q_in.Close
        
          'avg_wage(_) - prepare data
          P_main = "avg_wage"
          Set Tv_main = Creator.GetObject(1, "TgsPLTermv", "")
          Set Q_main = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_main.PredicateName = P_main
          Q_main.Termv = Tv_main
          '
          Q_main.OpenQuery
          If Q_main.EOF Then
            Exit Function
          End If
          Q_main.Close
        
          'avg_wage_run(EmplKey, FirstMoveKey, DateCalcFrom, DateCalcTo)
          P_run = "avg_wage_run"
          Set Tv_run = Creator.GetObject(4, "TgsPLTermv", "")
          Set Q_run = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_run.PredicateName = P_run
          Q_run.Termv = Tv_run
          'avg_wage_sql(EmplKey, FirstMoveKey, Connection, PredicateName, Arity, SQL)
          P_sql = "avg_wage_sql"
          P_kb = "avg_wage_kb"
          Set Tv_sql = Creator.GetObject(6, "TgsPLTermv", "")
          Set Q_sql = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_sql.PredicateName = P_sql
          Q_sql.Termv = Tv_sql
          '
          Q_run.OpenQuery
          If Q_run.EOF Then
            Exit Function
          End If
          '
          Append = False
          '
          Do Until Q_run.EOF
            EmplKey = Tv_run.ReadInteger(0)
            FirstMoveKey = Tv_run.ReadInteger(1)
            DateCalcFrom = Tv_run.ReadDate(2)
            DateCalcTo = Tv_run.ReadDate(3)
            '
            Tv_sql.Reset
            Tv_sql.PutInteger 0, EmplKey
            Tv_sql.PutInteger 1, FirstMoveKey
            Q_sql.OpenQuery
            '
            Do Until Q_sql.EOF
              Connection = Tv_sql.ReadAtom(2)
              PredicateName = Tv_sql.ReadAtom(3)
              Arity = Tv_sql.ReadInteger(4)
              SQL = Tv_sql.ReadString(5)
              '
              Ret =  PL.MakePredicatesOfSQLSelect _
                        (SQL, _
                        gdcBaseManager.ReadTransaction, _
                        PredicateName, PredicateName, Append)
              If Ret >= 0 Then
                 Ret = PL.Call(P_kb, Tv_sql)
              End If
              '
              Q_sql.NextSolution
            Loop
            Q_sql.Close
            '
            Append = True
            '
            Q_run.NextSolution
          Loop
          Q_run.Close
        
          'save param_list
          If PL.Debug Then
            Pred = "param_list"
            Set Tv = Creator.GetObject(3, "TgsPLTermv", "")
            PL.SavePredicatesToFile Pred, Tv, Pred
          End If
        
          'avg_wage(Variant) - calc result
          Q_main.OpenQuery
          If Q_main.EOF Then
            Exit Function
          End If
          Q_main.Close
        
          'avg_wage_out(EmplKey, FirstMoveKey, AvgWage, AvgWageVariant)
          P_out = "avg_wage_out"
          Set Tv_out = Creator.GetObject(4, "TgsPLTermv", "")
          Set Q_out = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_out.PredicateName = P_out
          Q_out.Termv = Tv_out
          'avg_wage_det(EmplKey, FirstMoveKey,
          '   Period, PeriodRule, Wage, ModernCoef, ModernWage,
          '   TabDays, NormDays, TabHoures, NormHoures)
          P_det = "avg_wage_det"
          Set Tv_det = Creator.GetObject(11, "TgsPLTermv", "")
          Set Q_det = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_det.PredicateName = P_det
          Q_det.Termv = Tv_det
          '
          Q_out.OpenQuery
          If Q_out.EOF Then
            Exit Function
          End If
          '
          Do Until Q_out.EOF
            EmplKey = Tv_out.ReadInteger(0)
            FirstMoveKey = Tv_out.ReadInteger(1)
            AvgWage = Tv_out.ReadFloat(2)
            AvgWageRule = Tv_out.ReadAtom(3)
            '
            Tv_det.Reset
            Tv_det.PutInteger 0, EmplKey
            Tv_det.PutInteger 1, FirstMoveKey
            Q_det.OpenQuery
            '
            Do Until Q_det.EOF
              Period = Tv_det.ReadDate(2)
              PeriodRule = Tv_det.ReadAtom(3)
              IsFull = _
                Abs( PeriodRule = "by_days_houres" _
                    Or PeriodRule = "by_houres" _
                    Or PeriodRule = "by_days" )
              IsCheck = Abs( Not (PeriodRule = "none") )
              '
              If AvgWageRule = "by_calc_month" Then
                Select Case PeriodRule
                  Case "by_days_houres"
                    PeriodRule = "табель равен графику по дням и часам"
                  Case "by_days"
                    PeriodRule = "табель покрывает график по дням"
                  Case "by_houres"
                    PeriodRule = "табель покрывает график по часам"
                  Case "by_month_wage_all"
                    PeriodRule = "по размеру заработка (не меньше всех полных)"
                  Case "by_month_wage_any"
                    PeriodRule = "по размеру заработка (не меньше любого полного)"
                  Case "by_month_no_bad_type"
                    PeriodRule = "виды начислений и типы часов в норме"
                  Case Else
                    PeriodRule = ""
                End Select
              ElseIf AvgWageRule = "by_avg_houre" Then
                PeriodRule = "по среднечасовому"
              End If
              '
              Wage = Tv_det.ReadFloat(4)
              ModernCoef = Tv_det.ReadFloat(5)
              ModernWage = Tv_det.ReadFloat(6)
              TabDays = Tv_det.ReadFloat(7)
              NormDays = Tv_det.ReadFloat(8)
              TabHoures = Tv_det.ReadFloat(9)
              NormHoures = Tv_det.ReadFloat(10)
              '
              gdcSalary.Append
              gdcSalary.FieldByName("USR$DATE").AsVariant = Period
              gdcSalary.FieldByName("USR$SALARY").AsVariant = Wage
              gdcSalary.FieldByName("USR$COEFF").AsVariant = ModernCoef
              gdcSalary.FieldByName("USR$MODERNSALARY").AsVariant = ModernWage
              gdcSalary.FieldByName("USR$DOW").AsVariant = TabDays
              gdcSalary.FieldByName("USR$HOW").AsVariant = TabHoures
              gdcSalary.FieldByName("USR$SCHEDULERDOW").AsVariant = NormDays
              gdcSalary.FieldByName("USR$SCHEDULERHOW").AsVariant = NormHoures
              gdcSalary.FieldByName("USR$ISCHECK").AsVariant = IsCheck
              gdcSalary.FieldByName("USR$ISFULL").AsVariant = IsFull
              gdcSalary.FieldByName("USR$DESCRIPTION").AsVariant = PeriodRule
              gdcSalary.Post
              '
              Q_det.NextSolution
            Loop
            Q_det.Close
            '
            Q_out.NextSolution
          Loop
          Q_out.Close
          '
        
          gdcSalary.First
          '
          Call wg_EnableFieldChange(gdcSalary, "AVGSALARYCALC")
          '
          gdcObject.FieldByName("USR$AVGSUMMA").AsCurrency = AvgWage
          gdcObject.Post
          '
        
          wg_AvgSalaryStrGenerate_pl = True
          
          T2 = Timer
          T = T2 - T1
        '
        End function
        
      DISPLAYSCRIPT: | 
        WG_AVGSALARYSTRGENERATE_PL
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QGAAAAU0VOREVSBgAAAFNFTkRFUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGTlNU
        UFJTVAgAAABDQUxDVFlQRQgAAABDQUxDVFlQRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGTlNU
        RkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-03T12:36:14+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "147019760_119619099 wg_WageSettings"
          - 
            ADDFUNCTIONKEY: "147016040_119619099 wg_EnableFieldChange"
          - 
            ADDFUNCTIONKEY: "151158419_5956463 pl_GetScriptIDByName"
          - 
            ADDFUNCTIONKEY: "156299481_119200397 wg_AvgSalary_CoefOption"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 156300136_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_AvgSalaryDetailGenerate_pl"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        '#include pl_GetScriptIDByName
        
        Function wg_AvgSalaryDetailGenerate_pl(ByRef Sender)
        '
          Dim Creator, gdcObject, gdcDetail
          '
          Dim PL, Ret, Pred, Tv, Append
          'struct_vacation_sql
          Dim P_sql, Tv_sql, Q_sql
          Dim Connection, PredicateName, Arity, SQL
          'struct_vacation_in
          Dim P_in, Tv_in, Q_in
          Dim DateCalc, DateBegin, DateEnd, AvgWage
          'struct_vacation_out
          Dim P_out, Tv_out, Q_out
          Dim AccDate, IncludeDate, Duration, Summa
          
          wg_AvgSalaryDetailGenerate_pl = False
          Set Creator = New TCreator
        
          Sender.GetComponent("actApply").Execute
        
          Set gdcObject = Sender.gdcObject
          '
          DateBegin = gdcObject.FieldByName("USR$DATEBEGIN").AsDateTime
          DateEnd = gdcObject.FieldByName("USR$DATEEND").AsDateTime
          AvgWage = gdcObject.FieldByName("USR$AVGSUMMA").AsCurrency
          '
          Dim IBSQL
          Set IBSQL = Creator.GetObject(nil, "TIBSQL", "")
          IBSQL.Transaction = gdcBaseManager.ReadTransaction
          IBSQL.SQL.Text = _
              "select " & _
              "  t.USR$DATEBEGIN " & _
              "from " & _
              "  usr$wg_total t " & _
              "where " & _
              "  t.DOCUMENTKEY = :TDK "
          IBSQL.ParamByName("TDK").asInteger = gdcObject.FieldByName("USR$TOTALDOCKEY").AsInteger
          IBSQL.ExecQuery
          DateCalc = IBSQL.FieldByName("USR$DATEBEGIN").AsDateTime
          '
          
          'init
          Set PL = Creator.GetObject(nil, "TgsPLClient", "")
          Ret = PL.Initialise("")
          If Not Ret Then
            Exit Function
          End If
          'debug
          PL.Debug = True
          'load
          Ret = PL.LoadScript(pl_GetScriptIDByName("twg_struct"))
          If Not Ret Then
            Exit Function
          End If
        
          Set gdcDetail = Sender.gdcDetailObject
          '
          gdcDetail.First
          While Not gdcDetail.EOF
            gdcDetail.Delete
          Wend
          '
          Sender.Repaint
        
          'struct_vacation_sql(DateBegin, DateEnd, Connection, PredicateName, Arity, SQL)
          P_sql = "struct_vacation_sql"
          Set Tv_sql = Creator.GetObject(6, "TgsPLTermv", "")
          Set Q_sql = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_sql.PredicateName = P_sql
          Q_sql.Termv = Tv_sql
          '
          Append = False
          '
          Tv_sql.PutDate 0, DateBegin
          Tv_sql.PutDate 1, DateEnd
          '
          Q_sql.OpenQuery
          Do Until Q_sql.EOF
            Connection = Tv_sql.ReadAtom(2)
            PredicateName = Tv_sql.ReadAtom(3)
            Arity = Tv_sql.ReadInteger(4)
            SQL = Tv_sql.ReadString(5)
            '
            Ret =  PL.MakePredicatesOfSQLSelect _
                      (SQL, _
                      gdcBaseManager.ReadTransaction, _
                      PredicateName, PredicateName, Append)
            '
            Q_sql.NextSolution
          Loop
          Q_sql.Close
          '
        
          'struct_vacation_in(DateCalc, DateBegin, DateEnd, AvgWage)
          P_in = "struct_vacation_in"
          Set Tv_in = Creator.GetObject(4, "TgsPLTermv", "")
          Set Q_in = Creator.GetObject(nil, "TgsPLQuery", "")
          Tv_in.PutDate 0, DateCalc
          Tv_in.PutDate 1, DateBegin
          Tv_in.PutDate 2, DateEnd
          Tv_in.PutFloat 3, AvgWage
          '
          Q_in.PredicateName = P_in
          Q_in.Termv = Tv_in
          '
          Q_in.OpenQuery
          If Q_in.EOF Then
            Exit Function
          End If
          Q_in.Close
        
          'struct_vacation_out(AccDate, IncludeDate, Duration, Summa, DateBegin, DateEnd)
          P_out = "struct_vacation_out"
          Set Tv_out = Creator.GetObject(6, "TgsPLTermv", "")
          Set Q_out = Creator.GetObject(nil, "TgsPLQuery", "")
          Q_out.PredicateName = P_out
          Q_out.Termv = Tv_out
          Q_out.OpenQuery
          If Q_out.EOF Then
            Exit Function
          End If
          '
          Do Until Q_out.EOF
            '
            AccDate = Tv_out.ReadDate(0)
            IncludeDate = Tv_out.ReadDate(1)
            Duration = Tv_out.ReadInteger(2)
            Summa = Tv_out.ReadFloat(3)
            DateBegin = Tv_out.ReadDate(4)
            DateEnd = Tv_out.ReadDate(5)
            '
            gdcDetail.Append
            gdcDetail.FieldByName("USR$ACCDATE").AsVariant = AccDate
            gdcDetail.FieldByName("USR$INCLUDEDATE").AsVariant = IncludeDate
            gdcDetail.FieldByName("USR$DURATION").AsVariant = Duration
            gdcDetail.FieldByName("USR$SUMMA").AsVariant = Summa
            gdcDetail.FieldByName("USR$DATEBEGIN").AsVariant = DateBegin
            gdcDetail.FieldByName("USR$DATEEND").AsVariant = DateEnd
            gdcDetail.Post
            '
            Q_out.NextSolution
          Loop
          Q_out.Close
          '
          gdcDetail.First
        
          wg_AvgSalaryDetailGenerate_pl = True
        '
        End function
        
      DISPLAYSCRIPT: | 
        WG_AVGSALARYDETAILGENERATE_PL
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QGAAAAU0VOREVSBgAAAFNFTkRFUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGTlNU
        RkxQUg==
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-03T11:54:55+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151158419_5956463 pl_GetScriptIDByName"
  - 
    Properties: 
      Class: "TgdcStorageFolder"
      RUID: 147063986_1439110857
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
    Fields: 
      PARENT: "990010_17 USER - Administrator"
      NAME: "gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      DATA_TYPE: "F"
      STR_DATA: ~
      INT_DATA: ~
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2010-04-20T13:32:16+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 154648252_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063986_1439110857
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "WS"
      DATA_TYPE: "I"
      STR_DATA: ~
      INT_DATA: 2
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2013-08-12T19:08:11+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 154648251_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063986_1439110857
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "Width"
      DATA_TYPE: "I"
      STR_DATA: ~
      INT_DATA: 1382
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2014-02-26T10:01:11+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 154648250_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063986_1439110857
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "Left"
      DATA_TYPE: "I"
      STR_DATA: ~
      INT_DATA: -8
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2014-02-26T10:01:11+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 154648249_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063986_1439110857
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "Top"
      DATA_TYPE: "I"
      STR_DATA: ~
      INT_DATA: -8
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2014-02-26T10:01:11+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 154648248_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063986_1439110857
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "Height"
      DATA_TYPE: "I"
      STR_DATA: ~
      INT_DATA: 744
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2014-02-26T10:01:11+03:00
  - 
    Properties: 
      Class: "TgdcStorageFolder"
      RUID: 147063987_1439110857
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "ibgrDetail(TgsIBGrid)"
      DATA_TYPE: "F"
      STR_DATA: ~
      INT_DATA: ~
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2010-04-20T13:32:16+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 147123779_1439110857
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063987_1439110857
    Fields: 
      PARENT: "147063987_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)\\ibgrDetail(TgsIBGrid)"
      NAME: "data"
      DATA_TYPE: "B"
      STR_DATA: ~
      INT_DATA: ~
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: !!binary > 
        VFBGMAYNR1JJRF9TVFJFQU1fNAEGBlRhaG9tYQYMY2xXaW5kb3dUZXh0AvUAAggAA8wAAAYIY2xX
        aW5kb3cBBgZUYWhvbWEGD2NsSGlnaGxpZ2h0VGV4dAL1AAIIAAPMAAAGC2NsSGlnaGxpZ2h0AQYG
        VGFob21hBgxjbFdpbmRvd1RleHQC9QACCAADzAAABgljbEJ0bkZhY2UJBgkkMDBFN0YzRjcGCSQw
        MEQ2RTdFNw4ACAgOAAgOAQhFeHBhbmRlZAgJRmllbGROYW1lBgtVU1IkQUNDREFURQ1UaXRsZS5D
        YXB0aW9uBg/E4PLgIO3g9+jx6+Xt6P8FV2lkdGgCbAdWaXNpYmxlCQABCEV4cGFuZGVkCAlGaWVs
        ZE5hbWUGD1VTUiRJTkNMVURFREFURQ1UaXRsZS5DYXB0aW9uBg/E4PLgIOfg9+jx6+Xt6P8FV2lk
        dGgCbAdWaXNpYmxlCQABCUFsaWdubWVudAcOdGFSaWdodEp1c3RpZnkIRXhwYW5kZWQICUZpZWxk
        TmFtZQYMVVNSJERVUkFUSU9ODVRpdGxlLkNhcHRpb24GA8Tt6AVXaWR0aAIkB1Zpc2libGUJCVRv
        dGFsVHlwZQcFdHRTdW0AAQlBbGlnbm1lbnQHDnRhUmlnaHRKdXN0aWZ5CEV4cGFuZGVkCAlGaWVs
        ZE5hbWUGCVVTUiRTVU1NQQ1UaXRsZS5DYXB0aW9uBgXR8+zs4AVXaWR0aAJIB1Zpc2libGUJDURp
        c3BsYXlGb3JtYXQGBCMuIyMJVG90YWxUeXBlBwV0dFN1bQABCEV4cGFuZGVkCAlGaWVsZE5hbWUG
        DVVTUiREQVRFQkVHSU4NVGl0bGUuQ2FwdGlvbgYLxODy4CDt4Pfg6+AFV2lkdGgCbAdWaXNpYmxl
        CQABCEV4cGFuZGVkCAlGaWVsZE5hbWUGC1VTUiREQVRFRU5EDVRpdGxlLkNhcHRpb24GDsTg8uAg
        7uru7ffg7ej/BVdpZHRoAmwHVmlzaWJsZQkAAQlBbGlnbm1lbnQHDnRhUmlnaHRKdXN0aWZ5CEV4
        cGFuZGVkCAlGaWVsZE5hbWUGBlNVTU5DVQ1UaXRsZS5DYXB0aW9uBgZzdW1uY3UFV2lkdGgC/wdW
        aXNpYmxlCAABCEV4cGFuZGVkCAlGaWVsZE5hbWUGDERPQ1VNRU5UREFURQ1UaXRsZS5DYXB0aW9u
        BgTE4PLgBVdpZHRoAv8HVmlzaWJsZQgAAQhFeHBhbmRlZAgJRmllbGROYW1lBgtERVNDUklQVElP
        Tg1UaXRsZS5DYXB0aW9uBgjO7+jx4O3o5QVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZp
        ZWxkTmFtZQYOVVNSJFNPUlROVU1CRVIIUmVhZE9ubHkIDVRpdGxlLkNhcHRpb24GFM3u7OXwIOTr
        /yDx7vDy6PDu4uroBVdpZHRoAv8HVmlzaWJsZQgAAQhFeHBhbmRlZAgJRmllbGROYW1lBgJJRA1U
        aXRsZS5DYXB0aW9uBgTK6/73BVdpZHRoAv8HVmlzaWJsZQgAAQhFeHBhbmRlZAgJRmllbGROYW1l
        BgZQQVJFTlQNVGl0bGUuQ2FwdGlvbgYI0O7k6PLl6/wFV2lkdGgC/wdWaXNpYmxlCAABCEV4cGFu
        ZGVkCAlGaWVsZE5hbWUGD0RPQ1VNRU5UVFlQRUtFWQ1UaXRsZS5DYXB0aW9uBg3S6O8g5O7q8+zl
        7fLgBVdpZHRoAv8HVmlzaWJsZQgAAQhFeHBhbmRlZAgJRmllbGROYW1lBglUUlRZUEVLRVkNVGl0
        bGUuQ2FwdGlvbgYO0ujvIPLw4O3n4Or26OgFV2lkdGgC/wdWaXNpYmxlCAABCEV4cGFuZGVkCAlG
        aWVsZE5hbWUGDlRSQU5TQUNUSU9OS0VZDVRpdGxlLkNhcHRpb24GCtLw4O3n4Or26P8FV2lkdGgC
        /wdWaXNpYmxlCAABCEV4cGFuZGVkCAlGaWVsZE5hbWUGBk5VTUJFUg1UaXRsZS5DYXB0aW9uBgXN
        7uzl8AVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZpZWxkTmFtZQYHU1VNQ1VSUg1UaXRs
        ZS5DYXB0aW9uBg7R8+zs4CDiIOLg6/7y5QVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZp
        ZWxkTmFtZQYHREVMQVlFRA1UaXRsZS5DYXB0aW9uBgrO8uvu5uXt7fvpBVdpZHRoAv8HVmlzaWJs
        ZQgAAQhFeHBhbmRlZAgJRmllbGROYW1lBgdDVVJSS0VZDVRpdGxlLkNhcHRpb24GBsLg6/7y4AVX
        aWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZpZWxkTmFtZQYKQ09NUEFOWUtFWQ1UaXRsZS5D
        YXB0aW9uBgjK7uzv4O3o/wVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZpZWxkTmFtZQYK
        Q1JFQVRPUktFWQ1UaXRsZS5DYXB0aW9uBgrK8u4g8e7n5ODrBVdpZHRoAv8HVmlzaWJsZQgAAQhF
        eHBhbmRlZAgJRmllbGROYW1lBgxDUkVBVElPTkRBVEUNVGl0bGUuQ2FwdGlvbgYNxODy4CDx7ufk
        4O3o/wVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZpZWxkTmFtZQYJRURJVE9SS0VZDVRp
        dGxlLkNhcHRpb24GDMry7iDo8e/w4OLo6wVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZp
        ZWxkTmFtZQYLRURJVElPTkRBVEUNVGl0bGUuQ2FwdGlvbgYOxODy4CDo5+zl7eXt6P8FV2lkdGgC
        /wdWaXNpYmxlCAABCEV4cGFuZGVkCAlGaWVsZE5hbWUGCVBSSU5UREFURQ1UaXRsZS5DYXB0aW9u
        BgvE4PLgIO/l9+Dy6AVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZpZWxkTmFtZQYIRElT
        QUJMRUQNVGl0bGUuQ2FwdGlvbgYJzvLq6/735e3uBVdpZHRoAv8HVmlzaWJsZQgAAQhFeHBhbmRl
        ZAgJRmllbGROYW1lBghSRVNFUlZFRA1UaXRsZS5DYXB0aW9uBg/H4PDl5+Xw4ujw7uLg7e4FV2lk
        dGgC/wdWaXNpYmxlCAABCEV4cGFuZGVkCAlGaWVsZE5hbWUGC0RPQ1VNRU5US0VZCFJlYWRPbmx5
        CQ1UaXRsZS5DYXB0aW9uBg7K6/73IOTu6vPs5e3y4AVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5k
        ZWQICUZpZWxkTmFtZQYJTUFTVEVSS0VZCFJlYWRPbmx5CQ1UaXRsZS5DYXB0aW9uBifQ7uTo8uXr
        /CAozeD36PHr5e3o5SDu8u/z8eru4ijv7ufo9uj/KSkFV2lkdGgC/wdWaXNpYmxlCAABCEV4cGFu
        ZGVkCAlGaWVsZE5hbWUGCVJFU0VSVkVEMQhSZWFkT25seQkNVGl0bGUuQ2FwdGlvbgYux+Dw5efl
        8OLo8O7i4O3uICjN4Pfo8evl7ejlIO7y7/Px6u7iKO/u5+j26P8pKQVXaWR0aAL/B1Zpc2libGUI
        AAEIRXhwYW5kZWQICUZpZWxkTmFtZQYFU1VNRVENVGl0bGUuQ2FwdGlvbgYT0fPs7OAg4iD96uLo
        4uDr5e3y5QVXaWR0aAL/B1Zpc2libGUIAAEIRXhwYW5kZWQICUZpZWxkTmFtZQYKVVNSJEVRUkFU
        RQ1UaXRsZS5DYXB0aW9uBgnK8/DxIP3q4i4FV2lkdGgC/wdWaXNpYmxlCAABCUFsaWdubWVudAcO
        dGFSaWdodEp1c3RpZnkIRXhwYW5kZWQICUZpZWxkTmFtZQYFQUZVTEwNVGl0bGUuQ2FwdGlvbgYN
        z+7r7fvpIOTu8fLz7wVXaWR0aAL/B1Zpc2libGUIAAEJQWxpZ25tZW50Bw50YVJpZ2h0SnVzdGlm
        eQhFeHBhbmRlZAgJRmllbGROYW1lBgVBQ0hBRw1UaXRsZS5DYXB0aW9uBhnP8O7x7O7y8CDoIPDl
        5ODq8ujw7uLg7ejlBVdpZHRoAv8HVmlzaWJsZQgAAQlBbGlnbm1lbnQHDnRhUmlnaHRKdXN0aWZ5
        CEV4cGFuZGVkCAlGaWVsZE5hbWUGBUFWSUVXDVRpdGxlLkNhcHRpb24GD9Lu6/zq7iDv8O7x7O7y
        8AVXaWR0aAL/B1Zpc2libGUIAAAICP0cCQg=
      EDITIONDATE: 2014-02-26T15:58:19+03:00
  - 
    Properties: 
      Class: "TgdcStorageFolder"
      RUID: 154648246_77029543
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "pnlMaster(TPanel)"
      DATA_TYPE: "F"
      STR_DATA: ~
      INT_DATA: ~
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2013-08-12T19:08:11+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 154648247_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 154648246_77029543
    Fields: 
      PARENT: "154648246_77029543 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)\\pnlMaster(TPanel)"
      NAME: "Height"
      DATA_TYPE: "I"
      STR_DATA: ~
      INT_DATA: 298
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2014-02-03T16:11:00+03:00
  - 
    Properties: 
      Class: "TgdcStorageFolder"
      RUID: 147063989_1439110857
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
    Fields: 
      PARENT: "147063986_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)"
      NAME: "usrg_grAvgSalaryStr(TgsIBGrid)"
      DATA_TYPE: "F"
      STR_DATA: ~
      INT_DATA: ~
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: ~
      EDITIONDATE: 2010-04-20T13:32:16+03:00
  - 
    Properties: 
      Class: "TgdcStorageValue"
      RUID: 147123780_1439110857
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: True
      HeadObject: 147063989_1439110857
    Fields: 
      PARENT: "147063989_1439110857 USER - Administrator\\gdc_dlgUserComplexDocument147020774_119619099(Tgdc_dlgUserComplexDocument)\\usrg_grAvgSalaryStr(TgsIBGrid)"
      NAME: "data"
      DATA_TYPE: "B"
      STR_DATA: ~
      INT_DATA: ~
      DATETIME_DATA: ~
      CURR_DATA: ~
      BLOB_DATA: !!binary > 
        VFBGMAYNR1JJRF9TVFJFQU1fNAEGBlRhaG9tYQYMY2xXaW5kb3dUZXh0AvUAAggAA8wAAAYIY2xX
        aW5kb3cBBgZUYWhvbWEGD2NsSGlnaGxpZ2h0VGV4dAL1AAIIAAPMAAAGC2NsSGlnaGxpZ2h0AQYG
        VGFob21hBgxjbFdpbmRvd1RleHQC9QACCAADzAAABgljbEJ0bkZhY2UJBgkkMDBFN0YzRjcGCSQw
        MEQ2RTdFNw4BDERpc3BsYXlGaWVsZAYHVVNSJERPVwlGaWVsZE5hbWUGB1VTUiRIT1cJTGluZUNv
        dW50AgEHT3B0aW9ucwsLY2VvQWRkRmllbGQAAAEMRGlzcGxheUZpZWxkBhBVU1IkU0NIRURVTEVS
        RE9XCUZpZWxkTmFtZQYQVVNSJFNDSEVEVUxFUkhPVwlMaW5lQ291bnQCAQdPcHRpb25zCwtjZW9B
        ZGRGaWVsZAAAAQxEaXNwbGF5RmllbGQGDVVTUiRORVdTQUxBUlkJRmllbGROYW1lBg1VU1IkT0xE
        U0FMQVJZCUxpbmVDb3VudAIBB09wdGlvbnMLC2Nlb0FkZEZpZWxkAAABDERpc3BsYXlGaWVsZAYK
        VVNSJFNBTEFSWQlGaWVsZE5hbWUGEFVTUiRNT0RFUk5TQUxBUlkJTGluZUNvdW50AgEHT3B0aW9u
        cwsLY2VvQWRkRmllbGQAAAAICA4ACA4BCUFsaWdubWVudAcNdGFMZWZ0SnVzdGlmeQhFeHBhbmRl
        ZAgJRmllbGROYW1lBgpVU1IkSVNGVUxMDVRpdGxlLkNhcHRpb24GDM/u6+376SDs5fH/9gVXaWR0
        aAIwB1Zpc2libGUJAAEJQWxpZ25tZW50Bw10YUxlZnRKdXN0aWZ5CEV4cGFuZGVkCAlGaWVsZE5h
        bWUGC1VTUiRJU0NIRUNLDVRpdGxlLkNhcHRpb24GBMLq6y4FV2lkdGgCMAdWaXNpYmxlCQlUb3Rh
        bFR5cGUHBXR0U3VtAAEJQWxpZ25tZW50Bw10YUxlZnRKdXN0aWZ5CEV4cGFuZGVkCAlGaWVsZE5h
        bWUGCFVTUiREQVRFDVRpdGxlLkNhcHRpb24GBMTg8uAFV2lkdGgCSAdWaXNpYmxlCQABCUFsaWdu
        bWVudAcOdGFSaWdodEp1c3RpZnkIRXhwYW5kZWQICUZpZWxkTmFtZQYKVVNSJFNBTEFSWQ1UaXRs
        ZS5DYXB0aW9uBgjH4PDv6+Dy4AVXaWR0aAJIB1Zpc2libGUJDURpc3BsYXlGb3JtYXQGBCMuIyMA
        AQlBbGlnbm1lbnQHDnRhUmlnaHRKdXN0aWZ5CEV4cGFuZGVkCAlGaWVsZE5hbWUGCVVTUiRDT0VG
        Rg1UaXRsZS5DYXB0aW9uBgbK7v30LfIFV2lkdGgCNAdWaXNpYmxlCQABCUFsaWdubWVudAcOdGFS
        aWdodEp1c3RpZnkIRXhwYW5kZWQICUZpZWxkTmFtZQYQVVNSJE1PREVSTlNBTEFSWQ1UaXRsZS5D
        YXB0aW9uBhTR7uLw5ezl7e3g/yDn4PDv6+Dy4AVXaWR0aAJUB1Zpc2libGUJDURpc3BsYXlGb3Jt
        YXQGBCMuIyMJVG90YWxUeXBlBwV0dFN1bQABCUFsaWdubWVudAcOdGFSaWdodEp1c3RpZnkIRXhw
        YW5kZWQICUZpZWxkTmFtZQYHVVNSJERPVw1UaXRsZS5DYXB0aW9uBgPE7egFV2lkdGgCJAdWaXNp
        YmxlCQlUb3RhbFR5cGUHBXR0U3VtAAEJQWxpZ25tZW50Bw10YUxlZnRKdXN0aWZ5CEV4cGFuZGVk
        CAlGaWVsZE5hbWUGEFVTUiRTQ0hFRFVMRVJET1cNVGl0bGUuQ2FwdGlvbgYLxO3l6SDv7iDj8C4F
        V2lkdGgCSAdWaXNpYmxlCQABCUFsaWdubWVudAcOdGFSaWdodEp1c3RpZnkIRXhwYW5kZWQICUZp
        ZWxkTmFtZQYHVVNSJEhPVw1UaXRsZS5DYXB0aW9uBgTX4PH7BVdpZHRoAisHVmlzaWJsZQkJVG90
        YWxUeXBlBwV0dFN1bQABCUFsaWdubWVudAcNdGFMZWZ0SnVzdGlmeQhFeHBhbmRlZAgJRmllbGRO
        YW1lBhBVU1IkU0NIRURVTEVSSE9XDVRpdGxlLkNhcHRpb24GDNfg8e7iIO/uIOPwLgVXaWR0aAJM
        B1Zpc2libGUJAAEJQWxpZ25tZW50Bw10YUxlZnRKdXN0aWZ5CEV4cGFuZGVkCAlGaWVsZE5hbWUG
        D1VTUiRERVNDUklQVElPTg1UaXRsZS5DYXB0aW9uBgjO7+jx4O3o5QVXaWR0aAPeAAdWaXNpYmxl
        CQABCUFsaWdubWVudAcNdGFMZWZ0SnVzdGlmeQhFeHBhbmRlZAgJRmllbGROYW1lBg1VU1IkT0xE
        U0FMQVJZDVRpdGxlLkNhcHRpb24GBc7q6+DkBVdpZHRoAv8HVmlzaWJsZQgAAQlBbGlnbm1lbnQH
        DXRhTGVmdEp1c3RpZnkIRXhwYW5kZWQICUZpZWxkTmFtZQYNVVNSJE5FV1NBTEFSWQ1UaXRsZS5D
        YXB0aW9uBg3S5erz+ejpIO7q6+DkBVdpZHRoAv8HVmlzaWJsZQgAAQlBbGlnbm1lbnQHDXRhTGVm
        dEp1c3RpZnkIRXhwYW5kZWQICUZpZWxkTmFtZQYCSUQIUmVhZE9ubHkJDVRpdGxlLkNhcHRpb24G
        Dcjk5e3y6PTo6uDy7vAFV2lkdGgC/wdWaXNpYmxlCAABCUFsaWdubWVudAcNdGFMZWZ0SnVzdGlm
        eQhFeHBhbmRlZAgJRmllbGROYW1lBg9VU1IkRE9DVU1FTlRLRVkNVGl0bGUuQ2FwdGlvbgYIxO7q
        8+zl7fIFV2lkdGgC/wdWaXNpYmxlCAABCUFsaWdubWVudAcNdGFMZWZ0SnVzdGlmeQhFeHBhbmRl
        ZAgJRmllbGROYW1lBhhaX1VTUiRET0NVTUVOVEtFWV9OVU1CRVINVGl0bGUuQ2FwdGlvbgYFze7s
        5fAFV2lkdGgC/wdWaXNpYmxlCAABCUFsaWdubWVudAcNdGFMZWZ0SnVzdGlmeQhFeHBhbmRlZAgJ
        RmllbGROYW1lBh5aX1VTUiRET0NVTUVOVEtFWV9ET0NVTUVOVERBVEUNVGl0bGUuQ2FwdGlvbgYE
        xODy4AVXaWR0aAL/B1Zpc2libGUIAAAICP0MCQg=
      EDITIONDATE: 2014-02-26T15:58:19+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189469_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "lib"
      COMMENT: ~
      SCRIPT: | 
        % lib
        
        % подготовка SQL-строки
        prepare_sql(InSQL, [], InSQL) :-
            !.
        prepare_sql(InSQL,[Key-Value|Pairs], OutSQL) :-
            replace_all(InSQL, Key, Value, InSQL1),
            !,
            prepare_sql(InSQL1, Pairs, OutSQL).
        
        % to_currency(+NumIn, -NumOut)
        to_currency(NumIn, NumOut) :-
            to_currency(NumIn, NumOut, 4),
            !.
        % to_currency(+NumIn, -NumOut, +Round)
        to_currency(NumIn, NumOut, Round) :-
            number(NumIn), integer(Round),
            NumOut is float( round( NumIn * (10 ** Round) ) / (10 ** Round) ),
            !.
        
        % make_list(+Num, -List)
        make_list(Num, List) :-
            integer(Num),
            make_list(Num, List, 0),
            !.
        
        make_list(Num, [], Num) :-
            !.
        make_list(Num, [_|Tail], Zero) :-
            Num1 is Num - 1,
            !,
            make_list(Num1, Tail, Zero).
        
        % replace_all(+In, +Search, +Replace, -Out)
        replace_all(In, Search, Replace, Out) :-
            replace(In, Search, Replace, In1),
            \+ In = In1,
            !,
            replace_all(In1, Search, Replace, Out).
        replace_all(In, _, _, In).
        
        % replace(+In, +Search, +Replace, -Out)
        replace(In, Search, Replace, Out) :-
            text_list([In, Search, Replace], [InCodes, SearchCodes, ReplaceCodes]),
            replace_list(InCodes, SearchCodes, ReplaceCodes, OutCodes),
            text_in_out(In, OutCodes, Out),
            !.
        replace(In, _, _, In).
        
        %
        text_list([], []) :-
            !.
        text_list([Head|Teil], [Head1|Rest]) :-
            text_in_out(Head, Head1, Head),
            !,
            text_list(Teil, Rest).
        
        %
        text_in_out(In, OutCodes, Out) :-
            ( atom(In), atom_codes(Out, OutCodes)
            ; string(In), string_codes(Out, OutCodes)
            ; number(In), number_codes(Out, OutCodes)
            ; integer_list(In), Out = In ),
            !,
            \+ In = [].
        
        %
        integer_list([]).
        integer_list([Head|Tail]) :-
            integer(Head),
            integer_list(Tail).
        
        %
        replace_list([InHead1,InHead2,InHead3|InChars], [InHead1,InHead2,InHead3|SearchChars], ReplaceChars, OutChars) :-
            append([InHead1,InHead2,InHead3|SearchChars], RestChars, [InHead1,InHead2,InHead3|InChars]),
            append(ReplaceChars, RestChars, OutChars),
            !.
        replace_list([InHead|InChars], [InHead|SearchChars], ReplaceChars, OutChars) :-
            append([InHead|SearchChars], RestChars, [InHead|InChars]),
            append(ReplaceChars, RestChars, OutChars),
            !.
        replace_list([InHead|InTail], SearchChars, ReplaceChars, [InHead|OutChars]) :-
            !,
            replace_list(InTail, SearchChars, ReplaceChars, OutChars).
        
        %
        remove_list(_, [], []) :-
            !.
        remove_list([Elem|Elems], List, Rest) :-
            remove_list(Elem, List, List1),
            remove_list(Elems, List1, Rest),
            !.
        remove_list(Elem, [Elem|[]], []).
        remove_list(Elem, [Elem|Tail], Rest) :-
            remove_list(Elem, Tail, Rest),
            !.
        remove_list(Elem, [Head|Tail], [Head|Rest]) :-
            remove_list(Elem, Tail, Rest).
        
        %
        member_list([], _) :-
            !.
        member_list([Head|Tail], List) :-
            member(Head, List),
            !,
            member_list(Tail, List).
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-03T10:42:26+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189468_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "params"
      COMMENT: ~
      SCRIPT: | 
        % params
        
        %:- ensure_loaded(lib).
        /* remove_list, member_list */
        
        :-
            dynamic(param_list/3),
            multifile(param_list/3),
            discontiguous(param_list/3).
        
        % param_list(?Scope, ?Type, ?Pairs)
        %   Scope - name of context
        %   Type  - protocol support
        %       Client: in; data; got; restart; test; ...
        %       Server: run; query; temp; log; out; clean; error; ...
        %   Pairs - list of pairs Key-Value or mixed with other
        
        % new_param_list(+Scope, +Type, +Pairs)
        new_param_list(Scope, Type, Pairs) :-
            ground([Scope, Type, Pairs]),
            ( \+ param_list(Scope, Type, Pairs),
              assertz( param_list(Scope, Type, Pairs) ) ; true ),
            !.
        
        % dispose_param_list(?Scope, ?Type, ?Pairs)
        dispose_param_list(Scope, Type, Pairs) :-
            retractall( param_list(Scope, Type, Pairs) ),
            !.
        
        % get_param(?Scope, ?Type, ?Param)
        get_param(Scope, Type, Param) :-
            param_list(Scope, Type, Pairs),
            once( member(Param, Pairs) ).
        % get_param(?Scope, ?Type, ?Param, ?Pairs)
        get_param(Scope, Type, Param, Pairs) :-
            param_list(Scope, Type, Pairs),
            once( member(Param, Pairs) ).
        
        % get_param_list(?Scope, ?Type, ?Params)
        get_param_list(Scope, Type, Params) :-
            param_list(Scope, Type, Pairs),
            once( member_list(Params, Pairs) ).
        % get_param_list(?Scope, ?Type, ?Params, ?Pairs)
        get_param_list(Scope, Type, Params, Pairs) :-
            param_list(Scope, Type, Pairs),
            once( member_list(Params, Pairs) ).
        
        % find_param(+Scope, +Type, +Key1-Value1, ?Key2-Value2)
        find_param(Scope, Type, Key1-Value1, Key2-Value2) :-
            find_param_list(Scope, Type, Key1-Value1, Pairs),
            once( member(Key2-Value2, Pairs) ).
        % find_param(+Scope, +Type, +Pairs0, ?Key-Value)
        find_param(Scope, Type, Pairs0, Key-Value) :-
            find_param_list(Scope, Type, Pairs0, Pairs),
            once( member(Key-Value, Pairs) ).
        
        % find_param_list(+Scope, +Type, +Key-Value, ?Pairs)
        find_param_list(Scope, Type, Key-Value, Pairs) :-
            ground([Scope, Type, Key-Value]),
            param_list(Scope, Type, Pairs0),
            once( member(Key-Value, Pairs0) ),
            remove_list(Key-Value, Pairs0, Pairs).
        % find_param_list(+Scope, +Type, +Pairs0, ?Pairs)
        find_param_list(Scope, Type, Pairs0, Pairs) :-
            ground([Scope, Type, Pairs0]),
            Pairs0 = [Key-Value|Tail],
            find_param_list(Scope, Type, Key-Value, Pairs1),
            once( member_list(Tail, Pairs1) ),
            remove_list(Tail, Pairs1, Pairs).
        
        %
        get_scope(Scope) :-
            findall(Scope0, param_list(Scope0, _, _), ScopeList0),
            sort(ScopeList0, ScopeList),
            member(Scope, ScopeList).
        
        %
        get_scope_list(ScopeList) :-
            findall(Scope0, param_list(Scope0, _, _), ScopeList0),
            sort(ScopeList0, ScopeList),
            !.
        
        %
        get_type(Type) :-
            findall(Type0, param_list(_, Type0, _), TypeList0),
            sort(TypeList0, TypeList),
            member(Type, TypeList).
        
        %
        get_type_list(TypeList) :-
            findall(Type0, param_list(_, Type0, _), TypeList0),
            sort(TypeList0, TypeList),
            !.
        
        %
        get_scope_type(Scope-Type) :-
            findall(Scope0-Type0, param_list(Scope0, Type0, _), ScopeTypeList0),
            sort(ScopeTypeList0, ScopeTypeList),
            member(Scope-Type, ScopeTypeList).
        
        %
        get_scope_type_list(ScopeTypeList) :-
            findall(Scope0-Type0, param_list(Scope0, Type0, _), ScopeTypeList0),
            sort(ScopeTypeList0, ScopeTypeList),
            !.
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-01-03T15:11:52+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189470_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151189370_18175251
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_avg_wage_sql"
      COMMENT: ~
      SCRIPT: | 
        % twg_avg_wage_sql
        
        :-
            GetSQL = [gd_pl_ds/5, get_sql/4],
            dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql([
                    usr_wg_DbfSums/6,
                    usr_wg_MovementLine/11,
                    usr_wg_FCRate/4,
                    usr_wg_TblDayNorm/8,
                    usr_wg_TblYearNorm/5,
                    usr_wg_TblCalLine/7,
                    usr_wg_TblCal_FlexLine/68,
                    -usr_wg_HourType/11,
                    usr_wg_TblCharge/9,
                    usr_wg_FeeType/5,
                    usr_wg_FeeTypeNoCoef/4,
                    usr_wg_BadHourType/3,
                    usr_wg_BadFeeType/3
                    ]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            member(Functor/Arity, ValidSQL),
            !.
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_DbfSums, 6,
            [
            fEmplKey-integer, fInSum-float, fInHoures-float,
            fInYear-integer, fInMonth-integer, fDateBegin-date
            ]).
        % usr_wg_DbfSums(EmplKey, InSum, InHoures, InYear, InMonth, DateBegin)
        get_sql(gsdb, usr_wg_DbfSums/6,
        "SELECT \c
          Z.USR$EMPLKEY, \c
          COALESCE(Z.USR$SUM, 0) AS INSUM, \c
          COALESCE(Z.USR$MID_HOW, 0) AS INHOURES, \c
          EXTRACT(YEAR FROM IDK.USR$DATEBEGIN) AS InYear, \c
          EXTRACT(MONTH FROM IDK.USR$DATEBEGIN) AS InMonth, \c
          IDK.USR$DATEBEGIN \c
        FROM \c
          USR$GMK_SUMS Z \c
        JOIN \c
          USR$WG_TOTAL IDK \c
            ON IDK.DOCUMENTKEY  =  Z.USR$INDOCKEY \c
        WHERE \c
          Z.USR$EMPLKEY = pEmplKey \c
          AND \c
          IDK.USR$DATEBEGIN >= \'pDateCalcFrom\' \c
          AND \c
          IDK.USR$DATEBEGIN < \'pDateCalcTo\' \c
        ORDER BY \c
          Z.USR$EMPLKEY, \c
          IDK.USR$DATEBEGIN \c
        ",
        [pEmplKey-_, pDateCalcFrom-_, pDateCalcTo-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_MovementLine, 11,
            [
            fEmplKey-integer, fDocumentKey-integer, fFirstMoveKey-integer,
            fMoveYear-integer, fMoveMonth-integer, fDateBegin-date,
            fScheduleKey-integer, fMovementType-integer,
            fRate-float, fListNumber-string, fMSalary-float
            ]).
        % usr_wg_MovementLine(EmplKey, DocumentKey, FirstMoveKey,
        %   MoveYear, MoveMonth, DateBegin,
        %   ScheduleKey, MovementType, Rate, ListNumber, MSalary)
        get_sql(gsdb, usr_wg_MovementLine/11,
        "SELECT \c
          ml.USR$EMPLKEY, \c
          ml.DOCUMENTKEY, \c
          ml.USR$FIRSTMOVE AS FirstMoveKey, \c
          EXTRACT(YEAR FROM ml.USR$DATEBEGIN) AS MoveYear, \c
          EXTRACT(MONTH FROM ml.USR$DATEBEGIN) AS MoveMonth, \c
          ml.USR$DATEBEGIN, \c
          ml.USR$SCHEDULEKEY, \c
          ml.USR$MOVEMENTTYPE, \c
          COALESCE(ml.USR$RATE, 0) AS Rate, \c
          ml.USR$LISTNUMBER, \c
          COALESCE(ml.USR$MSALARY, 0) AS MSalary \c
        FROM \c
          USR$WG_MOVEMENTLINE ml \c
        WHERE \c
          ml.USR$EMPLKEY = pEmplKey \c
          AND \c
          ml.USR$FIRSTMOVE = pFirstMoveKey \c
        ORDER BY \c
          ml.USR$EMPLKEY, \c
          ml.USR$FIRSTMOVE, \c
          ml.USR$DATEBEGIN \c
        ",
        [pEmplKey-_, pFirstMoveKey-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_FCRate, 4,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fDate-date, fFCRateSum-float
            ]).
        % usr_wg_FCRate(EmplKey, FirstMoveKey, Date, FCRateSum)
        get_sql(gsdb, usr_wg_FCRate/4,
        "SELECT \c
          pEmplKey AS EmplKey, \c
          pFirstMoveKey AS FirstMoveKey, \c
          fc.USR$WG_DATE, \c
          fc.USR$WG_FCRATESUM \c
        FROM \c
          USR$WG_FCRATE fc \c
        ORDER BY \c
          fc.USR$WG_DATE \c
        ",
        [pEmplKey-_, pFirstMoveKey-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_TblDayNorm, 8,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fWYear-integer, fWMonth-integer, fTheDay-date, fWDay-integer,
            fWDuration-float, fWorkDay-integer
            ]).
        % usr_wg_TblDayNorm(EmplKey, FirstMoveKey, WYear, WMonth, TheDay, WDay, WDuration, WorkDay)
        get_sql(gsdb, usr_wg_TblDayNorm/8,
        "\c
        SELECT EmplKey, FirstMoveKey, WYear, WMonth, TheDay, WDay, WDuration, WorkDay \c
        FROM USR$WG_TBLCALDAY_P(pEmplKey, pFirstMoveKey, \'pDateCalcFrom\', \'pDateCalcTo\') \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_TblYearNorm, 5,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fWYear-integer,
            fWHoures-float, fWDays-integer
            ]).
        % usr_wg_TblYearNorm(EmplKey, FirstMoveKey, WYear, WHoures, WDays)
        get_sql(gsdb, usr_wg_TblYearNorm/5,
        "\c
        SELECT EmplKey, FirstMoveKey, WYear, SUM(WDuration) AS WHoures, SUM(WorkDay) AS WDays \c
        FROM USR$WG_TBLCALDAY_P(pEmplKey, pFirstMoveKey, \'pDateNormFrom\', \'pDateNormTo\') \c
        GROUP BY EmplKey, FirstMoveKey, WYear \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pDateNormFrom-_, pDateNormTo-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_TblCalLine, 7,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDate-date,
            fDuration-float, fHoureType-integer
            ]).
        % usr_wg_TblCalLine(EmplKey, FirstMoveKey, CalYear, CalMonth, Date, Duration, HoureType)
        get_sql(gsdb, usr_wg_TblCalLine/7,
        "SELECT \c
          tc.USR$EMPLKEY, \c
          tc.USR$FIRSTMOVEKEY, \c
          EXTRACT(YEAR FROM tcl.USR$DATE) AS CalYear, \c
          EXTRACT(MONTH FROM tcl.USR$DATE) AS CalMonth, \c
          tcl.USR$DATE, \c
          tcl.USR$DURATION, \c
          tcl.USR$HOURTYPE \c
        FROM \c
          USR$WG_TBLCAL tc \c
        JOIN \c
          USR$WG_TBLCALLINE tcl \c
            ON tcl.MASTERKEY = tc.DOCUMENTKEY \c
        WHERE \c
          tc.USR$EMPLKEY = pEmplKey \c
          AND \c
          tc.USR$FIRSTMOVEKEY = pFirstMoveKey \c
          AND \c
          tcl.USR$DATE >= \'pDateCalcFrom\' \c
          AND \c
          tcl.USR$DATE < \'pDateCalcTo\' \c
        ORDER BY \c
          tc.USR$EMPLKEY, \c
          tc.USR$FIRSTMOVEKEY, \c
          tcl.USR$DATE \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_TblCal_FlexLine, 68,
            [fFlexType-string,
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fS1-variant, fH1-variant, fS2-variant, fH2-variant,
            fS3-variant, fH3-variant, fS4-variant, fH4-variant,
            fS5-variant, fH5-variant, fS6-variant, fH6-variant,
            fS7-variant, fH7-variant, fS8-variant, fH8-variant,
            fS9-variant, fH9-variant, fS10-variant, fH10-variant,
            fS11-variant, fH11-variant, fS12-variant, fH12-variant,
            fS13-variant, fH13-variant, fS14-variant, fH14-variant,
            fS15-variant, fH15-variant, fS16-variant, fH16-variant,
            fS17-variant, fH17-variant, fS18-variant, fH18-variant,
            fS19-variant, fH19-variant, fS20-variant, fH20-variant,
            fS21-variant, fH21-variant, fS22-variant, fH22-variant,
            fS23-variant, fH23-variant, fS24-variant, fH24-variant,
            fS25-variant, fH25-variant, fS26-variant, fH26-variant,
            fS27-variant, fH27-variant, fS28-variant, fH28-variant,
            fS29-variant, fH29-variant, fS30-variant, fH30-variant,
            fS31-variant, fH31-variant
            ]).
        % usr_wg_TblCal_FlexLine(FlexType, EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin, S1, H1, ..., S31, H31)
        get_sql(gsdb, usr_wg_TblCal_FlexLine/68,
        "SELECT \c
          CASE gd.DOCUMENTTYPEKEY \c
            WHEN pTblCal_DocType_Plan THEN \'plan\' \c
            WHEN pTblCal_DocType_Fact THEN \'fact\' \c
          END \c
            AS FlexType, \c
          tcfl.USR$EMPLKEY, \c
          tcfl.USR$FIRSTMOVEKEY, \c
          EXTRACT(YEAR FROM t.USR$DATEBEGIN) AS CalYear, \c
          EXTRACT(MONTH FROM t.USR$DATEBEGIN) AS CalMonth, \c
          t.USR$DATEBEGIN, \c
          tcfl.USR$S1, tcfl.USR$H1, tcfl.USR$S2, tcfl.USR$H2, \c
          tcfl.USR$S3, tcfl.USR$H3, tcfl.USR$S4, tcfl.USR$H4, \c
          tcfl.USR$S5, tcfl.USR$H5, tcfl.USR$S6, tcfl.USR$H6, \c
          tcfl.USR$S7, tcfl.USR$H7, tcfl.USR$S8, tcfl.USR$H8, \c
          tcfl.USR$S9, tcfl.USR$H9, tcfl.USR$S10, tcfl.USR$H10, \c
          tcfl.USR$S11, tcfl.USR$H11, tcfl.USR$S12, tcfl.USR$H12, \c
          tcfl.USR$S13, tcfl.USR$H13, tcfl.USR$S14, tcfl.USR$H14, \c
          tcfl.USR$S15, tcfl.USR$H15, tcfl.USR$S16, tcfl.USR$H16, \c
          tcfl.USR$S17, tcfl.USR$H17, tcfl.USR$S18, tcfl.USR$H18, \c
          tcfl.USR$S19, tcfl.USR$H19, tcfl.USR$S20, tcfl.USR$H20, \c
          tcfl.USR$S21, tcfl.USR$H21, tcfl.USR$S22, tcfl.USR$H22, \c
          tcfl.USR$S23, tcfl.USR$H23, tcfl.USR$S24, tcfl.USR$H24, \c
          tcfl.USR$S25, tcfl.USR$H25, tcfl.USR$S26, tcfl.USR$H26, \c
          tcfl.USR$S27, tcfl.USR$H27, tcfl.USR$S28, tcfl.USR$H28, \c
          tcfl.USR$S29, tcfl.USR$H29, tcfl.USR$S30, tcfl.USR$H30, \c
          tcfl.USR$S31, tcfl.USR$H31 \c
        FROM \c
          GD_DOCUMENT gd \c
        JOIN \c
          USR$WG_TBLCAL_FLEXLINE tcfl \c
            ON gd.ID = tcfl.DOCUMENTKEY \c
        JOIN \c
          USR$WG_TBLCAL_FLEX tcf \c
            ON tcf.DOCUMENTKEY = tcfl.MASTERKEY \c
        JOIN \c
          USR$WG_TOTAL t \c
            ON t.DOCUMENTKEY = tcf.USR$TOTALDOCKEY \c
        WHERE \c
          gd.DOCUMENTTYPEKEY IN(pTblCal_DocType_Plan,pTblCal_DocType_Fact) \c
          AND \c
          tcfl.USR$EMPLKEY = pEmplKey \c
          AND \c
          tcfl.USR$FIRSTMOVEKEY = pFirstMoveKey \c
          AND \c
          t.USR$DATEBEGIN >= \'pDateCalcFrom\' \c
          AND \c
          t.USR$DATEBEGIN < \'pDateCalcTo\' \c
         ORDER BY \c
           tcfl.USR$EMPLKEY, \c
           tcfl.USR$FIRSTMOVEKEY, \c
           t.USR$DATEBEGIN \c
        ",
        [pTblCal_DocType_Plan-_, pTblCal_DocType_Fact-_,
        pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_HourType, 11,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fID-integer, fCode-string, fDigitCode-string,
            fDiscription-string, fIsWorked-integer, fShortName-string,
            fForCalFlex-integer, fForOverTime-integer, fForFlex-integer
            ]).
        % usr_wg_HourType(EmplKey, FirstMoveKey,
        %   ID, Code, DigitCode, Description, IsWorked, ShortName,
        %   ForCalFlex, ForOverTime, ForFlex)
        get_sql(gsdb, usr_wg_HourType/11,
        "SELECT \c
          pEmplKey AS EmplKey, \c
          pFirstMoveKey AS FirstMoveKey, \c
          ht.ID, \c
          ht.USR$CODE, \c
          ht.USR$DIGITCODE, \c
          ht.USR$DISCRIPTION \c,
          ht.USR$ISWORKED, \c
          ht.USR$SHORTNAME, \c
          ht.USR$FORCALFLEX, \c
          ht.USR$FOROVERTIME, \c
          ht.USR$FORFLEX \c
        FROM \c
          USR$WG_HOURTYPE ht \c
        ",
        [pEmplKey-_, pFirstMoveKey-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_TblCharge, 9,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fCalYear-integer, fCalMonth-integer, fDateBegin-date,
            fDebit-float, fFeeTypeKey-integer, fDOW-float, fHOW-float
            ]).
        % usr_wg_TblCharge(EmplKey, FirstMoveKey, CalYear, CalMonth, DateBegin,
        %   Debit, FeeTypeKey, DOW, HOW)
        get_sql(gsdb, usr_wg_TblCharge/9,
        "SELECT \c
          tch.USR$EMPLKEY, \c
          tch.USR$FIRSTMOVEKEY, \c
          EXTRACT(YEAR FROM tch.USR$DATEBEGIN) AS CalYear, \c
          EXTRACT(MONTH FROM tch.USR$DATEBEGIN) AS CalMonth, \c
          tch.USR$DATEBEGIN, \c
          tch.USR$DEBIT, \c
          tch.USR$FEETYPEKEY, \c
          tch.USR$DOW, \c
          tch.USR$HOW \c
        FROM \c
          USR$WG_TBLCHARGE tch \c
        WHERE \c
          tch.USR$EMPLKEY = pEmplKey \c
          AND \c
          NOT tch.USR$DEBIT = 0 \c
          AND \c
          tch.USR$DATEBEGIN >= \'pDateCalcFrom\' \c
          AND \c
          tch.USR$DATEBEGIN < \'pDateCalcTo\' \c
        ORDER BY \c
          tch.USR$EMPLKEY, \c
          tch.USR$DATEBEGIN \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pDateCalcFrom-_, pDateCalcTo-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_FeeType, 5,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fFeeGroupKey-integer, fFeeTypeKey-integer, fAvgDayHOW-integer
            ]).
        % usr_wg_FeeType(EmplKey, FirstMoveKey, FeeGroupKey, FeeTypeKey, AvgDayHOW)
        get_sql(gsdb, usr_wg_FeeType/5,
        "SELECT \c
          pEmplKey AS EmplKey,  \c
          pFirstMoveKey AS FirstMoveKey, \c
          ft.USR$WG_FEEGROUPKEY, \c
          ft.USR$WG_FEETYPEKEY, \c
          ft_avg.USR$AVGDAYHOW \c
        FROM \c
          USR$CROSS179_256548741 ft \c
        JOIN \c
          USR$WG_FEETYPE ft_avg \c
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY \c
        WHERE \c
          ft.USR$WG_FEEGROUPKEY IN \c
        (SELECT id FROM gd_ruid \c
        WHERE xid = pFeeGroupKey_xid \c
        AND dbid = pFeeGroupKey_dbid \c
        ) \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pFeeGroupKey_xid-_, pFeeGroupKey_dbid-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_FeeTypeNoCoef, 4,
            [
            fEmplKey-integer, fFirstMoveKey-integer,
            fFeeGroupKeyNoCoef-integer, fFeeTypeKeyNoCoef-integer
            ]).
        % usr_wg_FeeTypeNoCoef(EmplKey, FirstMoveKey, FeeGroupKeyNoCoef, FeeTypeKeyNoCoef)
        get_sql(gsdb, usr_wg_FeeTypeNoCoef/4,
        "SELECT \c
          pEmplKey AS EmplKey,  \c
          pFirstMoveKey AS FirstMoveKey, \c
          ft.USR$WG_FEEGROUPKEY, \c
          ft.USR$WG_FEETYPEKEY \c
        FROM \c
          USR$CROSS179_256548741 ft \c
        JOIN \c
          USR$WG_FEETYPE ft_avg \c
            ON ft_avg.ID = ft.USR$WG_FEETYPEKEY \c
        WHERE \c
          ft.USR$WG_FEEGROUPKEY IN \c
        (SELECT id FROM gd_ruid \c
        WHERE xid = pFeeGroupKeyNoCoef_xid \c
        AND dbid = pFeeGroupKeyNoCoef_dbid \c
        ) \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pFeeGroupKeyNoCoef_xid-_, pFeeGroupKeyNoCoef_dbid-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_BadHourType, 3,
            [
            fEmplKey-integer, fFirstMoveKey-integer, fID-integer
            ]).
        % usr_wg_BadHourType(EmplKey, FirstMoveKey, ID)
        get_sql(gsdb, usr_wg_BadHourType/3,
        "SELECT \c
          pEmplKey AS EmplKey, pFirstMoveKey AS FirstMoveKey, id \c
        FROM USR$WG_HOURTYPE \c
        WHERE id IN \c
        (SELECT id FROM gd_ruid \c
        WHERE xid IN (pBadHourType_xid_IN) \c
        AND dbid = pBadHourType_dbid \c
        ) \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pBadHourType_xid_IN-_, pBadHourType_dbid-_]
            ).
        
        gd_pl_ds(wg_avg_wage_vacation, in, usr_wg_BadFeeType, 3,
            [
            fEmplKey-integer, fFirstMoveKey-integer, fID-integer
            ]).
        % usr_wg_BadFeeType(EmplKey, FirstMoveKey, ID)
        get_sql(gsdb, usr_wg_BadFeeType/3,
        "SELECT \c
          pEmplKey AS EmplKey, pFirstMoveKey AS FirstMoveKey, id \c
        FROM USR$WG_FEETYPE \c
        WHERE id IN \c
        (SELECT id FROM gd_ruid \c
        WHERE xid IN (pBadFeeType_xid_IN) \c
        AND dbid = pBadFeeType_dbid \c
        ) \c
        ",
        [pEmplKey-_, pFirstMoveKey-_, pBadFeeType_xid_IN-_, pBadFeeType_dbid-_]
            ).
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-02-14T15:22:48+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189471_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 151189370_18175251
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_avg_wage_in_params"
      COMMENT: ~
      SCRIPT: | 
        % twg_avg_wage_in_params
        
        :- new_param_list(wg_avg_wage_vacation, in,
            [pConnection-gsdb,
            pMonthQty-12, pAvgDays-29.7,
            pFeeGroupKey_xid-147071456,
            pFeeGroupKey_dbid-274788016,
            pFeeGroupKeyNoCoef_xid-147757383,
            pFeeGroupKeyNoCoef_dbid-84733194,
            pBadHourType_xid_IN-'147650804, 147650786, 147650802',
            pBadHourType_dbid-119619099,
            pBadFeeType_xid_IN-'151000730',
            pBadFeeType_dbid-2109681374,
            pTblCal_DocType_Plan-520230604,
            pTblCal_DocType_Fact-520227080
            ]).
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-02-13T17:41:37+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189370_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_avg_wage"
      COMMENT: ~
      SCRIPT: | 
        % twg_avg_wage
        
        % среднедневной заработок
        % - для отпусков
        %
        
        :- retractall(debug_mode).
        
        % ! при использовании в ТП Гедымин
        % ! для begin & end debug mode section
        % ! убрать символ процента из первой позиции
        /* %%% begin debug mode section
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        :- [lib].
        %#INCLUDE params
        :- [params].
        %#INCLUDE twg_avg_wage_sql
        :- [twg_avg_wage_sql].
        %#INCLUDE twg_avg_wage_in_params
        %:- [twg_avg_wage_in_params].
        %%
        
        %% facts
        :-  init_data,
            [
            usr_wg_DbfSums,
            usr_wg_MovementLine,
            usr_wg_FCRate,
            usr_wg_TblDayNorm,
            usr_wg_TblYearNorm,
            usr_wg_TblCalLine,
            usr_wg_TblCal_FlexLine,
            %usr_wg_HourType,
            usr_wg_TblCharge,
            usr_wg_FeeType,
            usr_wg_FeeTypeNoCoef,
            usr_wg_BadHourType,
            usr_wg_BadFeeType
            ].
        %%
        
        %% dynamic state
        :- [param_list].
        %%
        
        %% flag
        :- assertz(debug_mode).
        %%
        
        % ! при использовании в ТП Гедымин
        % ! для begin & end debug mode section
        % ! убрать символ процента из первой позиции
        */ %%% end debug mode section
        
        :- ps32k_lgt(64, 128, 64).
        
        /* реализация */
        
        %% варианты правил расчета для отпусков
        % [по расчетным месяцам, по среднечасовому]
        wg_valid_rules([by_calc_month, by_avg_houre]).
        %% варианты правил включения месяца в расчет
        % табель за месяц покрывает график [по дням и часам, по часам, по дням]
        wg_valid_rules([by_days_houres, by_houres, by_days]).
        %% дополнительные правила для включения месяца в расчет
        % [заработок за месяц не меньше каждого из полных месяцев]
        % (для одинаковых коэфициентов осовременивания)
        wg_valid_rules([-by_month_wage_all]).
        % [заработок за месяц не меньше любого из полных месяцев]
        % (для одинаковых коэфициентов осовременивания)
        wg_valid_rules([by_month_wage_any]).
        % [отсутствие в месяце плохих типов начислений и часов]
        wg_valid_rules([-by_month_no_bad_type]).
        
        %% варианты правил полных месяцев
        % табель за месяц покрывает график [по дням и часам, по часам, по дням]
        wg_full_month_rules([by_days_houres, by_houres, by_days]).
        
        % правило действительно
        is_valid_rule(Rule) :-
            wg_valid_rules(ValidRules),
            member(Rule, ValidRules),
            !.
        
        % среднедневной заработок
        % - для отпусков
        avg_wage(Variant) :-
            % параметры контекста
            Scope = wg_avg_wage_vacation,
            % шаблон первичного ключа
            PK = [pEmplKey-_, pFirstMoveKey-_],
            % для каждого первичного ключа расчета из входных параметров
            get_param_list(Scope, in, PK),
            % запустить цикл механизма подготовки данных
            engine_loop(Scope, in, PK),
            % выполнить расчет
            eval_avg_wage(Scope, PK, Variant),
            % найти альтернативу
            fail.
        avg_wage(_) :-
            % больше альтернатив нет
            !.
        
        % выполнить расчет
        eval_avg_wage(Scope, PK, Variant) :-
            % взять локальное время
            get_local_date_time(DT1),
            % записать отладочную информацию
            new_param_list(Scope, debug, [begin-DT1|PK]),
            % удалить временные данные по расчету
            forall( get_param_list(Scope, temp, PK, Pairs),
                    dispose_param_list(Scope, temp, Pairs) ),
            % вычислить среднедневной заработок по сотруднику
            calc_avg_wage(Scope, PK, AvgWage, Variant),
            % записать результат
            ret_avg_wage(Scope, PK, AvgWage, Variant),
            % взять локальное время
            get_local_date_time(DT2),
            % записать отладочную информацию
            new_param_list(Scope, debug, [end-DT2|PK]),
            !.
        
        % записать результат
        ret_avg_wage(Scope, PK, AvgWage, Variant) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять дополнительные данные из первого движения
            get_data(Scope, in, usr_wg_MovementLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fMovementType-1, fListNumber-ListNumber]),
            % записать выходные данные
            append(PK, [pListNumber-ListNumber,
                        pAvgWage-AvgWage, pVariant-Variant],
                    OutPairs),
            new_param_list(Scope, out, OutPairs),
            !.
        
        % среднедневной заработок по сотруднику (по расчетным месяцам)
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            Rule = by_calc_month,
            % правило действительно
            is_valid_rule(Rule),
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % проверка по табелю
            check_month_tab(Scope, PK, Periods),
            % если есть хотя бы один расчетный месяц
            ( once( get_month_incl(Scope, PK, _, _, _) ),
            % то проверка по заработку
              check_month_wage(Scope, PK, Periods)
              ; true ),
            % проверка на отсутствие плохих типов начислений и часов
            check_month_no_bad_type(Scope, PK, Periods),
            % есть хотя бы один расчетный месяц
            once( get_month_incl(Scope, PK, _, _, _) ),
            % взять заработок
            findall( Wage,
                       % за каждый расчетный месяц
                     ( get_month_incl(Scope, PK, Y, M, _),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y, M, _, Wage) ),
            % в список заработков
            Wages ),
            % итоговый заработок за расчетные месяцы
            sum_list(Wages, Amount),
            % количество расчетных месяцев
            length(Wages, Num),
            % среднемесячное количество календарных дней
            get_param(Scope, in, pAvgDays-AvgDays),
            % среднедневной заработок
            catch( AvgWage0 is Amount / Num / AvgDays, _, fail),
            AvgWage is round(AvgWage0),
            !.
        % среднедневной заработок по сотруднику (по среднечасовому)
        calc_avg_wage(Scope, PK, AvgWage, Rule) :-
            Rule = by_avg_houre,
            % правило действительно
            is_valid_rule(Rule),
            % подготовка временных данных для расчета
            prep_avg_wage(Scope, PK, Periods),
            % взять заработок
            findall( Wage,
                       % за каждый период проверки
                     ( member(Y-M, Periods),
                       % взять данные по заработку
                       get_month_wage(Scope, PK, Y, M, _, Wage) ),
            % в список заработков
            Wages ),
            % итоговый заработок
            sum_list(Wages, Amount),
            % взять часы
            findall( THoures,
                     % за период проверки
                     ( member(Y-M, Periods),
                     % взять данные по часам за месяц
                     get_month_norm_tab(Scope, PK, Y-M, _, _, _, THoures)
                     ),
            % в список часов
            Durations),
            % всего часов по табелю
            sum_list(Durations, TotalTab),
            % среднечасовой заработок
            catch( AvgHoureWage is Amount / TotalTab, _, fail ),
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % всего часов по графику за расчетный год
            get_data(Scope, in, usr_wg_TblYearNorm, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fWHoures-TotalNorm]),
            % среднемесячное количество расчетных рабочих часов
            AvgMonthNorm is TotalNorm / 12,
            % среднемесячное количество календарных дней
            get_param(Scope, in, pAvgDays-AvgDays),
            % среднедневной заработок
            catch( AvgWage0 is AvgHoureWage * AvgMonthNorm / AvgDays, _, fail),
            AvgWage is round(AvgWage0),
            !.
        
        % подготовка временных данных для расчета
        prep_avg_wage(Scope, PK, Periods) :-
            % периоды для проверки
            get_periods(Scope, PK, Periods),
            % добавление временных данных по расчету дней и часов
            add_month_norm_tab(Scope, PK, Periods),
            % добавление временных данных по расчету заработков
            add_month_wage(Scope, PK, Periods),
            !.
        
        % периоды для проверки
        get_periods(Scope, PK, Periods) :-
            append(PK, [pDateCalcFrom-DateFrom, pDateCalcTo-DateTo], Pairs),
            get_param_list(Scope, run, Pairs),
            make_periods(DateFrom, DateTo, Periods),
            !.
        
        % создать список периодов
        make_periods(DateFrom, DateTo, [Y-M|Periods]) :-
            DateFrom @< DateTo,
            atom_date(DateFrom, date(Y, M, D)),
            date_add(date(Y, M, D), 1, month, DateFrom0),
            atom_date(DateFrom1, DateFrom0),
            !,
            make_periods(DateFrom1, DateTo, Periods).
        make_periods(_, _, []).
        
        % добавление временных данных по расчету дней и часов
        add_month_norm_tab(_, _, []):-
            % больше месяцев для проверки нет
            !.
        add_month_norm_tab(Scope, PK, [Y-M|Periods]) :-
            % проверить данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, _, _, _, _),
            !,
            % проверить остальные месяцы
            add_month_norm_tab(Scope, PK, Periods).
        add_month_norm_tab(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            add_month_norm_tab(Scope, PK, Periods).
        
        % добавление временных данных по расчету заработков
        add_month_wage(_, _, []):-
            % больше месяцев для проверки нет
            !.
        add_month_wage(Scope, PK, [Y-M|Periods]) :-
            % проверить данные по заработку
            get_month_wage(Scope, PK, Y, M, _, _),
            !,
            % проверить остальные месяцы
            add_month_wage(Scope, PK, Periods).
        add_month_wage(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            add_month_wage(Scope, PK, Periods).
        
        % взять данные по заработку за месяц
        get_month_wage(Scope, PK, Y, M, MonthModernCoef, ModernWage) :-
            % взять из временных параметров данные по заработку
            append(PK, [pYM-Y-M, pModernCoef-MonthModernCoef, pModernWage-ModernWage],
                    Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_wage(Scope, PK, Y, M, MonthModernCoef, ModernWage) :-
            % расчитать заработок за месяц
            cacl_month_wage(Scope, PK, Y, M, Wage, MonthModernCoef, ModernWage),
            % записать во временные параметры данные по заработку
            append(PK, [pYM-Y-M,
                        pWage-Wage, pModernCoef-MonthModernCoef, pModernWage-ModernWage],
                    Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % расчитать заработок за месяц
        cacl_month_wage(Scope, PK, Y, M, Wage, MonthModernCoef, ModernWage) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % параметры выбора начислений
            member(ChargeOption, [tbl_charge, dbf_sums]),
            % взять начисления
            findall( Debit-ModernCoef,
                  % для начисления по одному из параметров
                  % где дата совпадает с проверяемым месяцем
                  ( usr_wg_TblCharge_mix(Scope, in, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-TheDay,
                        fDebit-Debit, fFeeTypeKey-FeeTypeKey ],
                                            ChargeOption),
                  % и соответствующего типа
                  once( get_data(Scope, in, usr_wg_FeeType, [
                                    fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                    fFeeTypeKey-FeeTypeKey ]) ),
                  % с коэффициентом осовременивания
                  get_modern_coef(Scope, PK, TheDay, FeeTypeKey, ModernCoef) ),
            % в список начислений
            Debits ),
            % проверить список начислений
            \+ Debits = [],
            % всего за месяц
            sum_month_debit(Debits, Wage, ModernWage0),
            % средний за месяц коэффициент осовременивания
            catch( MonthModernCoef0 is ModernWage0 / Wage, _, fail),
            to_currency(MonthModernCoef0, MonthModernCoef, 2),
            % осовремененный заработок
            ModernWage is round(Wage * MonthModernCoef),
            !.
        
        % итого зарплата и осовремененная зарплата за месяц
        sum_month_debit(Debits, Wage, ModernWage) :-
            sum_month_debit(Debits, Wage, ModernWage, 0, 0),
            !.
        %
        sum_month_debit([], Wage, ModernWage, Wage, ModernWage) :-
            !.
        sum_month_debit([Debit-ModernCoef | Debits], Wage, ModernWage, Wage0, ModernWage0) :-
            Wage1 is Wage0 + Debit,
            ModernWage1 is ModernWage0 + Debit*ModernCoef,
            !,
            sum_month_debit(Debits, Wage, ModernWage, Wage1, ModernWage1).
        
        % коэффициент осовременивания
        get_modern_coef(Scope, PK, _, FeeTypeKey, 1.0) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % проверить тип начисления на исключение для осовременивания
            get_data(Scope, in, usr_wg_FeeTypeNoCoef, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fFeeTypeKeyNoCoef-FeeTypeKey ]),
            !.
        get_modern_coef(Scope, PK, TheDay, _, ModernCoef) :-
            % взять параметр коэфициента и дату ограничения расчета
            append(PK, [pDateCalcTo-DateTo, pCoefOption-CoefOption], Pairs),
            get_param_list(Scope, run, Pairs),
            % сформировать список движений дата-сумма
            findall( Date-Amount,
                     get_modern_coef_data(PK, Scope, Date, Amount, CoefOption, DateTo),
            Movements ),
            % вычислить коэффициент
            calc_modern_coef(TheDay, Movements, ModernCoef),
            !.
        
        % взять данные для расчета коэфициента осовременивания
        %
        get_modern_coef_data(PK, Scope, Date, FCRateSum, CoefOption, DateTo) :-
            % справочник базовых величин - тарифная ставка 1-го разряда
            nonvar(CoefOption), CoefOption = fc_fcratesum,
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные из справочника по ставке
            get_data(Scope, in, usr_wg_FCRate, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDate-Date, fFCRateSum-FCRateSum ]),
            % где дата меньше расчетной
            Date @< DateTo.
        %
        get_modern_coef_data(PK, Scope, DateBegin, Rate, CoefOption, DateTo) :-
            % движение - тарифная ставка 1-го разряда
            nonvar(CoefOption), CoefOption = ml_rate,
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные из движения по ставке
            get_data(Scope, in, usr_wg_MovementLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fRate-Rate ]),
            % где дата меньше расчетной
            DateBegin @< DateTo.
        %
        get_modern_coef_data(PK, Scope, DateBegin, MSalary, CoefOption, DateTo) :-
            % движение - оклад
            nonvar(CoefOption), CoefOption = ml_msalary,
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные из движения по окладу
            get_data(Scope, in, usr_wg_MovementLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fDateBegin-DateBegin, fMSalary-MSalary ]),
            % где дата меньше расчетной
            DateBegin @< DateTo.
        
        % вычислить коэффициент
        calc_modern_coef(_, [ _ | [] ], 1.0) :-
            % если последнее движение, то коэффициент 1
            !.
        calc_modern_coef(TheDay, [ Date1-Rate1, Date2-Rate2 | Movements ], ModernCoef) :-
            % если проверяемая дата больше или равна даты текущего движения
            TheDay @>= Date1,
            % и меньше даты следующего движения
            TheDay @< Date2,
            % то взять последнюю ставку из следующего и всех оставшихся движений
            last([Date2-Rate2 | Movements], _-RateLast),
            % и вычислить коэффициент для текущего движения
            catch( ModernCoef0 is RateLast / Rate1, _, fail),
            ( ModernCoef0 < 1.0, ModernCoef = 1.0 ; ModernCoef = ModernCoef0 ),
            !.
        calc_modern_coef(TheDay, [ _ | Movements ], ModernCoef) :-
            % проверить для остальных движений
            !,
            calc_modern_coef(TheDay, Movements, ModernCoef).
        
        % месяц работы полный
        is_full_month(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если для первого движения по типу 1 (прием на работу)
            % где дата совпадает с проверяемым месяцем
            get_data(Scope, in, usr_wg_MovementLine, [
                fEmplKey-EmplKey, fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                fMoveYear-Y, fMoveMonth-M, fDateBegin-DateBegin, fMovementType-1 ]),
            !,
            % параметры выбора графика
            member(NormOption, [tbl_cal_flex, tbl_day_norm]),
            % первый рабочий день по графику для проверяемого месяца
            once( usr_wg_TblDayNorm_mix(Scope, in, PK, Y-M, TheDay, _, 1, NormOption) ),
            !,
            % больше или равен дате первого движения
            TheDay @>= DateBegin,
            % то первый месяц работы полный
            !.
        is_full_month(_, _, _) :-
            % проверяемый месяц не является первым месяцем работы
            !.
        
        % в месяце есть отработанные часы
        is_month_worked(Scope, PK, Y-M) :-
            % если есть хотя бы один рабочий день
            usr_wg_TblCalLine_mix(Scope, in, PK, Y-M, _, DOW, HOW, _, _),
            % с контролем наличия дней или часов
            once( (DOW > 0 ; HOW > 0 ) ),
            % то в месяце есть отработанные дни или часы
            !.
        
        % в месяце есть оплата
        is_month_paid(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если есть хотя бы одно начисление
            usr_wg_TblCharge_mix(Scope, in, [
                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                fCalYear-Y, fCalMonth-M, fDebit-Debit, fFeeTypeKey-FeeTypeKey ],
                                    _),
            % с контролем суммы
            Debit > 0,
            % соответствующего типа
            once( get_data(Scope, in, usr_wg_FeeType, [
                            fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                            fFeeTypeKey-FeeTypeKey ]) ),
            % то в месяце есть оплата
            !.
        
        % взять расчетный месяц
        get_month_incl(Scope, PK, Y, M, Variant) :-
            append(PK, [pMonthIncl-MonthInclList], Pairs),
            get_param_list(Scope, temp, Pairs),
            member(Y-M-Variant, MonthInclList).
        
        % принять месяц для исчисления
        take_month_incl(Scope, PK, Y, M, Variant) :-
            append(PK, [pMonthIncl-MonthInclList], Pairs),
            get_param_list(Scope, temp, Pairs),
            keysort([Y-M-Variant | MonthInclList], MonthInclList1),
            append(PK, [pMonthIncl-MonthInclList1], Pairs1),
            dispose_param_list(Scope, temp, Pairs),
            new_param_list(Scope, temp, Pairs1),
            !.
        take_month_incl(Scope, PK, Y, M, Variant) :-
            append(PK, [pMonthIncl-[Y-M-Variant]], Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % проверка месяца по табелю
        check_month_tab(_, _, []):-
            % больше месяцев для проверки нет
            !.
        check_month_tab(Scope, PK, [Y-M|Periods]) :-
            % месяц работы полный
            is_full_month(Scope, PK, Y-M),
            % в месяце есть отработанные часы
            is_month_worked(Scope, PK, Y-M),
            % в месяце есть оплата
            is_month_paid(Scope, PK, Y-M),
            % и выполняется одно из правил
            rule_month_tab(Scope, PK, Y-M, Variant),
            % то принять месяц для исчисления
            take_month_incl(Scope, PK, Y, M, Variant),
            !,
            % проверить остальные месяцы
            check_month_tab(Scope, PK, Periods).
        check_month_tab(Scope, PK, [_|Periods]) :-
            !,
            % проверить остальные месяцы
            check_month_tab(Scope, PK, Periods).
        
        % правила включения месяца в расчет
        rule_month_tab(Scope, PK, Y-M, Rule) :-
            % по дням и часам за месяц
            Rule = by_days_houres,
            % правило действительно
            is_valid_rule(Rule),
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures),
            % если табель равен графику по дням и часам
            TDays =:= NDays, THoures =:= NHoures,
            % то месяц включается в расчет
            !.
        rule_month_tab(Scope, PK, Y-M, Rule) :-
            % по часам за месяц
            Rule = by_houres,
            % правило действительно
            is_valid_rule(Rule),
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, _, _, NHoures, THoures),
            % если табель покрывает график по часам
            THoures >= NHoures,
            % то месяц включается в расчет
            !.
        rule_month_tab(Scope, PK, Y-M, Rule) :-
            % по дням за месяц
            Rule = by_days,
            % правило действительно
            is_valid_rule(Rule),
            % взять данные по графику и табелю за месяц
            get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, _, _),
            % если табель покрывает график по дням
            TDays >= NDays,
            % то месяц включается в расчет
            !.
        
        % взять данные по графику и табелю за месяц
        get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures) :-
            % взять из временных параметров дни и часы
            append(PK, [pYM-Y-M,
                        pTDays-TDays, pTHoures-THoures,
                        pNDays-NDays, pNHoures-NHoures],
                        Pairs),
            get_param_list(Scope, temp, Pairs),
            !.
        get_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures) :-
            % расчитать график и табель за месяц
            calc_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures),
            % записать во временные параметры дни и часы
            append(PK, [pYM-Y-M,
                        pTDays-TDays, pTHoures-THoures,
                        pNDays-NDays, pNHoures-NHoures],
                        Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        
        % расчитать график и табель за месяц
        calc_month_norm_tab(Scope, PK, Y-M, NDays, TDays, NHoures, THoures) :-
            % расчитать график за месяц
            calc_month_norm(Scope, PK, Y-M, NormDays),
            % сумма дней и часов по графику
            sum_days_houres(NormDays, NDays, NHoures),
            % расчитать табель за месяц
            calc_month_tab(Scope, PK, Y-M, TabDays),
            % сумма дней и часов по табелю
            sum_days_houres(TabDays, TDays, THoures),
            !.
        
        % расчитать график за месяц по одному из параметров
        calc_month_norm(Scope, PK, Y-M, NormDays) :-
            % параметры выбора графика
            member(NormOption, [tbl_cal_flex, tbl_day_norm]),
            % взять дату/часы
            findall( TheDay-1-WDuration,
                    % для рабочего дня
                    ( usr_wg_TblDayNorm_mix(Scope, in, PK,
                        Y-M, TheDay, WDuration, 1, NormOption),
                    % с контролем наличия часов
                    WDuration > 0 ),
            % в список дата/часы графика
            NormDays),
            % проверить список графика
            \+ NormDays = [],
            !.
        
        % расчитать табель за месяц по одному из параметров
        calc_month_tab(Scope, PK, Y-M, TabDays) :-
            % параметры выбора табеля
            member(TabelOption, [tbl_cal_flex, tbl_cal, tbl_charge, dbf_sums]),
            % взять данные табеля
            findall( Date-DOW-HOW,
                    % для проверяемого месяца
                    ( usr_wg_TblCalLine_mix(Scope, in, PK, Y-M, Date, DOW, HOW, _, TabelOption),
                    % с контролем наличия дней или часов
                    once( (DOW > 0 ; HOW > 0 ) )
                    ),
            % в список дата-день-часы
            TabDays),
            % проверить список табеля
            \+ TabDays = [],
            !.
        
        % сумма дней и часов
        sum_days_houres(ListDays, Days, Houres) :-
            sum_days_houres(ListDays, Days, Houres, 0, 0),
            !.
        %
        sum_days_houres([], Days, Houres, Days, Houres).
        sum_days_houres([_-DOW-HOW|ListDays], Days, Houres, Days0, Houres0) :-
            Days1 is Days0 + DOW,
            Houres1 is Houres0 + HOW,
            !,
            sum_days_houres(ListDays, Days, Houres, Days1, Houres1).
        
        % проверка месяца по заработку
        check_month_wage(_, _, []):-
            % больше месяцев для проверки нет
            !.
        check_month_wage(Scope, PK, [Y-M|Periods]) :-
            % если месяц еще не включен в расчет
            \+ get_month_incl(Scope, PK, Y, M, _),
            % и выполняется одно из правил
            rule_month_wage(Scope, PK, Y-M, Variant),
            % то принять месяц для исчисления
            take_month_incl(Scope, PK, Y, M, Variant),
            !,
            % проверить следующий месяц
            check_month_wage(Scope, PK, Periods).
        check_month_wage(Scope, PK, [_|Periods]) :-
            !,
            % проверить следующий месяц
            check_month_wage(Scope, PK, Periods).
        
        % заработок за месяц выше или на уровне каждого из полных месяцев
        rule_month_wage(Scope, PK, Y-M, Rule) :-
            Rule = by_month_wage_all,
            % правило действительно
            is_valid_rule(Rule),
            % варианты правил полных месяцев
            wg_full_month_rules(FullMonthRules),
            % взять заработок и коэффициент осовременивания за проверяемый месяц
            get_month_wage(Scope, PK, Y, M, ModernCoef, Wage),
            % взять заработок
            findall( Wage1,
                      % для расчетного месяца
                    ( get_month_incl(Scope, PK, Y1, M1, Variant1),
                      % который принят для исчисления по варианту полного месяца
                      once( member(Variant1, FullMonthRules) ),
                      % с заработком и коэффициентом осовременивания за месяц
                      get_month_wage(Scope, PK, Y1, M1, ModernCoef1, Wage1),
                      % где коэффициенты для проверяемого и расчетного равны
                      ModernCoef =:= ModernCoef1 ),
            % в список заработков
            Wages1 ),
            % если заработок проверяемого месяца покрывает все из расчетных
            wage_over_list(Wage, Wages1),
            % то месяц включается в расчет
            !.
        % заработок за месяц больше или равен любого из полных месяцев
        rule_month_wage(Scope, PK, Y-M, Rule) :-
            Rule = by_month_wage_any,
            % правило действительно
            is_valid_rule(Rule),
            % варианты правил полных месяцев
            wg_full_month_rules(FullMonthRules),
            % взять заработок и коэффициент осовременивания за проверяемый месяц
            get_month_wage(Scope, PK, Y, M, ModernCoef, Wage),
            % взять заработок
            findall( Wage1,
                      % для расчетного месяца
                    ( get_month_incl(Scope, PK, Y1, M1, Variant1),
                      % который принят для исчисления по варианту полного месяца
                      once( member(Variant1, FullMonthRules) ),
                      % с заработком и коэффициентом осовременивания за месяц
                      get_month_wage(Scope, PK, Y1, M1, ModernCoef1, Wage1),
                      % где коэффициенты для проверяемого и расчетного равны
                      ModernCoef =:= ModernCoef1 ),
            % в список заработков
            Wages1 ),
            % если заработок проверяемого месяца покрывает любой из расчетных
            wage_over_any(Wage, Wages1),
            % то месяц включается в расчет
            !.
        
        % заработок покрывает все значения из списка
        wage_over_list(Over, [Head|[]]) :-
            Over >= Head,
            !.
        wage_over_list(Over, [Head|Tail]) :-
            Over >= Head,
            !,
            wage_over_list(Over, Tail).
        
        % заработок покрывает любое значение из списка
        wage_over_any(Over, [Head|_]) :-
            Over >= Head,
            !.
        wage_over_any(Over, [_|Tail]) :-
            !,
            wage_over_any(Over, Tail).
        
        % проверка месяца по типу начислений и типу часов
        check_month_no_bad_type(_, _, []):-
            % больше месяцев для проверки нет
            !.
        check_month_no_bad_type(Scope, PK, [Y-M|Periods]) :-
            % если месяц еще не включен в расчет
            \+ get_month_incl(Scope, PK, Y, M, _),
            % месяц работы полный
            is_full_month(Scope, PK, Y-M),
            % в месяце есть оплата
            is_month_paid(Scope, PK, Y-M),
            % и выполняется одно из правил
            rule_month_no_bad_type(Scope, PK, Y-M, Variant),
            % то принять месяц для исчисления
            take_month_incl(Scope, PK, Y, M, Variant),
            !,
            % проверить следующий месяц
            check_month_no_bad_type(Scope, PK, Periods).
        check_month_no_bad_type(Scope, PK, [_|Periods]) :-
            !,
            % проверить следующий месяц
            check_month_no_bad_type(Scope, PK, Periods).
        
        % отсутствие плохих типов начислений и часов
        rule_month_no_bad_type(Scope, PK, Y-M, Rule) :-
            Rule = by_month_no_bad_type,
            % правило действительно
            is_valid_rule(Rule),
            % если нет плохих типов начислений и часов
            \+ month_bad_type(Scope, PK, Y-M),
            % то месяц включается в расчет
            !.
        
        % есть плохой тип часов
        month_bad_type(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если есть хотя бы один день по табелю
            usr_wg_TblCalLine_mix(Scope, in, PK, Y-M, _, _, _, HoureType, _),
            % с плохим типом часов
            nonvar(HoureType),
            HoureType > 0,
            once( get_data(Scope, in, usr_wg_BadHourType, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey, fID-HoureType]) ),
            !.
        % есть плохой тип начислений
        month_bad_type(Scope, PK, Y-M) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % если есть хотя бы одно начисление
            % где дата совпадает с проверяемым месяцем
            usr_wg_TblCharge_mix(Scope, in, [
                fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                fCalYear-Y, fCalMonth-M, fFeeTypeKey-FeeTypeKey ],
                                    _),
            % с плохим типом начисления
            nonvar(FeeTypeKey),
            FeeTypeKey > 0,
            once( get_data(Scope, in, usr_wg_BadFeeType, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey, fID-FeeTypeKey]) ),
            !.
        
        %% взять данные по начислению
        % начисление из TblCharge
        usr_wg_TblCharge_mix(Scope, Type, ArgPairs, ChargeOption) :-
            ChargeOption = tbl_charge,
            get_data(Scope, Type, usr_wg_TblCharge, ArgPairs).
        % или начисление из dbf
        usr_wg_TblCharge_mix(Scope, Type, ArgPairs, ChargeOption) :-
            ChargeOption = dbf_sums,
            ValuePairs = [
                        fEmplKey-EmplKey, fFirstMoveKey-_,
                        fCalYear-CalYear, fCalMonth-CalMonth, fDateBegin-DateBegin,
                        fDebit-Debit, fFeeTypeKey-_
                        ],
            member_list(ArgPairs, ValuePairs),
            gd_pl_ds(Scope, Type, usr_wg_DbfSums, 6, _),
            catch( usr_wg_DbfSums(EmplKey, Debit, _, CalYear, CalMonth, DateBegin), _, fail).
        
        %% взять данные по графику
        % день месяца по календарному графику
        usr_wg_TblDayNorm_mix(Scope, Type, PK, Y-M, Date, Duration, WorkDay, NormOption) :-
            NormOption = tbl_cal_flex,
            get_Flex_by_type(Scope, Type, PK, Y-M, Date, WorkDay, Duration, _, "plan").
        % или день месяца по справочнику графика рабочего времени
        usr_wg_TblDayNorm_mix(Scope, Type, PK, Y-M, TheDay, WDuration, WorkDay, NormOption) :-
            NormOption = tbl_day_norm,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_data(Scope, Type, usr_wg_TblDayNorm, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fWYear-Y, fWMonth-M, fTheDay-TheDay,
                        fWDuration-WDuration, fWorkDay-WorkDay ]).
        
        %% взять данные по табелю
        % день месяца по табелю мастера
        usr_wg_TblCalLine_mix(Scope, Type, PK, Y-M, Date, Days, Duration, HoureType, TabelOption) :-
            TabelOption = tbl_cal_flex,
            get_Flex_by_type(Scope, Type, PK, Y-M, Date, Days, Duration, HoureType, "fact").
        % или день месяца по табелю
        usr_wg_TblCalLine_mix(Scope, Type, PK, Y-M, Date, Days, Duration, HoureType, TabelOption) :-
            TabelOption = tbl_cal,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_data(Scope, Type, usr_wg_TblCalLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDate-Date,
                        fDuration-Duration, fHoureType-HoureType]),
            once( (Duration > 0, Days = 1 ; Days = 0) ).
        % или табель дни-часы из начислений
        usr_wg_TblCalLine_mix(Scope, Type, PK, Y-M, Date, DOW, HOW, 0, TabelOption) :-
            TabelOption = tbl_charge,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            ArgPairs = [fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-Date,
                        fFeeTypeKey-FeeTypeKey, fDOW-DOW, fHOW-HOW],
            get_data(Scope, Type, usr_wg_TblCharge, ArgPairs),
            once( get_data(Scope, Type, usr_wg_FeeType, [
                            fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                            fFeeTypeKey-FeeTypeKey, fAvgDayHOW-1]) ).
        % или день месяца из dbf
        usr_wg_TblCalLine_mix(Scope, Type, PK, Y-M, Date, Days, InHoures, 0, TabelOption) :-
            TabelOption = dbf_sums,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_data(Scope, Type, usr_wg_DbfSums, [
                        fEmplKey-EmplKey, fInHoures-InHoures,
                        fInYear-Y, fInMonth-M, fDateBegin-Date]),
            once( (InHoures > 0, Days = 1 ; Days = 0) ).
        
        % день месяца по календарному графику или табелю мастера
        % FlexType: "plan" ; "fact"
        get_Flex_by_type(Scope, Type, PK, Y-M, Date, Days, Duration, HoureType, FlexType) :-
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            gd_pl_ds(Scope, Type, usr_wg_TblCal_FlexLine, 68, _),
            make_list(62, TeilArgs),
            Term =..[ usr_wg_TblCal_FlexLine, FlexType, EmplKey, FirstMoveKey, Y, M, _ | TeilArgs ],
            catch( call( Term ), _, fail),
            member(D, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]),
            atom_date(Date, date(Y, M, D)),
            S is (D - 1) * 2 + 6,
            H is S + 1,
            arg(S, Term, Duration0),
            once( ( number(Duration0), Duration = Duration0
                    ; atom_number(Duration0, Duration)
                    ; Duration is 0 ) ),
            arg(H, Term, HoureType0),
            once( ( number(HoureType0), HoureType = HoureType0
                    ; atom_number(HoureType0, HoureType)
                    ; HoureType is 0 ) ),
            once( (Duration > 0, Days = 1 ; Days = 0) ).
        
        %% engine_loop(+Scope, +Type, +PK)
        %
        
        % args handler
        engine_loop(Scope, Type, PK) :-
            \+ ground([Scope, Type, PK]),
            !,
            fail.
        % fail handler
        engine_loop(Scope, _, PK) :-
            engine_fail_step(Type),
            get_param_list(Scope, Type, PK),
            !,
            fail.
        % deal handler
        engine_loop(Scope, Type, PK) :-
            engine_deal_step(Type),
            !,
            get_param_list(Scope, Type, PK),
            !.
        % data handler
        engine_loop(Scope, Type, PK) :-
            engine_data_step(Type, TypeNextStep),
            get_param_list(Scope, Type, PK),
            \+ get_param_list(Scope, TypeNextStep, PK),
            prepare_data(Scope, Type, PK, TypeNextStep),
            !,
            engine_loop(Scope, TypeNextStep, PK).
        engine_loop(Scope, Type, PK) :-
            engine_data_step(Type, TypeNextStep),
            !,
            engine_loop(Scope, TypeNextStep, PK).
        % restart handler
        engine_loop(Scope, Type, PK) :-
            engine_restart_step(Type, TypeNextStep),
            forall( ( get_param_list(Scope, ParamType, PK, Pairs),
                      \+ ParamType = TypeNextStep ),
                    dispose_param_list(Scope, ParamType, Pairs)
                  ),
            !,
            engine_loop(Scope, TypeNextStep, PK).
        % clean handler
        engine_loop(Scope, Type, PK) :-
            engine_clean_step(Type, CleanType, NextType),
            forall( ( get_param_list(Scope, ParamType, PK, Pairs),
                      ParamType = CleanType ),
                    dispose_param_list(Scope, ParamType, Pairs)
                  ),
            once( find_param(Scope, NextType, PK, pConnection-Connection) ),
            forall( ( get_sql(Connection, Query/Arity, _, _),
                      current_functor(Query, Arity),
                      is_valid_sql(Query/Arity) ),
                    ( length(PK, Len),
                      Arity1 is Arity - Len,
                      make_list(Arity1, TeilArgs),
                      PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
                      append([EmplKey, FirstMoveKey], TeilArgs, Args),
                      Term =.. [Query | Args ],
                      retractall( Term ) )
                    ),
            !.
        % error handler
        engine_loop(Scope, Type, PK) :-
            engine_error_step(TypeNextStep),
            \+ get_param_list(Scope, TypeNextStep, PK),
            get_local_date_time(DT),
            append(PK, [Type, DT], PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            !,
            fail.
        
        %
        engine_data_step(in, run).
        engine_data_step(run, query).
        engine_data_step(query, data).
        %
        engine_deal_step(run) :-
            debug_mode,
            !.
        engine_deal_step(data).
        %
        engine_fail_step(out).
        engine_fail_step(error).
        %
        engine_restart_step(restart, in).
        %
        engine_clean_step(clean, data, query).
        %
        engine_error_step(error).
        
         %
        %%
        
        %% prepare_data(+Scope, +Type, +PK, +TypeNextStep)
        % wg_avg_wage_vacation-in-run
        prepare_data(Scope, Type, PK, TypeNextStep) :-
            Scope = wg_avg_wage_vacation, Type = in, TypeNextStep = run,
            get_param_list(Scope, Type,
                    [pConnection-_, pMonthQty-MonthQty], ConnectionPairs),
            get_param_list(Scope, Type, PK, Pairs),
            member_list([pDateCalc-DateCalc, pMonthOffset-MonthOffset], Pairs),
            %
            atom_date(DateCalc, date(Y0, M0, _)),
            atom_date(DateCalcTo0, date(Y0, M0, 1)),
            MonthOffset1 is (- MonthOffset),
            date_add(DateCalcTo0, MonthOffset1, month, DateCalcTo),
            MonthAdd is (- MonthQty),
            date_add(DateCalcTo, MonthAdd, month, DateCalcFrom),
            date_add(DateCalcTo, -1, day, DateCalcTo1),
            atom_date(DateCalcTo1, date(Y, _, _)),
            atom_date(DateNormFrom, date(Y, 1, 1)),
            Y1 is Y + 1,
            atom_date(DateNormTo, date(Y1, 1, 1)),
            %
            append(Pairs,
                    [pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo,
                    pDateNormFrom-DateNormFrom, pDateNormTo-DateNormTo
                    |ConnectionPairs],
                PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            !.
        % wg_avg_wage_vacation-run-query
        prepare_data(Scope, Type, PK, TypeNextStep) :-
            Scope = wg_avg_wage_vacation, Type = run, TypeNextStep = query,
            get_param_list(Scope, Type, PK, Pairs),
            member(pConnection-Connection, Pairs),
            forall( ( get_sql(Connection, Query, SQL, Params),
                      is_valid_sql(Query),
                      member_list(Params, Pairs),
                      prepare_sql(SQL, Params, PrepSQL),
                      \+ find_param_list(Scope, TypeNextStep, PK,
                            [pConnection-Connection, pQuery-Query, pSQL-PrepSQL])
                    ),
                    ( append(PK,
                        [pConnection-Connection, pQuery-Query, pSQL-PrepSQL],
                        PairsNextStep),
                      new_param_list(Scope, TypeNextStep, PairsNextStep)
                    )
                  ),
            !.
        %%
        
        %% расширение для клиента
        %
        
        % загрузка общих входных параметров
        avg_wage_in_public(Connection,
                            MonthQty, AvgDays,
                            FeeGroupKey_xid, FeeGroupKey_dbid,
                            FeeGroupKeyNoCoef_xid, FeeGroupKeyNoCoef_dbid,
                            BadHourType_xid_IN, BadHourType_dbid,
                            BadFeeType_xid_IN, BadFeeType_dbid) :-
            Scope = wg_avg_wage_vacation, Type = in,
            new_param_list(Scope, Type, [
                            pConnection-Connection,
                            pMonthQty-MonthQty, pAvgDays-AvgDays,
                            pFeeGroupKey_xid-FeeGroupKey_xid,
                            pFeeGroupKey_dbid-FeeGroupKey_dbid,
                            pFeeGroupKeyNoCoef_xid-FeeGroupKeyNoCoef_xid,
                            pFeeGroupKeyNoCoef_dbid-FeeGroupKeyNoCoef_dbid,
                            pBadHourType_xid_IN-BadHourType_xid_IN,
                            pBadHourType_dbid-BadHourType_dbid,
                            pBadFeeType_xid_IN-BadFeeType_xid_IN,
                            pBadFeeType_dbid-BadFeeType_dbid]),
            !.
        
        % загрузка входных данных по сотруднику
        % CoefOption: fc_fcratesum ; ml_rate ; ml_msalary
        avg_wage_in(EmplKey, FirstMoveKey, DateCalc, MonthOffset, CoefOption) :-
            Scope = wg_avg_wage_vacation, Type = in,
            new_param_list(Scope, Type,
                [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey,
                 pDateCalc-DateCalc, pMonthOffset-MonthOffset,
                 pCoefOption-CoefOption]),
            !.
        
        % выгрузка данных выполнения по сотруднику
        avg_wage_run(EmplKey, FirstMoveKey, DateCalcFrom, DateCalcTo) :-
            Scope = wg_avg_wage_vacation, Type = run,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            append(PK, [pDateCalcFrom-DateCalcFrom, pDateCalcTo-DateCalcTo], Pairs),
            get_param_list(Scope, Type, Pairs).
        
        % выгрузка SQL-запросов по сотруднику
        avg_wage_sql(EmplKey, FirstMoveKey, Connection, PredicateName, Arity, SQL) :-
            Scope = wg_avg_wage_vacation, Type = query, TypeNextStep = data,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            Query = PredicateName/Arity,
            find_param_list(Scope, Type, PK,
                    [pConnection-Connection, pQuery-Query, pSQL-SQL]),
            \+ find_param_list(Scope, TypeNextStep, PK,
                    [pConnection-Connection, pQuery-Query, pSQL-SQL]).
        
        % подтвеждение формирования фактов по сотруднику
        avg_wage_kb(EmplKey, FirstMoveKey, Connection, PredicateName, Arity, SQL) :-
            Scope = wg_avg_wage_vacation, Type = query, TypeNextStep = data,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            Query = PredicateName/Arity,
            find_param_list(Scope, Type, PK,
                    [pConnection-Connection, pQuery-Query, pSQL-SQL]),
            \+ find_param_list(Scope, TypeNextStep, PK,
                    [pConnection-Connection, pQuery-Query, pSQL-SQL]),
            append(PK,
                    [pConnection-Connection, pQuery-Query, pSQL-SQL],
                    PairsNextStep),
            new_param_list(Scope, TypeNextStep, PairsNextStep),
            !.
        
        % выгрузка выходных данных по сотруднику
        avg_wage_out(EmplKey, FirstMoveKey, AvgWage, Variant) :-
            % параметры контекста
            Scope = wg_avg_wage_vacation, Type = out,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные по результатам расчета
            append(PK, [pAvgWage-AvgWage, pVariant-Variant], Pairs),
            get_param_list(Scope, Type, Pairs).
        
        % выгрузка детальных выходных данных по сотруднику
        avg_wage_det(EmplKey, FirstMoveKey,
                        Period, Rule, Wage, ModernCoef, ModernWage,
                        TabDays, NormDays, TabHoures, NormHoures) :-
            % параметры контекста
            Scope = wg_avg_wage_vacation, Type = temp,
            % шаблон первичного ключа
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % для каждого периода
            % взять данные по табелю и графику
            append(PK, [pYM-Y-M,
                            pTDays-TabDays, pTHoures-TabHoures,
                            pNDays-NormDays, pNHoures-NormHoures],
                    Pairs),
            get_param_list(Scope, Type, Pairs),
            % если для первого движения по типу 1 (прием на работу)
            % дата совпадает с проверяемым месяцем, то период есть дата начала работы
            once( (
                get_data(Scope, in, usr_wg_MovementLine, [
                fEmplKey-EmplKey, fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                fMoveYear-Y, fMoveMonth-M, fDateBegin-Period, fMovementType-1 ])
                ;
            % иначе сформировать дату периода, как первый день месяца
                atom_date(Period, date(Y, M, 1))
                ) ),
            % взять данные по правилам расчета
            append(PK, [pMonthIncl-MonthIncl], Pairs1),
            once( ( get_param_list(Scope, Type, Pairs1) ; MonthIncl = [] ) ),
            once( ( member(Y-M-Rule, MonthIncl) ; Rule = none ) ),
            % взять данные по заработку
            once( ( ( append(PK, [pYM-Y-M,
                                    pWage-Wage, pModernCoef-ModernCoef,
                                    pModernWage-ModernWage],
                                Pairs2),
                      get_param_list(Scope, Type, Pairs2) )
                      ; [Wage, ModernCoef, ModernWage] = [0, 1, 0] ) ),
            %
            % есть отработанные часы или заработок
            once( ( TabHoures > 0 ; ModernWage > 0 ) ).
        
        % удаление данных по сотруднику
        avg_wage_clean(EmplKey, FirstMoveKey) :-
            Scope = wg_avg_wage_vacation,
            get_type_list(TypeList),
            member(Type, TypeList),
            gd_pl_ds(Scope, Type, Name, _, _),
            del_data(Scope, Type, Name, [fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey]),
            fail.
        avg_wage_clean(EmplKey, FirstMoveKey) :-
            Scope = wg_avg_wage_vacation,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_param_list(Scope, Type, PK, Pairs),
            dispose_param_list(Scope, Type, Pairs),
            fail.
        avg_wage_clean(_, _) :-
            !.
        
         %
        %%
        
        /**/
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-03T12:40:44+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "151189470_18175251 twg_avg_wage_sql"
          - 
            ADDFUNCTIONKEY: "151189471_18175251 twg_avg_wage_in_params"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 156300302_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
      HeadObject: 156300135_119200397
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_struct_sql"
      COMMENT: ~
      SCRIPT: | 
        % twg_struct_sql
        
        :-
            GetSQL = [gd_pl_ds/5, get_sql/4],
            dynamic(GetSQL),
            multifile(GetSQL),
            discontiguous(GetSQL).
        
        %
        wg_valid_sql([wg_holiday/1]).
        
        %
        is_valid_sql(Functor/Arity) :-
            wg_valid_sql(ValidSQL),
            member(Functor/Arity, ValidSQL),
            !.
        
        gd_pl_ds(wg_struct_vacation, in, wg_holiday, 1, [fHolidayDate-date]).
        % wg_holiday(HolidayDate)
        get_sql(gsdb, wg_holiday/1,
        "SELECT \c
          h.holidaydate \c
        FROM \c
          wg_holiday h \c
        WHERE \c
          h.holidaydate BETWEEN \'pDateBegin\' AND \'pDateEnd\' \c
          AND COALESCE(h.disabled, 0) = 0 \c
        ",
        [pDateBegin-_, pDateEnd-_]
            ).
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-03T11:17:21+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 156300135_119200397
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "twg_struct"
      COMMENT: ~
      SCRIPT: | 
        % twg_struct
        
        % расчет структуры
        % - для отпусков
        %
        
        :- retractall(debug_mode).
        
        % ! при использовании в ТП Гедымин
        % ! для begin & end debug mode section
        % ! убрать символ процента из первой позиции
        /* %%% begin debug mode section
        
        %% saved state
        :- ['../gd_pl_state/load_atom', '../gd_pl_state/date', '../gd_pl_state/dataset'].
        %%
        
        %% include
        %#INCLUDE lib
        :- [lib].
        %#INCLUDE params
        :- [params].
        %%
        %#INCLUDE twg_struct_sql
        :- [twg_struct_sql].
        
        %% facts
        :-  init_data,
            [wg_holiday].
        %%
        %% dynamic state
        %:- [param_list].
        %%
        
        %% flag
        :- assertz(debug_mode).
        %%
        
        % ! при использовании в ТП Гедымин
        % ! для begin & end debug mode section
        % ! убрать символ процента из первой позиции
        */ %%% end debug mode section
        
        :- ps32k_lgt(64, 128, 64).
        
        /* реализация */
        
        struct_vacation_sql(DateBegin, DateEnd, Connection, PredicateName, Arity, SQL) :-
            Connection = gsdb,
            Pairs = [pDateBegin-DateBegin, pDateEnd-DateEnd],
            get_sql(Connection, Query, SQL0, Params),
            is_valid_sql(Query),
            Query = PredicateName/Arity,
            member_list(Params, Pairs),
            prepare_sql(SQL0, Params, SQL).
        
        struct_vacation_in(DateCalc, DateBegin, DateEnd, AvgWage) :-
            atom_date(DateCalc, date(Year, Month, _)),
            month_days(Year, Month, Days),
            atom_date(AccDate, date(Year, Month, Days)),
            struct_vacation_calc(AccDate, DateBegin, DateEnd, AvgWage),
            !.
        
        struct_vacation_calc(_, '', '', _) :-
            !.
        struct_vacation_calc(AccDate, DateBegin, DateEnd, AvgWage) :-
            make_period(DateBegin, DateEnd, DateBegin1, DateEnd1, DateBegin2, DateEnd2),
            atom_date(DateBegin1, date(Y, M, _)),
            atom_date(IncludeDate, date(Y, M, 1)),
            vacation_days(DateBegin1, DateEnd1, 1, Duration),
            Summa is Duration * AvgWage,
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pDuration-Duration, pSumma-Summa,
                        pDateBegin-DateBegin1, pDateEnd-DateEnd1
                        ],
            new_param_list(struct_vacation, out, OutPairs),
            !,
            struct_vacation_calc(AccDate, DateBegin2, DateEnd2, AvgWage).
        
        make_period(DateBegin, DateEnd, DateBegin, DateEnd1, DateBegin2, DateEnd2) :-
            head_period(DateBegin, DateEnd, DateEnd1),
            teil_period(DateEnd, DateEnd1, DateBegin2, DateEnd2),
            !.
        
        head_period(DateBegin, DateEnd, DateBegin) :-
           date_add(DateBegin, 1, day, DateBegin1),
           atom_date(DateBegin, date(Y, M, _)),
           ( \+ atom_date(DateBegin1, date(Y, M, _))
           ; DateBegin1 @> DateEnd ),
           !.
        head_period(DateBegin, DateEnd, DateEnd1) :-
           date_add(DateBegin, 1, day, DateBegin1),
           !,
           head_period(DateBegin1, DateEnd, DateEnd1).
        
        teil_period(DateEnd, DateEnd, '', '') :-
            !.
        teil_period(DateEnd, DateEnd1, DateBegin2, DateEnd) :-
            date_add(DateEnd1, 1, day, DateBegin2),
            !.
        
        vacation_days(DateBegin, DateBegin, Duration, Duration) :-
            !.
        vacation_days(DateBegin, DateEnd, Duration0, Duration) :-
            date_add(DateBegin, 1, day, DateBegin1),
            ( catch( wg_holiday(DateBegin), _, fail), Duration1 is Duration0
            ; Duration1 is Duration0 + 1 ),
            !,
            vacation_days(DateBegin1, DateEnd, Duration1, Duration).
        
        struct_vacation_out(AccDate, IncludeDate, Duration, Summa, DateBegin, DateEnd) :-
            OutPairs = [
                        pAccDate-AccDate, pIncludeDate-IncludeDate,
                        pDuration-Duration, pSumma-Summa,
                        pDateBegin-DateBegin, pDateEnd-DateEnd
                        ],
            get_param_list(struct_vacation, out, OutPairs).
        
        /**/
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-03T11:52:40+03:00
    Set: 
      - 
        Table: "RP_ADDITIONALFUNCTION"
        Items: 
          - 
            ADDFUNCTIONKEY: "151189469_18175251 lib"
          - 
            ADDFUNCTIONKEY: "151189468_18175251 params"
          - 
            ADDFUNCTIONKEY: "156300302_119200397 twg_struct_sql"
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151158415_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "CONST"
      LANGUAGE: "VBScript"
      NAME: "pl_Const"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        'Константы и переменные Prolog
        
        Public Const scrPrologModuleName = "PROLOG"
        
        'TERM-TYPE CONSTANTS
        Public Const PL_VARIABLE = 1
        Public Const PL_ATOM = 2
        Public Const PL_INTEGER = 3
        Public Const PL_FLOAT = 4
        Public Const PL_STRING = 5
        Public Const PL_TERM = 6
        '
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2013-10-11T12:23:43+03:00