%YAML 1.1
--- 
StructureVersion: "1.0"
Properties: 
  RUID: 151049506_187967073
  Name: "GS.Зарплата.Пролог.Общие"
  Caption: "Общие"
  Version: "1.0.0.1"
  Optional: False
  Internal: True
Objects: 
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151158415_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "CONST"
      LANGUAGE: "VBScript"
      NAME: "pl_Const"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        'Константы и переменные Prolog
        
        Public Const scrPrologModuleName = "PROLOG"
        
        'TERM-TYPE CONSTANTS
        Public Const PL_VARIABLE = 1
        Public Const PL_ATOM = 2
        Public Const PL_INTEGER = 3
        Public Const PL_FLOAT = 4
        Public Const PL_STRING = 5
        Public Const PL_TERM = 6
        '
        
        'for Function wg_Prolog
        Public wg_Prolog_
        Set wg_Prolog_ = Nothing
        '
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-26T12:01:03+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151158419_5956463
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "pl_GetScriptIDByName"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        
        'uses pl_Const
        Function pl_GetScriptIDByName(Name)
          Dim Creator, ibsql
        
          pl_GetScriptIDByName = 0
        
          Set Creator = New TCreator
          Set ibsql = Creator.GetObject(nil, "TIBSQL", "")
        
          ibsql.Transaction = gdcBaseManager.ReadTransaction
          ibsql.SQL.TEXT = _
              "SELECT * FROM gd_function" & _
              " WHERE UPPER(name) = UPPER(:name) AND module = :module"
          ibsql.ParamByName("name").AsString = Name
          ibsql.ParamByName("module").AsString = scrPrologModuleName
          ibsql.ExecQuery
        
          If Not ibsql.EOF Then
             pl_GetScriptIDByName = ibsql.FieldByName("id").AsInteger
          End If
        End Function
        
      DISPLAYSCRIPT: | 
        PL_GETSCRIPTIDBYNAME
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: !!binary > 
        U0xQUlBSU1QEAAAATkFNRQQAAABOQU1FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEZOU1RGTFBS
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2013-10-11T16:45:28+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 528612033_99701464
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "VBCLASSES"
      LANGUAGE: "VBScript"
      NAME: "Twg_Prolog"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        
        Class Twg_Prolog
        '
          Private VarSyncField
          
          Private Sub Class_Initialize
            VarSyncField = "PrologSyncField"
          End Sub
        
          Private Sub Class_Terminate
            Set wg_Prolog_ = Nothing
          End Sub
          
          Public Sub SyncField(ByRef Sender, ByVal Allow)
            If Not Sender.VariableExists(VarSyncField) Then
              Sender.AddVariableItem(VarSyncField)
              Sender.Variables(VarSyncField) = False
            End If
            '
            Sender.Variables(VarSyncField) = Allow
          End Sub
          
          Public Function SyncField_Name(ByRef Sender, ByVal FieldName)
            If Not Sender.VariableExists(VarSyncField) Then
              Sender.AddVariableItem(VarSyncField)
              Sender.Variables(VarSyncField) = False
            End If
            '
            If Sender.Variables(VarSyncField) = True Then
              SyncField_Name = ""
            Else
              SyncField_Name = FieldName
            End If
          End Function
        '
        End Class
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-26T13:36:06+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 528612032_99701464
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "UNKNOWN"
      LANGUAGE: "VBScript"
      NAME: "wg_Prolog"
      COMMENT: ~
      SCRIPT: | 
        Option Explicit
        
        Function wg_Prolog
          If Not Assigned(wg_Prolog_) Then
            Set wg_Prolog_ = New Twg_Prolog
          end if
        
          Set wg_Prolog = wg_Prolog_
        End Function
        
      DISPLAYSCRIPT: | 
        WG_PROLOG
        
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-03-26T11:57:22+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189469_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "lib"
      COMMENT: ~
      SCRIPT: | 
        % lib
        
        %:- ['../gd_pl_state/date'].
        
        % get_local_stamp(-Stamp)
        get_local_stamp(Stamp) :-
            get_local_date_time(DateTime),
            get_time(TimeStamp),
            Fract is round(float_fractional_part(TimeStamp) * 1000) // 1,
            atomic_list_concat([DateTime, '.', Fract], Stamp),
            !.
        
        % день недели
        weekday(date(Year, Month, Day), WeekDay) :-
            A is (14 - Month) // 12,
            Y is Year - A,
            M is Month + 12 * A - 2,
            WeekDay0 is (7000 + (Day + Y + Y // 4 - Y // 100 + Y // 400 + (31 * M) // 12)) mod 7,
            WeekDay is WeekDay0 + 1,
            !.
        weekday(Date, WeekDay) :-
            atom_date(Date, date(Year, Month, Day)),
            weekday(date(Year, Month, Day), WeekDay),
            !.
        
        % подготовка SQL-строки
        prepare_sql(InSQL, [], InSQL) :-
            !.
        prepare_sql(InSQL,[Key-Value|Pairs], OutSQL) :-
            replace_all(InSQL, Key, Value, InSQL1),
            !,
            prepare_sql(InSQL1, Pairs, OutSQL).
        
        % to_currency(+NumIn, -NumOut)
        to_currency(NumIn, NumOut) :-
            to_currency(NumIn, NumOut, 4),
            !.
        % to_currency(+NumIn, -NumOut, +Round)
        to_currency(NumIn, NumOut, Round) :-
            number(NumIn), integer(Round),
            NumOut is float( round( NumIn * (10 ** Round) ) / (10 ** Round) ),
            !.
        
        % round_sum(+SumIn, +SumOut, +RoundType, +RoundValue)
        round_sum(SumIn, SumOut, RoundType, RoundValue) :-
            number(SumIn), integer(RoundType), number(RoundValue),
            Delta = 0.00001,
            round_sum(SumIn, SumOut, RoundType, RoundValue, Delta),
            !.
        % round_sum(+SumIn, +SumOut, +RoundType, +RoundValue, +Delta)
        round_sum(SumIn, SumOut, 1, _, Delta) :-
            SumOut is round((SumIn + Delta) / 10) * 10,
            !.
        round_sum(SumIn, SumOut, 2, RoundValue, Delta) :-
            SumOut is round((SumIn + Delta) / RoundValue) * RoundValue,
            !.
        round_sum(SumIn, SumOut, 3, RoundValue, Delta) :-
            SumOut is float_integer_part((SumIn + Delta) / RoundValue) * RoundValue,
            !.
        round_sum(Sum, Sum, _, _, _) :-
            !.
        
        % make_list(+Num, -List)
        make_list(Num, List) :-
            integer(Num),
            make_list(Num, List, 0),
            !.
        
        make_list(Num, [], Num) :-
            !.
        make_list(Num, [_|Tail], Zero) :-
            Num1 is Num - 1,
            !,
            make_list(Num1, Tail, Zero).
        
        
        % exist_in(+Search, +In)
        exist_in(Search, In) :-
            text_list([Search, In], [SearchCodes, InCodes]),
            append(_, MiddleCodes, InCodes),
            append(SearchCodes, _, MiddleCodes),
            !.
        
        % replace_all(+In, +Search, +Replace, -Out)
        replace_all(In, Search, Replace, Out) :-
            replace(In, Search, Replace, In1),
            \+ In = In1,
            !,
            replace_all(In1, Search, Replace, Out).
        replace_all(In, _, _, In).
        
        % replace(+In, +Search, +Replace, -Out)
        replace(In, Search, Replace, Out) :-
            text_list([In, Search, Replace], [InCodes, SearchCodes, ReplaceCodes]),
            replace_list(InCodes, SearchCodes, ReplaceCodes, OutCodes),
            text_in_out(In, OutCodes, Out),
            !.
        replace(In, _, _, In).
        
        % replace_list(+In, +Search, +Replace, -Out)
        replace_list(In, Search, Replace, Out) :-
            append(Part1, Middle, In),
            append(Search, Part2, Middle),
            append([Part1, Replace, Part2], Out),
            !.
        
        %
        text_list([], []) :-
            !.
        text_list([Head|Teil], [Head1|Rest]) :-
            text_in_out(Head, Head1, Head),
            !,
            text_list(Teil, Rest).
        
        %
        text_in_out(In, OutCodes, Out) :-
            ( atom(In), atom_codes(Out, OutCodes)
            ; string(In), string_codes(Out, OutCodes)
            ; number(In), number_codes(Out, OutCodes)
            ; integer_list(In), Out = In ),
            !.
        
        %
        integer_list([]) :-
            !.
        integer_list([Head|Tail]) :-
            integer(Head),
            !,
            integer_list(Tail).
        
        %
        member_list([], _) :-
            !.
        member_list([Head|Tail], List) :-
            memberchk(Head, List),
            !,
            member_list(Tail, List).
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-07-11T11:30:56+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151189468_18175251
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "params"
      COMMENT: ~
      SCRIPT: | 
        % params
        
        %:- [lib].
        /* member_list */
        
        :-
            dynamic(param_list/3),
            multifile(param_list/3),
            discontiguous(param_list/3).
        
        % param_list(?Scope, ?Type, ?Pairs)
        %   Scope - name of context
        %   Type  - protocol support
        %       Client: in; data; got; restart; test; ...
        %       Server: run; query; temp; log; out; clean; error; ...
        %   Pairs - list of pairs Key-Value or mixed with other
        
        % new_param_list(+Scope, +Type, +Pairs)
        new_param_list(Scope, Type, Pairs) :-
            \+ param_list(Scope, Type, Pairs),
            assertz( param_list(Scope, Type, Pairs) ),
            !.
        new_param_list(_, _, _) :-
            !.
        
        % dispose_param_list(?Scope, ?Type, ?Pairs)
        dispose_param_list(Scope, Type, Pairs) :-
            retractall( param_list(Scope, Type, Pairs) ),
            !.
        
        % get_param(?Scope, ?Type, ?Param)
        get_param(Scope, Type, Param) :-
            param_list(Scope, Type, Pairs),
            memberchk(Param, Pairs).
        % get_param(?Scope, ?Type, ?Param, ?Pairs)
        get_param(Scope, Type, Param, Pairs) :-
            param_list(Scope, Type, Pairs),
            memberchk(Param, Pairs).
        
        % get_param_list(?Scope, ?Type, ?Params)
        get_param_list(Scope, Type, Params) :-
            param_list(Scope, Type, Pairs),
            member_list(Params, Pairs).
        % get_param_list(?Scope, ?Type, ?Params, ?Pairs)
        get_param_list(Scope, Type, Params, Pairs) :-
            param_list(Scope, Type, Pairs),
            member_list(Params, Pairs).
        
        %
        get_scope(Scope) :-
            setof(Scope, Type^Pairs^param_list(Scope, Type, Pairs), ScopeList),
            member(Scope, ScopeList).
        
        %
        get_scope_list(ScopeList) :-
            setof(Scope, Type^Pairs^param_list(Scope, Type, Pairs), ScopeList),
            !.
        
        %
        get_type(Type) :-
            setof(Type, Scope^Pairs^param_list(Scope, Type, Pairs), TypeList),
            member(Type, TypeList).
        
        %
        get_type_list(TypeList) :-
            setof(Type, Scope^Pairs^param_list(Scope, Type, Pairs), TypeList),
            !.
        
        %
        get_scope_type(Scope-Type) :-
            setof(Scope-Type, Pairs^param_list(Scope, Type, Pairs), ScopeTypeList),
            member(Scope-Type, ScopeTypeList).
        
        %
        get_scope_type_list(ScopeTypeList) :-
            setof(Scope-Type, Pairs^param_list(Scope, Type, Pairs), ScopeTypeList),
            !.
        
        %
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-04-17T11:11:57+03:00
  - 
    Properties: 
      Class: "TgdcFunction"
      RUID: 151042959_187967073
      AlwaysOverwrite: False
      DontRemove: False
      IncludeSiblings: False
    Fields: 
      OBJECTNAME: "APPLICATION"
      MODULE: "PROLOG"
      LANGUAGE: "VBScript"
      NAME: "wg_data_mix"
      COMMENT: ~
      SCRIPT: | 
        %% wg_data_mix
        %  смешанные данные для twg_avg_wage, twg_fee
        %
        
        %:- ['../gd_pl_state/date', '../gd_pl_state/dataset'].
        %:- ['../common/lib', '../common/params'].
        
        /* реализация - общий код */
        
        % взять БВ
        get_min_wage(Scope, DateCalcTo, MinWage) :-
            findall( MinWage0,
                          % взять данные по БВ
                        ( get_data(Scope, kb, usr_wg_FCRate, [
                                    fDate-Date, fMinWage-MinWage0]),
                          % где дата константы меньше первой даты месяца
                          Date @< DateCalcTo
                        ),
            % в список БВ
            MinWageList),
            % последние данные по БВ
            last(MinWageList, MinWage),
            !.
        get_min_wage(_, _, 0) :-
            !.
        
        % взять БПМ
        get_budget(Scope, DateCalcTo, Budget) :-
            findall( Budget0,
                          % взять данные по БПМ
                        ( get_data(Scope, kb, gd_const_budget, [
                                    fConstDate-ConstDate, fBudget-Budget0]),
                          % где дата константы меньше первой даты месяца
                          ConstDate @< DateCalcTo
                        ),
            % в список БПМ
            BudgetList),
            % последние данные по БПМ
            last(BudgetList, Budget),
            !.
        get_budget(_, _, 0) :-
            !.
        
        % взять дату последнего приема на работу
        get_last_hire(Scope, PK, DateIn) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять даты
            findall( EmplKey-FirstMoveKey-DateIn0,
                     % для первого движения по типу 1 (прием на работу)
                     get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey,
                                 fDocumentKey-FirstMoveKey, fFirstMoveKey-FirstMoveKey,
                                 fDateBegin-DateIn0, fMovementType-1 ]),
            % в список дат приема на работу
            DateInList ),
            % определить дату последнего приема на работу
            last(DateInList, EmplKey-FirstMoveKey-DateIn),
            !.
        
        % формирование временных данных по графику работы
        make_schedule(Scope, PK) :-
            % временные данные по графику работы уже есть
            get_param_list(Scope, temp, [pScheduleKey-_|PK]),
            !.
        make_schedule(Scope, PK) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять данные по движению
            findall( Date-ScheduleKey,
                     get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                 fDateBegin-Date, fScheduleKey-ScheduleKey]),
            MoveList ),
            % взять дату ограничения расчета
            get_param_list(Scope, run, [pDateCalcTo-DateCalcTo|PK]),
            % добавить временные данные по графику работы
            add_schedule(Scope, PK, MoveList, DateCalcTo),
            !.
        
        % добавить временные данные по графику работы
        add_schedule(_, _, [], _) :-
            !.
        add_schedule(Scope, PK, [DateFrom-ScheduleKey], DateCalcTo) :-
            append(PK,
                    [pDateFrom-DateFrom, pDateTo-DateCalcTo, pScheduleKey-ScheduleKey],
                        Pairs),
            new_param_list(Scope, temp, Pairs),
            !.
        add_schedule(Scope, PK, [DateFrom-ScheduleKey, DateTo-ScheduleKey1 | MoveList], DateCalcTo) :-
            append(PK,
                    [pDateFrom-DateFrom, pDateTo-DateTo, pScheduleKey-ScheduleKey],
                        Pairs),
            new_param_list(Scope, temp, Pairs),
            !,
            add_schedule(Scope, PK, [DateTo-ScheduleKey1 | MoveList], DateCalcTo).
        
        % взять последний график рабочего времени
        get_last_schedule(Scope, PK, ScheduleKey) :-
            % разложить первичный ключ
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            % взять график
            findall( ScheduleKey0,
                     % для движения по сотруднику
                     get_data(Scope, kb, usr_wg_MovementLine, [
                                 fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                                 fScheduleKey-ScheduleKey0]),
            % в список графиков
            ScheduleKeyList ),
            % определить последний график рабочего времени
            last(ScheduleKeyList, ScheduleKey),
            !.
        
        % проверить вхождение даты в график
        check_schedule(Scope, PK, TheDay, ScheduleKey) :-
            append(PK,
                    [pDateFrom-DateFrom, pDateTo-DateTo, pScheduleKey-ScheduleKey],
                        Pairs),
            get_param_list(Scope, temp, Pairs),
            TheDay @>= DateFrom, TheDay @< DateTo,
            !.
        check_schedule(Scope, PK, _, ScheduleKey) :-
            get_last_schedule(Scope, PK, ScheduleKey),
            !.
        
        % расчитать табель за месяц по одному из параметров
        calc_month_tab(Scope, PK, Y-M, TabDays) :-
            % параметры выбора табеля
            member(TabelOption, [tbl_cal_flex, tbl_cal, tbl_charge, dbf_sums]),
            % взять данные из табеля
            findall( Date-DOW-HOW,
                    % для проверяемого месяца
                    ( usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, DOW, HOW, _, TabelOption),
                    % с контролем наличия дней или часов
                    once( ( DOW > 0 ; HOW > 0 ) )
                    ),
            % в список дата-день-часы
            TabDays),
            % проверить список табеля
            \+ TabDays = [],
            !.
        calc_month_tab(_, _, _, []) :-
            !.
        
        % сумма дней и часов
        sum_days_houres(ListDays, Days, Houres) :-
            sum_days_houres(ListDays, Days, Houres, '', ''),
            !.
        sum_days_houres(ListDays, Days, Houres, DateBegin, DateEnd) :-
            sum_days_houres(ListDays, Days, Houres, 0, 0, DateBegin, DateEnd),
            !.
        %
        sum_days_houres([], Days, Houres, Days, Houres, _, _).
        sum_days_houres([Date-DOW-HOW|ListDays], Days, Houres, Days0, Houres0, DateBegin, DateEnd) :-
              % если в заданном периоде
            ( ( Date @>= DateBegin, Date @=< DateEnd
              % или полный расчет
              ; [DateBegin, DateEnd] = ['', '']
              ),
              % то добавить дни и часы
              Days1 is Days0 + DOW,
              Houres1 is Houres0 + HOW
            ; % иначе исключать
              Days1 is Days0,
              Houres1 is Houres0
            ),
            !,
            sum_days_houres(ListDays, Days, Houres, Days1, Houres1, DateBegin, DateEnd).
        
        /* реализация - смешанные данные */
        
        %% взять данные по начислению
        % начисление из TblCharge
        usr_wg_TblCharge_mix(Scope, ArgPairs, ChargeOption) :-
            ChargeOption = tbl_charge,
            get_data(Scope, kb, usr_wg_TblCharge, [fPayPeriod-PayPeriod|ArgPairs]),
            once( ( PayPeriod < 2
                  ; \+ memberchk(Scope, [wg_avg_wage_avg]) )
                ).
        % или начисление из dbf
        % с согласованием спецификации по TblCharge
        usr_wg_TblCharge_mix(Scope, ArgPairs, ChargeOption) :-
            ChargeOption = dbf_sums,
            % спецификация usr_wg_TblCharge
            ValuePairs = [
                        fEmplKey-EmplKey, fFirstMoveKey-_,
                        fCalYear-CalYear, fCalMonth-CalMonth, fDateBegin-DateBegin,
                        fDebit-Debit, fFeeTypeKey-_
                        ],
            member_list(ArgPairs, ValuePairs),
            % спецификация usr_wg_DbfSums
            DataPairs =  [
                        fEmplKey-EmplKey,
                        fInYear-CalYear, fInMonth-CalMonth, fDateBegin-DateBegin,
                        fInSum-Debit
                        ],
            get_data(Scope, kb, usr_wg_DbfSums, DataPairs).
        
        %% взять данные по графику
        % день месяца по календарному графику
        usr_wg_TblDayNorm_mix(Scope, PK, Y-M, Date, Duration, WorkDay, NormOption) :-
            NormOption = tbl_cal_flex,
            get_Flex_by_type(Scope, PK, Y-M, Date, WorkDay, Duration, _, "plan").
        % или день месяца по справочнику графика рабочего времени
        usr_wg_TblDayNorm_mix(Scope, PK, Y-M, TheDay, WDuration, WorkDay, NormOption) :-
            NormOption = tbl_day_norm,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_data(Scope, kb, usr_wg_TblCalDay, [
                        fScheduleKey-ScheduleKey,
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fWYear-Y, fWMonth-M, fTheDay-TheDay,
                        fWDuration-WDuration, fWorkDay-WorkDay ]),
            check_schedule(Scope, PK, TheDay, ScheduleKey).
        
        %% взять данные по табелю
        % день месяца по табелю мастера
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, Days, Duration, HoureType, TabelOption) :-
            TabelOption = tbl_cal_flex,
            get_Flex_by_type(Scope, PK, Y-M, Date, Days, Duration, HoureType, "fact").
        % или день месяца по табелю
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, Days, Duration, HoureType, TabelOption) :-
            TabelOption = tbl_cal,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            get_data(Scope, kb, usr_wg_TblCalLine, [
                        fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDate-Date,
                        fDuration-Duration, fHoureType-HoureType]),
            once( (Duration > 0, Days = 1 ; Days = 0) ).
        % или табель дни-часы из начислений
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, DOW, HOW, 0, TabelOption) :-
            TabelOption = tbl_charge,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            ArgPairs = [fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                        fCalYear-Y, fCalMonth-M, fDateBegin-Date,
                        fFeeTypeKey-FeeTypeKey, fDOW-DOW, fHOW-HOW],
            get_data(Scope, kb, usr_wg_TblCharge, [fPayPeriod-_|ArgPairs]),
            once( get_data(Scope, kb, usr_wg_FeeType, [
                            fEmplKey-EmplKey, fFirstMoveKey-FirstMoveKey,
                            fFeeTypeKey-FeeTypeKey, fAvgDayHOW-1]) ).
        % или день месяца из dbf
        usr_wg_TblCalLine_mix(Scope, PK, Y-M, Date, 0, InHoures, 0, TabelOption) :-
            TabelOption = dbf_sums,
            PK = [pEmplKey-EmplKey, pFirstMoveKey-_],
            get_data(Scope, kb, usr_wg_DbfSums, [
                        fEmplKey-EmplKey, fInHoures-InHoures,
                        fInYear-Y, fInMonth-M, fDateBegin-Date]).
        
        % день месяца по календарному графику или табелю мастера
        % FlexType: "plan" ; "fact"
        get_Flex_by_type(Scope, PK, Y-M, Date, Days, Duration, HoureType, FlexType) :-
            PK = [pEmplKey-EmplKey, pFirstMoveKey-FirstMoveKey],
            gd_pl_ds(Scope, kb, usr_wg_TblCal_FlexLine, 68, _),
            make_list(62, TeilArgs),
            Term =..[ usr_wg_TblCal_FlexLine, FlexType, EmplKey, FirstMoveKey, Y, M, _ | TeilArgs ],
            catch( call( Term ), _, fail),
            member(D, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]),
            atom_date(Date, date(Y, M, D)),
            S is (D - 1) * 2 + 6 + 1,
            H is S + 1,
            arg(S, Term, Duration0),
            once( ( number(Duration0), Duration = Duration0
                    ; atom_number(Duration0, Duration)
                    ; Duration = 0 ) ),
            arg(H, Term, HoureType0),
            once( ( number(HoureType0), HoureType = HoureType0
                    ; atom_number(HoureType0, HoureType)
                    ; HoureType = 0 ) ),
            once( (Duration > 0, Days = 1 ; Days = 0) ).
        
        /**/
        
         %
        %%
        
        
      DISPLAYSCRIPT: ~
      MODIFYDATE: ~
      OWNERNAME: ~
      FUNCTIONTYPE: ~
      EVENT: ~
      LOCALNAME: ~
      PUBLICFUNCTION: 1
      SHORTCUT: ~
      GROUPNAME: ~
      MODULECODE: "1010001_17 APPLICATION"
      ENTEREDPARAMS: ~
      INHERITEDRULE: 0
      USEDEBUGINFO: 0
      EDITIONDATE: 2014-07-02T17:07:33+03:00